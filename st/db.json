{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/Vateral/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/Vateral/source/css/Vateral.min.css","path":"css/Vateral.min.css","modified":0,"renderable":1},{"_id":"themes/Vateral/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/Vateral/source/css/magnific-popup.css","path":"css/magnific-popup.css","modified":0,"renderable":1},{"_id":"themes/Vateral/source/css/Vateral.css","path":"css/Vateral.css","modified":0,"renderable":1},{"_id":"themes/Vateral/source/css/main.min.css","path":"css/main.min.css","modified":0,"renderable":1},{"_id":"themes/Vateral/source/css/nprogress.css","path":"css/nprogress.css","modified":0,"renderable":1},{"_id":"themes/Vateral/source/css/nprogress.min.css","path":"css/nprogress.min.css","modified":0,"renderable":1},{"_id":"themes/Vateral/source/css/templatemo_style.css","path":"css/templatemo_style.css","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/MaterialIcons-Regular.woff","path":"fonts/MaterialIcons-Regular.woff","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/MaterialIcons-Regular.woff2","path":"fonts/MaterialIcons-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/header.png","path":"images/header.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/LICENSE.md","path":"js/LICENSE.md","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/README.md","path":"js/README.md","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/Vateral.js","path":"js/Vateral.js","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/Vateral.min.js","path":"js/Vateral.min.js","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/bower.json","path":"js/bower.json","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/exif.js","path":"js/exif.js","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/jquery.easing.1.3.js","path":"js/jquery.easing.1.3.js","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/jquery.magnific-popup.min.js","path":"js/jquery.magnific-popup.min.js","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/jquery.rotate.min.js","path":"js/jquery.rotate.min.js","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/jquery.pjax.min.js","path":"js/jquery.pjax.min.js","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/main.min.js","path":"js/main.min.js","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/modernizr.2.5.3.min.js","path":"js/modernizr.2.5.3.min.js","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/lazyload.min.js","path":"js/lazyload.min.js","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/package.json","path":"js/package.json","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/nprogress.min.js","path":"js/nprogress.min.js","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/photopage.js","path":"js/photopage.js","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/templatemo_script.js","path":"js/templatemo_script.js","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/nprogress.js","path":"js/nprogress.js","modified":0,"renderable":1},{"_id":"themes/Vateral/source/css/materialize.min.css","path":"css/materialize.min.css","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/MaterialIcons-Regular.ttf","path":"fonts/MaterialIcons-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/jquery-3.1.1.min.js","path":"js/jquery-3.1.1.min.js","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/MaterialIcons-Regular.eot","path":"fonts/MaterialIcons-Regular.eot","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Bold.eot","path":"fonts/roboto/Roboto-Bold.eot","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Bold.woff","path":"fonts/roboto/Roboto-Bold.woff","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Light.woff","path":"fonts/roboto/Roboto-Light.woff","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Light.woff2","path":"fonts/roboto/Roboto-Light.woff2","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Light.eot","path":"fonts/roboto/Roboto-Light.eot","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Medium.eot","path":"fonts/roboto/Roboto-Medium.eot","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Medium.woff","path":"fonts/roboto/Roboto-Medium.woff","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Medium.woff2","path":"fonts/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Regular.eot","path":"fonts/roboto/Roboto-Regular.eot","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Regular.woff","path":"fonts/roboto/Roboto-Regular.woff","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Regular.woff2","path":"fonts/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Bold.woff2","path":"fonts/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Thin.eot","path":"fonts/roboto/Roboto-Thin.eot","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Thin.woff","path":"fonts/roboto/Roboto-Thin.woff","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Thin.woff2","path":"fonts/roboto/Roboto-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/header-bg.png","path":"images/header-bg.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/link/all.png","path":"images/link/all.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/materialize.min.js","path":"js/materialize.min.js","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Bold.ttf","path":"fonts/roboto/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Light.ttf","path":"fonts/roboto/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Medium.ttf","path":"fonts/roboto/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Regular.ttf","path":"fonts/roboto/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Thin.ttf","path":"fonts/roboto/Roboto-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-13.png","path":"images/random/vateral-13.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-16.png","path":"images/random/vateral-16.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-17.png","path":"images/random/vateral-17.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-6.png","path":"images/random/vateral-6.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-15.png","path":"images/random/vateral-15.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-4.png","path":"images/random/vateral-4.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/coverpic.png","path":"images/coverpic.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-10.png","path":"images/random/vateral-10.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-12.png","path":"images/random/vateral-12.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-9.png","path":"images/random/vateral-9.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-3.png","path":"images/random/vateral-3.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-11.png","path":"images/random/vateral-11.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-19.png","path":"images/random/vateral-19.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-8.png","path":"images/random/vateral-8.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-1.png","path":"images/random/vateral-1.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-2.png","path":"images/random/vateral-2.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/Roboto-Black.ttf","path":"fonts/Roboto-Black.ttf","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/Roboto-Bold.ttf","path":"fonts/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/Roboto-Light.ttf","path":"fonts/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/Roboto-Medium.ttf","path":"fonts/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/Roboto-Regular.ttf","path":"fonts/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/Vateral/source/fonts/Roboto-Thin.ttf","path":"fonts/Roboto-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-7.png","path":"images/random/vateral-7.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-18.png","path":"images/random/vateral-18.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-5.png","path":"images/random/vateral-5.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/vateral-14.png","path":"images/random/vateral-14.png","modified":0,"renderable":1},{"_id":"themes/Vateral/source/js/spec/Exif2-2.pdf","path":"js/spec/Exif2-2.pdf","modified":0,"renderable":1},{"_id":"themes/Vateral/source/images/random/moumao_hexo-theme-Vateral_ hexo主题-Vateral（a theme of hexo named as Vateral）.webarchive","path":"images/random/moumao_hexo-theme-Vateral_ hexo主题-Vateral（a theme of hexo named as Vateral）.webarchive","modified":0,"renderable":1}],"Cache":[{"_id":"themes/Vateral/.bowerrc","hash":"5d8502d31f0ed07e935bc6faf5e7f8ce8308ab75","modified":1498473950000},{"_id":"themes/Vateral/README.md","hash":"8732c0bbbb06640b10932cd8e4beabade6d65698","modified":1498473950000},{"_id":"themes/Vateral/_config.yml","hash":"060bb6f37bb25b759b93b44ec23fdbab79f2c89a","modified":1504605859678},{"_id":"themes/Vateral/bower.json","hash":"03be72b7b0ba2db4acfea95ee4cf652725737b2f","modified":1498473950000},{"_id":"themes/Vateral/package.json","hash":"ffa0ab58475ceb2efd85de6d04ea7b50b4752316","modified":1498473950000},{"_id":"source/Category/index.md","hash":"e4788276a1263ae4d7f5fc2647fa666f2a6e5fd0","modified":1504604626582},{"_id":"source/_posts/Gradle的一些小知识-不定期更新.md","hash":"e7b307a7dec5da0bb0e879c3aaa7536ba2a58c4b","modified":1515138531508},{"_id":"source/_posts/Hexo-github搭建个人博客.md","hash":"70c78b0f35f4fd64d374a92bbb4fbe5b9ebb72cd","modified":1515119792322},{"_id":"source/_posts/MotionLayout.md","hash":"45eab0ac0cdcb83b9dbfaf507c2b75032e8ab50b","modified":1534736327359},{"_id":"source/_posts/LinearLayoutManager源码阅读（滑动）.md","hash":"46895af10735307d6f843dff7f60c898de0bc09c","modified":1516694825241},{"_id":"source/_posts/Parcelable.md","hash":"17d2a4f92661812dca3f6ed8d4f8f32adad362ca","modified":1516178281665},{"_id":"source/_posts/ProducerArbiter.md","hash":"283301a56db26fcf556035321c82e1102241b1bb","modified":1534413324474},{"_id":"source/_posts/RxJava-Scheduler一点理解.md","hash":"a43572f73eb7c073cb4ef356d9ee9cfc15ee12df","modified":1534387007202},{"_id":"source/_posts/RxJava中的-Producer.md","hash":"732cfa4dd499a665f965fadf3032bf05b519cea8","modified":1534737133053},{"_id":"source/_posts/SpanTextView.md","hash":"52fb43565c93fe35411053f1a2d8301c87cc9290","modified":1506330821741},{"_id":"source/_posts/Rxjava-retryWhen和repeatWhen操作符原理.md","hash":"489cbf23879ab2a3396215c290d42d36c7f6d73c","modified":1534382801674},{"_id":"source/_posts/SpanTextView的错误.md","hash":"1846eb20aded9cbd099ead154845ab0cf1d5ab66","modified":1519353446673},{"_id":"source/_posts/关于AndroidStudio下的idea目录.md","hash":"c2ea8f76eec9c5374049d0ebd27ee704742122e9","modified":1516785052684},{"_id":"source/_posts/关于DataBinding的一些知识.md","hash":"4bcec1d09ae3f6d1149544e62f554532574b5008","modified":1523522935370},{"_id":"source/_posts/自行处理Fling导致RecyclerView-滑动点击事件无效.md","hash":"703edc0e408049b4cc6302d7a165502628c308b2","modified":1522632295558},{"_id":"source/_posts/关于事件机制的总结.md","hash":"4a263b02d8a4dc280d282b3e08a7ebfdd676a14b","modified":1524130523185},{"_id":"source/_posts/关于RecyclerView的一个有趣的事情.md","hash":"45d5daad5319e23a0b5ff9489cd66ace398483d2","modified":1516435613688},{"_id":"source/categories/index.md","hash":"011cabfb4e8986a73ad64f807c185f229b20bd4d","modified":1504604899182},{"_id":"source/tags/index.md","hash":"0e250686ae30c9ac64a63b40b52578bea4720b7e","modified":1504584432902},{"_id":"themes/Vateral/.idea/modules.xml","hash":"e8d632f5927e396a98c2badb2bef54c55df499b4","modified":1498473950000},{"_id":"themes/Vateral/.idea/jsLibraryMappings.xml","hash":"3057cb9aa5f72d93b27b0fa4e16d257b6115d28e","modified":1498473950000},{"_id":"themes/Vateral/.idea/vcs.xml","hash":"c92f3eb0ad1c70371e177a4d7d741f90af3f902c","modified":1498473950000},{"_id":"themes/Vateral/.idea/watcherTasks.xml","hash":"712597f3a6fe3b5da4b357499e8314ab21a512e2","modified":1498473950000},{"_id":"themes/Vateral/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1498473950000},{"_id":"themes/Vateral/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1498473950000},{"_id":"themes/Vateral/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1498473950000},{"_id":"themes/Vateral/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1498473950000},{"_id":"themes/Vateral/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1498473950000},{"_id":"themes/Vateral/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1498473950000},{"_id":"themes/Vateral/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1498473950000},{"_id":"themes/Vateral/layout/about.ejs","hash":"dce19d0743772b2d8624bc880394f57de18e28e2","modified":1498473950000},{"_id":"themes/Vateral/layout/archive.ejs","hash":"681e58b87971b409f41fb94b5142715731437c6d","modified":1498473950000},{"_id":"themes/Vateral/layout/category.ejs","hash":"3c627467358b91cfab881460f0ccca313c773d7c","modified":1498473950000},{"_id":"themes/Vateral/layout/index.ejs","hash":"387a5d7991e8867b6ab97bfd87e166a7575d9d77","modified":1498473950000},{"_id":"themes/Vateral/layout/friends.ejs","hash":"7e83c779ba084c8076a8fc74e082aab0efb00f2c","modified":1498473950000},{"_id":"themes/Vateral/layout/layout.ejs","hash":"6be4eb06bc34d567547ff31c2ac2319efa160329","modified":1498473950000},{"_id":"themes/Vateral/layout/photo.ejs","hash":"e7617aa82d5a4e3ed475f2f8f1c4d12dd1434fd6","modified":1498473950000},{"_id":"themes/Vateral/layout/post.ejs","hash":"f8c9ac2b8da05eeac4bc7e200740d01988cac549","modified":1498473950000},{"_id":"themes/Vateral/layout/tag.ejs","hash":"3c93eecaf26931c03aed2dd37a66281415c6b97e","modified":1498473950000},{"_id":"themes/Vateral/.idea/misc.xml","hash":"7df46872d1421797d543d0323da2e81710cc573d","modified":1498473950000},{"_id":"themes/Vateral/.idea/Vateral.iml","hash":"4240dabdc746a36bae8a56eeec04a3a3fc59d842","modified":1498473950000},{"_id":"themes/Vateral/.idea/workspace.xml","hash":"89c102beacde1845f541a726cef2a27c6a1a321d","modified":1498473950000},{"_id":"themes/Vateral/source/favicon.ico","hash":"b3f04351ed05e6c65ea7ea19dfed5b1839cacefc","modified":1498473950000},{"_id":"themes/Vateral/layout/partials/footer.ejs","hash":"74354d54966e3f2219ff151c6bc7779c8785d22a","modified":1498473950000},{"_id":"themes/Vateral/layout/partials/nav-left-head.ejs","hash":"f8de62a6899eb43640b11dec00a25fc0c70badd0","modified":1498473950000},{"_id":"themes/Vateral/layout/partials/nav-left-list.ejs","hash":"d33b6d0ff9cd1de2214dc8a0d210c9a0bb1911c5","modified":1498473950000},{"_id":"themes/Vateral/layout/partials/nav-left.ejs","hash":"fa2ef9a890ccaf78aa9e1b24b29308205726c1a9","modified":1498473950000},{"_id":"themes/Vateral/layout/partials/pagination.ejs","hash":"3f3681ece3b5bead885ee9272775a56166543826","modified":1498473950000},{"_id":"themes/Vateral/layout/partials/recent-head.ejs","hash":"ac6cb5da5f782f122ae89639b52c4f78c2dce7d8","modified":1498473950000},{"_id":"themes/Vateral/layout/partials/recent-posts-noup.ejs","hash":"a88381e7e0a521eeb971e7c4f9da7ec247056c03","modified":1498473950000},{"_id":"themes/Vateral/layout/partials/recent-posts.ejs","hash":"50267d572f6b824b74e7709b75a55317f5c1c211","modified":1498473950000},{"_id":"themes/Vateral/source/css/Vateral.min.css","hash":"24f551bd5bc4426ad3c4e3c94f591360682fc93e","modified":1498473950000},{"_id":"themes/Vateral/source/css/font-awesome.min.css","hash":"c068cd49f2dd57e8162c1ad380fc63f0ec59cb1a","modified":1498473950000},{"_id":"themes/Vateral/source/css/magnific-popup.css","hash":"8158ea6f0b9851a3e574c3f531843f703b7a0ec0","modified":1498473950000},{"_id":"themes/Vateral/source/css/Vateral.css","hash":"4d53e0ab96388f0fc4321e4119d374c65c98889e","modified":1498473950000},{"_id":"themes/Vateral/source/css/main.min.css","hash":"090bc31729b28a6afdc2eb8c4679ff50e3e213c0","modified":1498473950000},{"_id":"themes/Vateral/source/css/nprogress.css","hash":"17ca817a091da9dcf5fe0f2f1e1f2eea60a33149","modified":1498473950000},{"_id":"themes/Vateral/source/css/nprogress.min.css","hash":"eb76839f8583abb84141cf60fd28058841740e7b","modified":1498473950000},{"_id":"themes/Vateral/source/css/templatemo_style.css","hash":"0b55b4ae7eb8c8ce5cbe0705bd3b8c95c83a1868","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/MaterialIcons-Regular.woff","hash":"c6c953c2ccb2ca9abb21db8dbf473b5a435f0082","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/MaterialIcons-Regular.woff2","hash":"09963592e8c953cc7e14e3fb0a5b05d5042e8435","modified":1498473950000},{"_id":"themes/Vateral/source/images/header.png","hash":"8ce504534e37325732140741efdc432a62e9273f","modified":1498473950000},{"_id":"themes/Vateral/source/js/LICENSE.md","hash":"8fce083aa639d11058fdd01c85190dce87560241","modified":1498473950000},{"_id":"themes/Vateral/source/js/README.md","hash":"fdbf6fee26e9bed79ad203972a3ca386e14e4361","modified":1498473950000},{"_id":"themes/Vateral/source/js/Vateral.js","hash":"064910ed67045e9b317f8c776f6ce0a68000e114","modified":1498473950000},{"_id":"themes/Vateral/source/js/Vateral.min.js","hash":"caf0283803553d1bc703321e1baebf9c2d664e38","modified":1498473950000},{"_id":"themes/Vateral/source/js/bower.json","hash":"9678ebb17f62024aa21eeae4f4c9af43492f5768","modified":1498473950000},{"_id":"themes/Vateral/source/js/exif.js","hash":"0f584529ef7ec601eaddbee27fde6edbc2e82ccc","modified":1498473950000},{"_id":"themes/Vateral/source/js/jquery.easing.1.3.js","hash":"083a2d30bc0f76cc160a8bb00646750c6ce6a260","modified":1498473950000},{"_id":"themes/Vateral/source/js/jquery.magnific-popup.min.js","hash":"9a45cea8875b8e067276f942eb8ba5d08e820cc9","modified":1498473950000},{"_id":"themes/Vateral/source/js/jquery.pjax.js","hash":"13485a1e2dc9c8df28267549de1b8af8f39061d9","modified":1498473950000},{"_id":"themes/Vateral/source/js/jquery.rotate.min.js","hash":"d1645449a3b0d85052c6055474da9d2cb49a880f","modified":1498473950000},{"_id":"themes/Vateral/source/js/jquery.pjax.min.js","hash":"b0b664e2b31e4bd0d271493c55946644817611bb","modified":1498473950000},{"_id":"themes/Vateral/source/js/main.min.js","hash":"ad84aa92b5a2ca364fc0bd9c10fafbd61bc2de73","modified":1498473950000},{"_id":"themes/Vateral/source/js/modernizr.2.5.3.min.js","hash":"7bac5df50deb223d46964a2c980a6bfabf57767a","modified":1498473950000},{"_id":"themes/Vateral/source/js/lazyload.min.js","hash":"5348fd7aa4dbefac9d21091c9fd5e263563b5540","modified":1498473950000},{"_id":"themes/Vateral/source/js/package.json","hash":"59c850f26dd573f570a1363c93c7a767ddb8d578","modified":1498473950000},{"_id":"themes/Vateral/source/js/nprogress.min.js","hash":"a51a498e06f2198e9ac07de6efb45bce140d2c01","modified":1498473950000},{"_id":"themes/Vateral/source/js/photopage.js","hash":"125860b6ece132e64199315658bd9a73d734e344","modified":1498473950000},{"_id":"themes/Vateral/source/js/templatemo_script.js","hash":"38817e0337a13a22b0f8194ddd76ce8b7e5c7967","modified":1498473950000},{"_id":"themes/Vateral/source/js/nprogress.js","hash":"a7e1146d2021c42e68b599dc8bcc69d44fc31df3","modified":1498473950000},{"_id":"themes/Vateral/source/css/materialize.min.css","hash":"031f08da08b5e0fbde71927fb0860f08c6874989","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/FontAwesome.otf","hash":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/MaterialIcons-Regular.ttf","hash":"fc05de31234e0090f7ddc28ce1b23af4026cb1da","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/fontawesome-webfont.eot","hash":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/fontawesome-webfont.woff","hash":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/fontawesome-webfont.woff2","hash":"638c652d623280a58144f93e7b552c66d1667a11","modified":1498473950000},{"_id":"themes/Vateral/source/js/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/MaterialIcons-Regular.eot","hash":"26fb8cecb5512223277b4d290a24492a0f09ede1","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/fontawesome-webfont.ttf","hash":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1498473950000},{"_id":"themes/Vateral/source/images/header-bg.png","hash":"7c271fc2b851c8e1f2c5e313a60a7864851d728e","modified":1498473950000},{"_id":"themes/Vateral/source/images/link/all.png","hash":"4187499cc20689a582300bfcb26576252a188d5d","modified":1498473950000},{"_id":"themes/Vateral/source/js/materialize.min.js","hash":"55bbdc929aeca8fe2136a6907b5f6f2e50d6a9a1","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-13.png","hash":"1a8378db3121b583485e2b939cb1aa0e0b14b0c8","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-16.png","hash":"ade7f75200d3fb38326e3cf1e9f1a812fb12a43b","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-17.png","hash":"9c463f96d4dadae4e67932c2d7ed1e353c4ecca8","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-6.png","hash":"29dd92b7c110bb6dfdfc2923c33f5d0895518001","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-15.png","hash":"36b9937cf3810e4970902b78797ad29b0831f065","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-4.png","hash":"171d9290b89a8e102d33f5a5c3f2d003cc20fe9f","modified":1498473950000},{"_id":"themes/Vateral/source/images/coverpic.png","hash":"c5fc2ec66660f48be0fb092a872d4058e9d9e68f","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-10.png","hash":"021dca8d2477dae8f456a0cdc2725502d3b45785","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-12.png","hash":"ba0c8506af62f984da564e6e390f592475e51f2d","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-9.png","hash":"bc4f1b42fd2d09a80ab5fef8c6066b5148db0749","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-3.png","hash":"a7f86a309712b9bbb01a4b7b39b1ee429df9086a","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/fontawesome-webfont.svg","hash":"b06b5c8f67fd632cdc62a33b62ae4f74194131b3","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-11.png","hash":"637d4513d1e7beeb1e5179fa404b4b6ea61ca3dd","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-19.png","hash":"f0b5383ba5c7e91f711daaa6b3a520556b7ca14d","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-8.png","hash":"cb700661e312a5527aaf229517705adb1c1cead2","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-1.png","hash":"af4b0ad72ce30f3fd7f7435cd3267b9187335ffd","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-2.png","hash":"c5fc2ec66660f48be0fb092a872d4058e9d9e68f","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/Roboto-Black.ttf","hash":"0244e6497a51fb8a38ca7e6fe297b066e2e09af5","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/Roboto-Bold.ttf","hash":"d1864343b543978bd491d40c80010cea50c1b7bf","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/Roboto-Light.ttf","hash":"b9ea2eaf26ff8fdcb5aee3e0c2c7a6084ebb6aac","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/Roboto-Medium.ttf","hash":"3965419aab480c184f66bc5e39c1719a373a4ef6","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/Roboto-Regular.ttf","hash":"06691e103d4d3ce1f1108d9b7d21254b714a41f8","modified":1498473950000},{"_id":"themes/Vateral/source/fonts/Roboto-Thin.ttf","hash":"ed5101c3a800f35e925603a406e0c2dc5278b96c","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-7.png","hash":"e4aa6d4e1b52f1c097f61b5205d5b71a412e1d80","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-18.png","hash":"1d5bacea5d57cc3e652a7c697bcb4fbcb11e20dc","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-5.png","hash":"e26c197b3a765bbdcc966e4fb368c8808e9d655d","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/vateral-14.png","hash":"f6bd9ceca7deb32c45b02a5d89014c7ee4748833","modified":1498473950000},{"_id":"themes/Vateral/source/js/spec/Exif2-2.pdf","hash":"9ecf2bc7ebab6ef1916839d9778804945173ee39","modified":1498473950000},{"_id":"themes/Vateral/source/images/random/moumao_hexo-theme-Vateral_ hexo主题-Vateral（a theme of hexo named as Vateral）.webarchive","hash":"16c2ed57bca5fd4bf075e13686d72171627922b7","modified":1498473950000}],"Category":[],"Data":[],"Page":[{"title":"Category","date":"2017-09-05T08:12:43.000Z","categories":"随笔 生活","_content":"","source":"Category/index.md","raw":"---\ntitle: Category\ndate: 2017-09-05 16:12:43\ncategories: 随笔 生活\n---\n","updated":"2017-09-05T09:43:46.582Z","path":"Category/index.html","comments":1,"layout":"page","_id":"cjl1qvaos0000y472h8b3bigh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-09-05T04:06:23.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: tags\ndate: 2017-09-05 12:06:23\ntype: \"categories\"\ncomments: false\n---\n","updated":"2017-09-05T09:48:19.182Z","path":"categories/index.html","layout":"page","_id":"cjl1qvar3001yy4724ft1d2bf","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2017-09-05T04:06:23.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2017-09-05 12:06:23\ntype: \"tags\"\ncomments: false\n---\n","updated":"2017-09-05T04:07:12.902Z","path":"tags/index.html","layout":"page","_id":"cjl1qvar4001zy4722ciwyqvz","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Gradle的一些小知识(不定期更新)","date":"2018-01-05T05:20:07.000Z","_content":"\n### 资源分包\n一次不小心点进去sourceSet进去，发现可以定义资源路径的;自己按照main目录下的结构一样创建了一个debug的SourceSet(新建的其他名字的都不行，debug和main可以)，然后在module的gradle中加入如下配置就等于是有两个res目录，这样可以让资源分类更清晰\n```groovy\n        sourceSets {\n            debug {\n                res.srcDirs(\"src/debug/res_debug\", \"src/debug/res\")\n            }\n\n        }\n```\n记得sync一下\n![](https://github.com/HirayClay/draft/blob/master/GradleSourceSet.png?raw=true)\n最后生成apk的时候两个sourceSet的东西会合并","source":"_posts/Gradle的一些小知识-不定期更新.md","raw":"---\ntitle: Gradle的一些小知识(不定期更新)\ndate: 2018-01-05 13:20:07\ntags:\n    - Gradle\n    - Android\n---\n\n### 资源分包\n一次不小心点进去sourceSet进去，发现可以定义资源路径的;自己按照main目录下的结构一样创建了一个debug的SourceSet(新建的其他名字的都不行，debug和main可以)，然后在module的gradle中加入如下配置就等于是有两个res目录，这样可以让资源分类更清晰\n```groovy\n        sourceSets {\n            debug {\n                res.srcDirs(\"src/debug/res_debug\", \"src/debug/res\")\n            }\n\n        }\n```\n记得sync一下\n![](https://github.com/HirayClay/draft/blob/master/GradleSourceSet.png?raw=true)\n最后生成apk的时候两个sourceSet的东西会合并","slug":"Gradle的一些小知识-不定期更新","published":1,"updated":"2018-01-05T07:48:51.508Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl1qvaou0001y4726ms0st71","content":"<h3 id=\"资源分包\"><a href=\"#资源分包\" class=\"headerlink\" title=\"资源分包\"></a>资源分包</h3><p>一次不小心点进去sourceSet进去，发现可以定义资源路径的;自己按照main目录下的结构一样创建了一个debug的SourceSet(新建的其他名字的都不行，debug和main可以)，然后在module的gradle中加入如下配置就等于是有两个res目录，这样可以让资源分类更清晰</p>\n<pre class=\"line-numbers language-groovy\"><code class=\"language-groovy\">        sourceSets <span class=\"token punctuation\">{</span>\n            debug <span class=\"token punctuation\">{</span>\n                res<span class=\"token operator\">.</span><span class=\"token function\">srcDirs</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"src/debug/res_debug\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"src/debug/res\"</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n\n        <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>记得sync一下<br><img src=\"https://github.com/HirayClay/draft/blob/master/GradleSourceSet.png?raw=true\" alt=\"\"><br>最后生成apk的时候两个sourceSet的东西会合并</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"资源分包\"><a href=\"#资源分包\" class=\"headerlink\" title=\"资源分包\"></a>资源分包</h3><p>一次不小心点进去sourceSet进去，发现可以定义资源路径的;自己按照main目录下的结构一样创建了一个debug的SourceSet(新建的其他名字的都不行，debug和main可以)，然后在module的gradle中加入如下配置就等于是有两个res目录，这样可以让资源分类更清晰</p>\n<pre><code class=\"groovy\">        sourceSets {\n            debug {\n                res.srcDirs(&quot;src/debug/res_debug&quot;, &quot;src/debug/res&quot;)\n            }\n\n        }\n</code></pre>\n<p>记得sync一下<br><img src=\"https://github.com/HirayClay/draft/blob/master/GradleSourceSet.png?raw=true\" alt=\"\"><br>最后生成apk的时候两个sourceSet的东西会合并</p>\n"},{"title":"Hexo+github搭建个人博客","date":"2017-09-05T06:04:10.000Z","_content":"很早之前就有人用hexo和github提供的page服务做个人博客了,不过了解一下就没有怎么关注了，最近有时间，看了一下官方文档，花了两个多小时，搭建了一个简单的个人博客，除了最开始搭建配置繁琐一点，后面写完一篇文章一个命令就发布，体验非常棒！\n### 新建主页仓库\n登录自己的github账户，新建一个仓库，比如我的用户名是HirayClay，那么我就新建一个名为\nHirayClay.github.io的仓库\n\n### hexo环境搭建\n\n首先要安装必要的软件，[Node.js](https://nodejs.org)和[Git](https://git-scm.com/),安装完成之后安装hexo\n```shell\n   $ npm install -g hexo-cli\n```\n我安装的是 3.3.3版本\nhexo安装好之后就可以用hexo命令创建一个站点了\n```shell\n    $ hexo init <folder_name>\n    $ cd <folder>\n    $ npm install\n```\n看一下创建的目录结构\n```\n    .\n    ├── _config.yml\n    ├── package.json\n    ├── scaffolds\n    ├── source\n    |   └── _posts\n    └── themes\n```\n\n其中_config.yml是配置文件，一些全局的重要配置都在这里面；package.json文件中声明了版本信息和依赖信息，scaffolds，即脚手架的意思，我们创建post的时候就是用的这个文件下的模板，里面默认有三种模板：draft、page、post，当然你也可以创建自己的模板；source目录下有个子目录_posts，顾名思义就是放我们文章的地方；最后themes就是存放主题的地方，可以下载三方的主题放在里面\n\n我们需要重点关注一下_config.yml文件里面几个地方\n\n```yaml\n    title: Blog\n    subtitle: hirayclay's blog\n    description:\n    author: hirayclay\n    language: zh\n    timezone: Asia/Shanghai\n```\ntitle：站点的标题，subtitle：站点子标题，description：站点描述 language:站点语言，这里配置的是中文，其他语言的参考这里[>>](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes),timezone即时区，这里用的中国北京时区，其他时区参考[>>](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)\n\n要注意一点的是，这里所有的配置“：”后面都需要有一个空格，不然最后解析生成时候会失败，这是YAML的语法\n\n```yaml\n    new_post_name: :title\n    default_layout: post\n```\n\nnew_post_name 即生成的post的名称，有一下几个配置：\n:title  \n:year   \n:month  \n:i_month    \n:day    \n:i_day \n我这里直接用title命名生成的post文件\n\n比如执行一下命令\n```shell\n    hexo new post \"MyNewPost\" \n```\n\n就会在source/_posts目录下生成 MyNewPost.md文件\n\n再看下语法高亮配置，比较简单，常用到的是否禁用和代码行数\n\n```yaml\n    highlight:\n    enable: false\n    line_number: true\n    auto_detect: false\n    tab_replace:\n```\n\n部署配置，第一步新建仓库的作用到了\n```yaml\n  deploy:\n  type: git\n  repo: git@github.com:HirayClay/HirayClay.github.io.git\n  branch: master\n```\n\n因为我们用的git提交到远程仓库的，所以type = git,以及仓库地址和分支名，这里的repo就是之前新建的仓库地址\n\n\n配置说完了，基本可以开写了\n\n首先 用 hexo new post <your_post_name> 创建一篇博客，然后source/_posts目录找到对应的博客打开编辑即可,可以给博客加tag，比如本博客的tag\n\n```yaml\n   ---\n    title: Hexo+github搭建个人博客\n    date: 2017-09-05 14:04:10\n    tags:\n        - hexo\n        - 博客\n    ---\n```\n\n至此基本的都配置完成了，用以下命令生成静态资源\n```shell\n    hexo generate\n```\n也可以写成\n```shell\n    hexo g\n```\n\n然后可以本地起一个服务进行预览\n```shell\n    hexo server\n```\n\n浏览器输入http://localhost:4000 进行查看\n\n\n用以下命令发布到git远程仓库\n```shell\n    hexo deploy\n```\n\n应该会弹出一个窗口让你你输入ssh-key的密码\n\n\n最后如果觉得默认主题不合适，可以去下载其他[主题](https://hexo.io/themes/)到 themes目录下，可以随意命名该目录下的主题文件夹，但是最后在_config.yml文件中配置主题时候一定要用文件夹的名字\n```yaml\n    theme: theme_folder_name\n```\n\nThe End","source":"_posts/Hexo-github搭建个人博客.md","raw":"---\ntitle: Hexo+github搭建个人博客\ndate: 2017-09-05 14:04:10\ntags:\n    - hexo\n    - 博客\n---\n很早之前就有人用hexo和github提供的page服务做个人博客了,不过了解一下就没有怎么关注了，最近有时间，看了一下官方文档，花了两个多小时，搭建了一个简单的个人博客，除了最开始搭建配置繁琐一点，后面写完一篇文章一个命令就发布，体验非常棒！\n### 新建主页仓库\n登录自己的github账户，新建一个仓库，比如我的用户名是HirayClay，那么我就新建一个名为\nHirayClay.github.io的仓库\n\n### hexo环境搭建\n\n首先要安装必要的软件，[Node.js](https://nodejs.org)和[Git](https://git-scm.com/),安装完成之后安装hexo\n```shell\n   $ npm install -g hexo-cli\n```\n我安装的是 3.3.3版本\nhexo安装好之后就可以用hexo命令创建一个站点了\n```shell\n    $ hexo init <folder_name>\n    $ cd <folder>\n    $ npm install\n```\n看一下创建的目录结构\n```\n    .\n    ├── _config.yml\n    ├── package.json\n    ├── scaffolds\n    ├── source\n    |   └── _posts\n    └── themes\n```\n\n其中_config.yml是配置文件，一些全局的重要配置都在这里面；package.json文件中声明了版本信息和依赖信息，scaffolds，即脚手架的意思，我们创建post的时候就是用的这个文件下的模板，里面默认有三种模板：draft、page、post，当然你也可以创建自己的模板；source目录下有个子目录_posts，顾名思义就是放我们文章的地方；最后themes就是存放主题的地方，可以下载三方的主题放在里面\n\n我们需要重点关注一下_config.yml文件里面几个地方\n\n```yaml\n    title: Blog\n    subtitle: hirayclay's blog\n    description:\n    author: hirayclay\n    language: zh\n    timezone: Asia/Shanghai\n```\ntitle：站点的标题，subtitle：站点子标题，description：站点描述 language:站点语言，这里配置的是中文，其他语言的参考这里[>>](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes),timezone即时区，这里用的中国北京时区，其他时区参考[>>](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)\n\n要注意一点的是，这里所有的配置“：”后面都需要有一个空格，不然最后解析生成时候会失败，这是YAML的语法\n\n```yaml\n    new_post_name: :title\n    default_layout: post\n```\n\nnew_post_name 即生成的post的名称，有一下几个配置：\n:title  \n:year   \n:month  \n:i_month    \n:day    \n:i_day \n我这里直接用title命名生成的post文件\n\n比如执行一下命令\n```shell\n    hexo new post \"MyNewPost\" \n```\n\n就会在source/_posts目录下生成 MyNewPost.md文件\n\n再看下语法高亮配置，比较简单，常用到的是否禁用和代码行数\n\n```yaml\n    highlight:\n    enable: false\n    line_number: true\n    auto_detect: false\n    tab_replace:\n```\n\n部署配置，第一步新建仓库的作用到了\n```yaml\n  deploy:\n  type: git\n  repo: git@github.com:HirayClay/HirayClay.github.io.git\n  branch: master\n```\n\n因为我们用的git提交到远程仓库的，所以type = git,以及仓库地址和分支名，这里的repo就是之前新建的仓库地址\n\n\n配置说完了，基本可以开写了\n\n首先 用 hexo new post <your_post_name> 创建一篇博客，然后source/_posts目录找到对应的博客打开编辑即可,可以给博客加tag，比如本博客的tag\n\n```yaml\n   ---\n    title: Hexo+github搭建个人博客\n    date: 2017-09-05 14:04:10\n    tags:\n        - hexo\n        - 博客\n    ---\n```\n\n至此基本的都配置完成了，用以下命令生成静态资源\n```shell\n    hexo generate\n```\n也可以写成\n```shell\n    hexo g\n```\n\n然后可以本地起一个服务进行预览\n```shell\n    hexo server\n```\n\n浏览器输入http://localhost:4000 进行查看\n\n\n用以下命令发布到git远程仓库\n```shell\n    hexo deploy\n```\n\n应该会弹出一个窗口让你你输入ssh-key的密码\n\n\n最后如果觉得默认主题不合适，可以去下载其他[主题](https://hexo.io/themes/)到 themes目录下，可以随意命名该目录下的主题文件夹，但是最后在_config.yml文件中配置主题时候一定要用文件夹的名字\n```yaml\n    theme: theme_folder_name\n```\n\nThe End","slug":"Hexo-github搭建个人博客","published":1,"updated":"2018-01-05T02:36:32.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl1qvap00002y472fzegd4y1","content":"<p>很早之前就有人用hexo和github提供的page服务做个人博客了,不过了解一下就没有怎么关注了，最近有时间，看了一下官方文档，花了两个多小时，搭建了一个简单的个人博客，除了最开始搭建配置繁琐一点，后面写完一篇文章一个命令就发布，体验非常棒！</p>\n<h3 id=\"新建主页仓库\"><a href=\"#新建主页仓库\" class=\"headerlink\" title=\"新建主页仓库\"></a>新建主页仓库</h3><p>登录自己的github账户，新建一个仓库，比如我的用户名是HirayClay，那么我就新建一个名为<br>HirayClay.github.io的仓库</p>\n<h3 id=\"hexo环境搭建\"><a href=\"#hexo环境搭建\" class=\"headerlink\" title=\"hexo环境搭建\"></a>hexo环境搭建</h3><p>首先要安装必要的软件，<a href=\"https://nodejs.org\" target=\"_blank\" rel=\"external\">Node.js</a>和<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"external\">Git</a>,安装完成之后安装hexo</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">   $ npm install -g hexo-cli\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>我安装的是 3.3.3版本<br>hexo安装好之后就可以用hexo命令创建一个站点了</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">    $ hexo init <folder_name>\n    $ cd <folder>\n    $ npm install\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>看一下创建的目录结构</p>\n<pre><code>    .\n    ├── _config.yml\n    ├── package.json\n    ├── scaffolds\n    ├── source\n    |   └── _posts\n    └── themes\n</code></pre><p>其中_config.yml是配置文件，一些全局的重要配置都在这里面；package.json文件中声明了版本信息和依赖信息，scaffolds，即脚手架的意思，我们创建post的时候就是用的这个文件下的模板，里面默认有三种模板：draft、page、post，当然你也可以创建自己的模板；source目录下有个子目录_posts，顾名思义就是放我们文章的地方；最后themes就是存放主题的地方，可以下载三方的主题放在里面</p>\n<p>我们需要重点关注一下_config.yml文件里面几个地方</p>\n<pre class=\"line-numbers language-yaml\"><code class=\"language-yaml\">    <span class=\"token key atrule\">title</span><span class=\"token punctuation\">:</span> Blog\n    <span class=\"token key atrule\">subtitle</span><span class=\"token punctuation\">:</span> hirayclay's blog\n    <span class=\"token key atrule\">description</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">author</span><span class=\"token punctuation\">:</span> hirayclay\n    <span class=\"token key atrule\">language</span><span class=\"token punctuation\">:</span> zh\n    <span class=\"token key atrule\">timezone</span><span class=\"token punctuation\">:</span> Asia/Shanghai\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>title：站点的标题，subtitle：站点子标题，description：站点描述 language:站点语言，这里配置的是中文，其他语言的参考这里<a href=\"https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\" target=\"_blank\" rel=\"external\">&gt;&gt;</a>,timezone即时区，这里用的中国北京时区，其他时区参考<a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"_blank\" rel=\"external\">&gt;&gt;</a></p>\n<p>要注意一点的是，这里所有的配置“：”后面都需要有一个空格，不然最后解析生成时候会失败，这是YAML的语法</p>\n<pre class=\"line-numbers language-yaml\"><code class=\"language-yaml\">    <span class=\"token key atrule\">new_post_name</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">:</span>title\n    <span class=\"token key atrule\">default_layout</span><span class=\"token punctuation\">:</span> post\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>new_post_name 即生成的post的名称，有一下几个配置：<br>:title<br>:year<br>:month<br>:i_month<br>:day<br>:i_day<br>我这里直接用title命名生成的post文件</p>\n<p>比如执行一下命令</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">    hexo new post \"MyNewPost\"\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>就会在source/_posts目录下生成 MyNewPost.md文件</p>\n<p>再看下语法高亮配置，比较简单，常用到的是否禁用和代码行数</p>\n<pre class=\"line-numbers language-yaml\"><code class=\"language-yaml\">    <span class=\"token key atrule\">highlight</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">enable</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n    <span class=\"token key atrule\">line_number</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true</span>\n    <span class=\"token key atrule\">auto_detect</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">false</span>\n    <span class=\"token key atrule\">tab_replace</span><span class=\"token punctuation\">:</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>部署配置，第一步新建仓库的作用到了</p>\n<pre class=\"line-numbers language-yaml\"><code class=\"language-yaml\">  <span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">type</span><span class=\"token punctuation\">:</span> git\n  <span class=\"token key atrule\">repo</span><span class=\"token punctuation\">:</span> git@github.com<span class=\"token punctuation\">:</span>HirayClay/HirayClay.github.io.git\n  <span class=\"token key atrule\">branch</span><span class=\"token punctuation\">:</span> master\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>因为我们用的git提交到远程仓库的，所以type = git,以及仓库地址和分支名，这里的repo就是之前新建的仓库地址</p>\n<p>配置说完了，基本可以开写了</p>\n<p>首先 用 hexo new post <your_post_name> 创建一篇博客，然后source/_posts目录找到对应的博客打开编辑即可,可以给博客加tag，比如本博客的tag</your_post_name></p>\n<pre class=\"line-numbers language-yaml\"><code class=\"language-yaml\">   <span class=\"token punctuation\">---</span>\n    <span class=\"token key atrule\">title</span><span class=\"token punctuation\">:</span> Hexo+github搭建个人博客\n    <span class=\"token key atrule\">date</span><span class=\"token punctuation\">:</span> <span class=\"token datetime number\">2017-09-05 14:04:10</span>\n    <span class=\"token key atrule\">tags</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">-</span> hexo\n        <span class=\"token punctuation\">-</span> 博客\n    <span class=\"token punctuation\">---</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>至此基本的都配置完成了，用以下命令生成静态资源</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">    hexo generate\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>也可以写成</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">    hexo g\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>然后可以本地起一个服务进行预览</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">    hexo server\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>浏览器输入<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a> 进行查看</p>\n<p>用以下命令发布到git远程仓库</p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\">    hexo deploy\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>应该会弹出一个窗口让你你输入ssh-key的密码</p>\n<p>最后如果觉得默认主题不合适，可以去下载其他<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"external\">主题</a>到 themes目录下，可以随意命名该目录下的主题文件夹，但是最后在_config.yml文件中配置主题时候一定要用文件夹的名字</p>\n<pre class=\"line-numbers language-yaml\"><code class=\"language-yaml\">    <span class=\"token key atrule\">theme</span><span class=\"token punctuation\">:</span> theme_folder_name\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>The End</p>\n","site":{"data":{}},"excerpt":"","more":"<p>很早之前就有人用hexo和github提供的page服务做个人博客了,不过了解一下就没有怎么关注了，最近有时间，看了一下官方文档，花了两个多小时，搭建了一个简单的个人博客，除了最开始搭建配置繁琐一点，后面写完一篇文章一个命令就发布，体验非常棒！</p>\n<h3 id=\"新建主页仓库\"><a href=\"#新建主页仓库\" class=\"headerlink\" title=\"新建主页仓库\"></a>新建主页仓库</h3><p>登录自己的github账户，新建一个仓库，比如我的用户名是HirayClay，那么我就新建一个名为<br>HirayClay.github.io的仓库</p>\n<h3 id=\"hexo环境搭建\"><a href=\"#hexo环境搭建\" class=\"headerlink\" title=\"hexo环境搭建\"></a>hexo环境搭建</h3><p>首先要安装必要的软件，<a href=\"https://nodejs.org\" target=\"_blank\" rel=\"external\">Node.js</a>和<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"external\">Git</a>,安装完成之后安装hexo</p>\n<pre><code class=\"shell\">   $ npm install -g hexo-cli\n</code></pre>\n<p>我安装的是 3.3.3版本<br>hexo安装好之后就可以用hexo命令创建一个站点了</p>\n<pre><code class=\"shell\">    $ hexo init &lt;folder_name&gt;\n    $ cd &lt;folder&gt;\n    $ npm install\n</code></pre>\n<p>看一下创建的目录结构</p>\n<pre><code>    .\n    ├── _config.yml\n    ├── package.json\n    ├── scaffolds\n    ├── source\n    |   └── _posts\n    └── themes\n</code></pre><p>其中_config.yml是配置文件，一些全局的重要配置都在这里面；package.json文件中声明了版本信息和依赖信息，scaffolds，即脚手架的意思，我们创建post的时候就是用的这个文件下的模板，里面默认有三种模板：draft、page、post，当然你也可以创建自己的模板；source目录下有个子目录_posts，顾名思义就是放我们文章的地方；最后themes就是存放主题的地方，可以下载三方的主题放在里面</p>\n<p>我们需要重点关注一下_config.yml文件里面几个地方</p>\n<pre><code class=\"yaml\">    title: Blog\n    subtitle: hirayclay&#39;s blog\n    description:\n    author: hirayclay\n    language: zh\n    timezone: Asia/Shanghai\n</code></pre>\n<p>title：站点的标题，subtitle：站点子标题，description：站点描述 language:站点语言，这里配置的是中文，其他语言的参考这里<a href=\"https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\" target=\"_blank\" rel=\"external\">&gt;&gt;</a>,timezone即时区，这里用的中国北京时区，其他时区参考<a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"_blank\" rel=\"external\">&gt;&gt;</a></p>\n<p>要注意一点的是，这里所有的配置“：”后面都需要有一个空格，不然最后解析生成时候会失败，这是YAML的语法</p>\n<pre><code class=\"yaml\">    new_post_name: :title\n    default_layout: post\n</code></pre>\n<p>new_post_name 即生成的post的名称，有一下几个配置：<br>:title<br>:year<br>:month<br>:i_month<br>:day<br>:i_day<br>我这里直接用title命名生成的post文件</p>\n<p>比如执行一下命令</p>\n<pre><code class=\"shell\">    hexo new post &quot;MyNewPost&quot;\n</code></pre>\n<p>就会在source/_posts目录下生成 MyNewPost.md文件</p>\n<p>再看下语法高亮配置，比较简单，常用到的是否禁用和代码行数</p>\n<pre><code class=\"yaml\">    highlight:\n    enable: false\n    line_number: true\n    auto_detect: false\n    tab_replace:\n</code></pre>\n<p>部署配置，第一步新建仓库的作用到了</p>\n<pre><code class=\"yaml\">  deploy:\n  type: git\n  repo: git@github.com:HirayClay/HirayClay.github.io.git\n  branch: master\n</code></pre>\n<p>因为我们用的git提交到远程仓库的，所以type = git,以及仓库地址和分支名，这里的repo就是之前新建的仓库地址</p>\n<p>配置说完了，基本可以开写了</p>\n<p>首先 用 hexo new post <your_post_name> 创建一篇博客，然后source/_posts目录找到对应的博客打开编辑即可,可以给博客加tag，比如本博客的tag</your_post_name></p>\n<pre><code class=\"yaml\">   ---\n    title: Hexo+github搭建个人博客\n    date: 2017-09-05 14:04:10\n    tags:\n        - hexo\n        - 博客\n    ---\n</code></pre>\n<p>至此基本的都配置完成了，用以下命令生成静态资源</p>\n<pre><code class=\"shell\">    hexo generate\n</code></pre>\n<p>也可以写成</p>\n<pre><code class=\"shell\">    hexo g\n</code></pre>\n<p>然后可以本地起一个服务进行预览</p>\n<pre><code class=\"shell\">    hexo server\n</code></pre>\n<p>浏览器输入<a href=\"http://localhost:4000\" target=\"_blank\" rel=\"external\">http://localhost:4000</a> 进行查看</p>\n<p>用以下命令发布到git远程仓库</p>\n<pre><code class=\"shell\">    hexo deploy\n</code></pre>\n<p>应该会弹出一个窗口让你你输入ssh-key的密码</p>\n<p>最后如果觉得默认主题不合适，可以去下载其他<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"external\">主题</a>到 themes目录下，可以随意命名该目录下的主题文件夹，但是最后在_config.yml文件中配置主题时候一定要用文件夹的名字</p>\n<pre><code class=\"yaml\">    theme: theme_folder_name\n</code></pre>\n<p>The End</p>\n"},{"title":"MotionLayout","date":"2018-08-20T01:57:59.000Z","_content":"\n\n### 传统动画的问题\n以前的动画————比如View动画和属性动画我们其实无法真正的很好的控制动画，因为动画的时间是给定的，而不是根据用户的操作去表现给定的动画。\n简单来说，传统的动画一旦运行起来我们就无法控制，我们能做的只是何时开始，何时结束，或者何时取消，对于已经运行中的动画我们无法控制。那么有些情况我们就没法做的更好，比如用户在滑动列表时，其他控件如何响应用户的滑动操作并做出对应的动画————当然我们并不是做不到，而是不太优雅，如果能够配置并定义好这些东西，那么再好不过。MotionLayout做的就是这些。\n\n### MotionLayout实现折叠动画\n以前为了实现一个不那么复杂的滑动折叠效果，需要CoordinatorLayout CollapsingToolBar的帮助才能做到。而且布局文件里面的内容显得有些过于冗长。下面使用MotionLayout实现下面这个效果\n\n<img src=\"https://gitee.com/cjjmyj/StackLayoutManager/raw/master/static/hrreverse.gif\" width=\"400px\" height=\"250px\"/>\n\n布局十分简单：\n```xml\n<android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/content\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:fitsSystemWindows=\"false\"\n    android:background=\"@color/contentBackground\">\n\n    <android.support.design.widget.AppBarLayout\n        android:id=\"@+id/app_bar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"@dimen/app_bar_height\"\n        android:theme=\"@style/AppTheme.AppBarOverlay\">\n\n        <include layout=\"@layout/motion_09_coordinatorlayout_header\"/>\n\n    </android.support.design.widget.AppBarLayout>\n\n    <include layout=\"@layout/content_scrolling\" />\n\n</android.support.design.widget.CoordinatorLayout>\n````\n\nmotion_09_coordinatorlayout_header:\n```xml\n<com.google.androidstudio.motionlayoutexample.utils.CollapsibleToolbar xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:id=\"@+id/motionLayout\"\n    app:layoutDescription=\"@xml/scene_09\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:minHeight=\"50dp\"\n    android:fitsSystemWindows=\"false\"\n    app:layout_scrollFlags=\"scroll|enterAlways|snap|exitUntilCollapsed\">\n\n    <ImageView\n        android:id=\"@+id/background\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"200dp\"\n        android:background=\"@color/colorAccent\"\n        android:scaleType=\"centerCrop\"\n        android:src=\"@drawable/monterey\"/>\n\n    <TextView\n        android:id=\"@+id/label\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:transformPivotX=\"0dp\"\n        android:transformPivotY=\"0dp\"\n        android:text=\"Monterey\"\n        android:textColor=\"#FFF\"\n        android:textSize=\"32dp\" />\n\n</com.google.androidstudio.motionlayoutexample.utils.CollapsibleToolbar>\n```\n\n\n没有任何的嵌套，只是简单利用了ConstraintLayout的特性把控件放到合适的位置。可能会奇怪，并没有看到任何与动画有关的东西，难道是用Java代码在控制吗？并不是，动画的入口实则在layoutDescription属性上，这个属性的值指向一个xml文件：\n\n```xml\n    <MotionScene\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:motion=\"http://schemas.android.com/apk/res-auto\">\n\n    <Transition\n        motion:constraintSetStart=\"@+id/start\"\n        motion:constraintSetEnd=\"@+id/end\"\n        motion:duration=\"1000\"\n        motion:interpolator=\"linear\">\n        <OnSwipe\n            motion:touchAnchorId=\"@+id/background\"\n            motion:touchAnchorSide=\"bottom\"\n            motion:dragDirection=\"dragUp\" />\n\n        <ConstraintSet android:id=\"@+id/end\">\n            <Constraint\n                android:id=\"@id/background\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:alpha=\"0.2\"\n                motion:layout_constraintBottom_toBottomOf=\"parent\"/>\n            <Constraint\n                android:id=\"@id/label\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:layout_marginStart=\"8dp\"\n                android:layout_marginBottom=\"8dp\"\n                android:rotation=\"0.0\"\n                motion:layout_constraintBottom_toBottomOf=\"@+id/background\"\n                motion:layout_constraintStart_toStartOf=\"parent\" />\n        </ConstraintSet>\n\n        <ConstraintSet android:id=\"@+id/start\">\n            <Constraint\n                android:id=\"@+id/background\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:alpha=\"1.0\"\n                motion:layout_constraintBottom_toBottomOf=\"parent\"/>\n            <Constraint\n                android:id=\"@+id/label\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:rotation=\"-90.0\"\n                motion:layout_constraintBottom_toBottomOf=\"@+id/background\"\n                motion:layout_constraintStart_toStartOf=\"parent\"/>\n        </ConstraintSet>\n    </Transition>\n\n</MotionScene>\n```\n代码其实不多，最外边是MotiongScene，包含了所有动画需要的元素。Transition是","source":"_posts/MotionLayout.md","raw":"---\ntitle: MotionLayout\ndate: 2018-08-20 09:57:59\ntags:\n    - MotionLayout\n    - 动画\n---\n\n\n### 传统动画的问题\n以前的动画————比如View动画和属性动画我们其实无法真正的很好的控制动画，因为动画的时间是给定的，而不是根据用户的操作去表现给定的动画。\n简单来说，传统的动画一旦运行起来我们就无法控制，我们能做的只是何时开始，何时结束，或者何时取消，对于已经运行中的动画我们无法控制。那么有些情况我们就没法做的更好，比如用户在滑动列表时，其他控件如何响应用户的滑动操作并做出对应的动画————当然我们并不是做不到，而是不太优雅，如果能够配置并定义好这些东西，那么再好不过。MotionLayout做的就是这些。\n\n### MotionLayout实现折叠动画\n以前为了实现一个不那么复杂的滑动折叠效果，需要CoordinatorLayout CollapsingToolBar的帮助才能做到。而且布局文件里面的内容显得有些过于冗长。下面使用MotionLayout实现下面这个效果\n\n<img src=\"https://gitee.com/cjjmyj/StackLayoutManager/raw/master/static/hrreverse.gif\" width=\"400px\" height=\"250px\"/>\n\n布局十分简单：\n```xml\n<android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/content\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:fitsSystemWindows=\"false\"\n    android:background=\"@color/contentBackground\">\n\n    <android.support.design.widget.AppBarLayout\n        android:id=\"@+id/app_bar\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"@dimen/app_bar_height\"\n        android:theme=\"@style/AppTheme.AppBarOverlay\">\n\n        <include layout=\"@layout/motion_09_coordinatorlayout_header\"/>\n\n    </android.support.design.widget.AppBarLayout>\n\n    <include layout=\"@layout/content_scrolling\" />\n\n</android.support.design.widget.CoordinatorLayout>\n````\n\nmotion_09_coordinatorlayout_header:\n```xml\n<com.google.androidstudio.motionlayoutexample.utils.CollapsibleToolbar xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:id=\"@+id/motionLayout\"\n    app:layoutDescription=\"@xml/scene_09\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:minHeight=\"50dp\"\n    android:fitsSystemWindows=\"false\"\n    app:layout_scrollFlags=\"scroll|enterAlways|snap|exitUntilCollapsed\">\n\n    <ImageView\n        android:id=\"@+id/background\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"200dp\"\n        android:background=\"@color/colorAccent\"\n        android:scaleType=\"centerCrop\"\n        android:src=\"@drawable/monterey\"/>\n\n    <TextView\n        android:id=\"@+id/label\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:transformPivotX=\"0dp\"\n        android:transformPivotY=\"0dp\"\n        android:text=\"Monterey\"\n        android:textColor=\"#FFF\"\n        android:textSize=\"32dp\" />\n\n</com.google.androidstudio.motionlayoutexample.utils.CollapsibleToolbar>\n```\n\n\n没有任何的嵌套，只是简单利用了ConstraintLayout的特性把控件放到合适的位置。可能会奇怪，并没有看到任何与动画有关的东西，难道是用Java代码在控制吗？并不是，动画的入口实则在layoutDescription属性上，这个属性的值指向一个xml文件：\n\n```xml\n    <MotionScene\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:motion=\"http://schemas.android.com/apk/res-auto\">\n\n    <Transition\n        motion:constraintSetStart=\"@+id/start\"\n        motion:constraintSetEnd=\"@+id/end\"\n        motion:duration=\"1000\"\n        motion:interpolator=\"linear\">\n        <OnSwipe\n            motion:touchAnchorId=\"@+id/background\"\n            motion:touchAnchorSide=\"bottom\"\n            motion:dragDirection=\"dragUp\" />\n\n        <ConstraintSet android:id=\"@+id/end\">\n            <Constraint\n                android:id=\"@id/background\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:alpha=\"0.2\"\n                motion:layout_constraintBottom_toBottomOf=\"parent\"/>\n            <Constraint\n                android:id=\"@id/label\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:layout_marginStart=\"8dp\"\n                android:layout_marginBottom=\"8dp\"\n                android:rotation=\"0.0\"\n                motion:layout_constraintBottom_toBottomOf=\"@+id/background\"\n                motion:layout_constraintStart_toStartOf=\"parent\" />\n        </ConstraintSet>\n\n        <ConstraintSet android:id=\"@+id/start\">\n            <Constraint\n                android:id=\"@+id/background\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"match_parent\"\n                android:alpha=\"1.0\"\n                motion:layout_constraintBottom_toBottomOf=\"parent\"/>\n            <Constraint\n                android:id=\"@+id/label\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:rotation=\"-90.0\"\n                motion:layout_constraintBottom_toBottomOf=\"@+id/background\"\n                motion:layout_constraintStart_toStartOf=\"parent\"/>\n        </ConstraintSet>\n    </Transition>\n\n</MotionScene>\n```\n代码其实不多，最外边是MotiongScene，包含了所有动画需要的元素。Transition是","slug":"MotionLayout","published":1,"updated":"2018-08-20T03:38:47.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl1qvap50004y472t5dcamjq","content":"<h3 id=\"传统动画的问题\"><a href=\"#传统动画的问题\" class=\"headerlink\" title=\"传统动画的问题\"></a>传统动画的问题</h3><p>以前的动画————比如View动画和属性动画我们其实无法真正的很好的控制动画，因为动画的时间是给定的，而不是根据用户的操作去表现给定的动画。<br>简单来说，传统的动画一旦运行起来我们就无法控制，我们能做的只是何时开始，何时结束，或者何时取消，对于已经运行中的动画我们无法控制。那么有些情况我们就没法做的更好，比如用户在滑动列表时，其他控件如何响应用户的滑动操作并做出对应的动画————当然我们并不是做不到，而是不太优雅，如果能够配置并定义好这些东西，那么再好不过。MotionLayout做的就是这些。</p>\n<h3 id=\"MotionLayout实现折叠动画\"><a href=\"#MotionLayout实现折叠动画\" class=\"headerlink\" title=\"MotionLayout实现折叠动画\"></a>MotionLayout实现折叠动画</h3><p>以前为了实现一个不那么复杂的滑动折叠效果，需要CoordinatorLayout CollapsingToolBar的帮助才能做到。而且布局文件里面的内容显得有些过于冗长。下面使用MotionLayout实现下面这个效果</p>\n<p><img src=\"https://gitee.com/cjjmyj/StackLayoutManager/raw/master/static/hrreverse.gif\" width=\"400px\" height=\"250px\"></p>\n<p>布局十分简单：</p>\n<pre class=\"line-numbers language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>android.support.design.widget.CoordinatorLayout</span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>android</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://schemas.android.com/apk/res/android<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@+id/content<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>fitsSystemWindows</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>false<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>background</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@color/contentBackground<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>android.support.design.widget.AppBarLayout</span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@+id/app_bar<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@dimen/app_bar_height<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>theme</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@style/AppTheme.AppBarOverlay<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>include</span> <span class=\"token attr-name\">layout</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@layout/motion_09_coordinatorlayout_header<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>android.support.design.widget.AppBarLayout</span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>include</span> <span class=\"token attr-name\">layout</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@layout/content_scrolling<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>android.support.design.widget.CoordinatorLayout</span><span class=\"token punctuation\">></span></span>\n`\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>motion_09_coordinatorlayout_header:</p>\n<pre class=\"line-numbers language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>com.google.androidstudio.motionlayoutexample.utils.CollapsibleToolbar</span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>android</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://schemas.android.com/apk/res/android<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>app</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://schemas.android.com/apk/res-auto<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@+id/motionLayout<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token attr-name\"><span class=\"token namespace\">app:</span>layoutDescription</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@xml/scene_09<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>minHeight</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>50dp<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>fitsSystemWindows</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>false<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token attr-name\"><span class=\"token namespace\">app:</span>layout_scrollFlags</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>scroll|enterAlways|snap|exitUntilCollapsed<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ImageView</span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@+id/background<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>200dp<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>background</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@color/colorAccent<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>scaleType</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>centerCrop<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>src</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@drawable/monterey<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>TextView</span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@+id/label<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>transformPivotX</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>0dp<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>transformPivotY</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>0dp<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>text</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>Monterey<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>textColor</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>#FFF<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>textSize</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>32dp<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>com.google.androidstudio.motionlayoutexample.utils.CollapsibleToolbar</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>没有任何的嵌套，只是简单利用了ConstraintLayout的特性把控件放到合适的位置。可能会奇怪，并没有看到任何与动画有关的东西，难道是用Java代码在控制吗？并不是，动画的入口实则在layoutDescription属性上，这个属性的值指向一个xml文件：</p>\n<pre class=\"line-numbers language-xml\"><code class=\"language-xml\">    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>MotionScene</span>\n    <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>android</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://schemas.android.com/apk/res/android<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>motion</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://schemas.android.com/apk/res-auto<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Transition</span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">motion:</span>constraintSetStart</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@+id/start<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">motion:</span>constraintSetEnd</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@+id/end<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">motion:</span>duration</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1000<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">motion:</span>interpolator</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>linear<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>OnSwipe</span>\n            <span class=\"token attr-name\"><span class=\"token namespace\">motion:</span>touchAnchorId</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@+id/background<span class=\"token punctuation\">\"</span></span>\n            <span class=\"token attr-name\"><span class=\"token namespace\">motion:</span>touchAnchorSide</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>bottom<span class=\"token punctuation\">\"</span></span>\n            <span class=\"token attr-name\"><span class=\"token namespace\">motion:</span>dragDirection</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>dragUp<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ConstraintSet</span> <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@+id/end<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Constraint</span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@id/background<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>alpha</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>0.2<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">motion:</span>layout_constraintBottom_toBottomOf</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>parent<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Constraint</span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@id/label<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_marginStart</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>8dp<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_marginBottom</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>8dp<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>rotation</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>0.0<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">motion:</span>layout_constraintBottom_toBottomOf</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@+id/background<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">motion:</span>layout_constraintStart_toStartOf</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>parent<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ConstraintSet</span><span class=\"token punctuation\">></span></span>\n\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ConstraintSet</span> <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@+id/start<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Constraint</span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@+id/background<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>match_parent<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>alpha</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>1.0<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">motion:</span>layout_constraintBottom_toBottomOf</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>parent<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Constraint</span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@+id/label<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>rotation</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>-90.0<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">motion:</span>layout_constraintBottom_toBottomOf</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@+id/background<span class=\"token punctuation\">\"</span></span>\n                <span class=\"token attr-name\"><span class=\"token namespace\">motion:</span>layout_constraintStart_toStartOf</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>parent<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ConstraintSet</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Transition</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>MotionScene</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>代码其实不多，最外边是MotiongScene，包含了所有动画需要的元素。Transition是</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"传统动画的问题\"><a href=\"#传统动画的问题\" class=\"headerlink\" title=\"传统动画的问题\"></a>传统动画的问题</h3><p>以前的动画————比如View动画和属性动画我们其实无法真正的很好的控制动画，因为动画的时间是给定的，而不是根据用户的操作去表现给定的动画。<br>简单来说，传统的动画一旦运行起来我们就无法控制，我们能做的只是何时开始，何时结束，或者何时取消，对于已经运行中的动画我们无法控制。那么有些情况我们就没法做的更好，比如用户在滑动列表时，其他控件如何响应用户的滑动操作并做出对应的动画————当然我们并不是做不到，而是不太优雅，如果能够配置并定义好这些东西，那么再好不过。MotionLayout做的就是这些。</p>\n<h3 id=\"MotionLayout实现折叠动画\"><a href=\"#MotionLayout实现折叠动画\" class=\"headerlink\" title=\"MotionLayout实现折叠动画\"></a>MotionLayout实现折叠动画</h3><p>以前为了实现一个不那么复杂的滑动折叠效果，需要CoordinatorLayout CollapsingToolBar的帮助才能做到。而且布局文件里面的内容显得有些过于冗长。下面使用MotionLayout实现下面这个效果</p>\n<p><img src=\"https://gitee.com/cjjmyj/StackLayoutManager/raw/master/static/hrreverse.gif\" width=\"400px\" height=\"250px\"></p>\n<p>布局十分简单：</p>\n<pre><code class=\"xml\">&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    android:id=&quot;@+id/content&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:fitsSystemWindows=&quot;false&quot;\n    android:background=&quot;@color/contentBackground&quot;&gt;\n\n    &lt;android.support.design.widget.AppBarLayout\n        android:id=&quot;@+id/app_bar&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;@dimen/app_bar_height&quot;\n        android:theme=&quot;@style/AppTheme.AppBarOverlay&quot;&gt;\n\n        &lt;include layout=&quot;@layout/motion_09_coordinatorlayout_header&quot;/&gt;\n\n    &lt;/android.support.design.widget.AppBarLayout&gt;\n\n    &lt;include layout=&quot;@layout/content_scrolling&quot; /&gt;\n\n&lt;/android.support.design.widget.CoordinatorLayout&gt;\n`\n</code></pre>\n<p>motion_09_coordinatorlayout_header:</p>\n<pre><code class=\"xml\">&lt;com.google.androidstudio.motionlayoutexample.utils.CollapsibleToolbar xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    android:id=&quot;@+id/motionLayout&quot;\n    app:layoutDescription=&quot;@xml/scene_09&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    android:minHeight=&quot;50dp&quot;\n    android:fitsSystemWindows=&quot;false&quot;\n    app:layout_scrollFlags=&quot;scroll|enterAlways|snap|exitUntilCollapsed&quot;&gt;\n\n    &lt;ImageView\n        android:id=&quot;@+id/background&quot;\n        android:layout_width=&quot;match_parent&quot;\n        android:layout_height=&quot;200dp&quot;\n        android:background=&quot;@color/colorAccent&quot;\n        android:scaleType=&quot;centerCrop&quot;\n        android:src=&quot;@drawable/monterey&quot;/&gt;\n\n    &lt;TextView\n        android:id=&quot;@+id/label&quot;\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:transformPivotX=&quot;0dp&quot;\n        android:transformPivotY=&quot;0dp&quot;\n        android:text=&quot;Monterey&quot;\n        android:textColor=&quot;#FFF&quot;\n        android:textSize=&quot;32dp&quot; /&gt;\n\n&lt;/com.google.androidstudio.motionlayoutexample.utils.CollapsibleToolbar&gt;\n</code></pre>\n<p>没有任何的嵌套，只是简单利用了ConstraintLayout的特性把控件放到合适的位置。可能会奇怪，并没有看到任何与动画有关的东西，难道是用Java代码在控制吗？并不是，动画的入口实则在layoutDescription属性上，这个属性的值指向一个xml文件：</p>\n<pre><code class=\"xml\">    &lt;MotionScene\n    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:motion=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;\n\n    &lt;Transition\n        motion:constraintSetStart=&quot;@+id/start&quot;\n        motion:constraintSetEnd=&quot;@+id/end&quot;\n        motion:duration=&quot;1000&quot;\n        motion:interpolator=&quot;linear&quot;&gt;\n        &lt;OnSwipe\n            motion:touchAnchorId=&quot;@+id/background&quot;\n            motion:touchAnchorSide=&quot;bottom&quot;\n            motion:dragDirection=&quot;dragUp&quot; /&gt;\n\n        &lt;ConstraintSet android:id=&quot;@+id/end&quot;&gt;\n            &lt;Constraint\n                android:id=&quot;@id/background&quot;\n                android:layout_width=&quot;match_parent&quot;\n                android:layout_height=&quot;match_parent&quot;\n                android:alpha=&quot;0.2&quot;\n                motion:layout_constraintBottom_toBottomOf=&quot;parent&quot;/&gt;\n            &lt;Constraint\n                android:id=&quot;@id/label&quot;\n                android:layout_width=&quot;wrap_content&quot;\n                android:layout_height=&quot;wrap_content&quot;\n                android:layout_marginStart=&quot;8dp&quot;\n                android:layout_marginBottom=&quot;8dp&quot;\n                android:rotation=&quot;0.0&quot;\n                motion:layout_constraintBottom_toBottomOf=&quot;@+id/background&quot;\n                motion:layout_constraintStart_toStartOf=&quot;parent&quot; /&gt;\n        &lt;/ConstraintSet&gt;\n\n        &lt;ConstraintSet android:id=&quot;@+id/start&quot;&gt;\n            &lt;Constraint\n                android:id=&quot;@+id/background&quot;\n                android:layout_width=&quot;match_parent&quot;\n                android:layout_height=&quot;match_parent&quot;\n                android:alpha=&quot;1.0&quot;\n                motion:layout_constraintBottom_toBottomOf=&quot;parent&quot;/&gt;\n            &lt;Constraint\n                android:id=&quot;@+id/label&quot;\n                android:layout_width=&quot;wrap_content&quot;\n                android:layout_height=&quot;wrap_content&quot;\n                android:rotation=&quot;-90.0&quot;\n                motion:layout_constraintBottom_toBottomOf=&quot;@+id/background&quot;\n                motion:layout_constraintStart_toStartOf=&quot;parent&quot;/&gt;\n        &lt;/ConstraintSet&gt;\n    &lt;/Transition&gt;\n\n&lt;/MotionScene&gt;\n</code></pre>\n<p>代码其实不多，最外边是MotiongScene，包含了所有动画需要的元素。Transition是</p>\n"},{"title":"Parcelable","date":"2018-01-05T02:11:07.000Z","_content":"这里并不是要仔细说一遍Parcelable，而是看了一些Parcelable的国内博客，发现都是说怎么用。怎么用官方文档就有例子，而是有个点，没有一篇博客说出来（也有可能我看的不仔细？）。\n这个疑惑估计你也有过，在使用Parcelable 序列化和序列化的时候都是write** read**方法调用，但是发现如果有两个相同类型的值，比如有两个int要序列化，我们是不是要调用writeInt两次，然后反序列化的时候调用两次readInt，那么问题来了，反序列化的时候调用readInt怎么就知道是拿到的正确的值，而不会拿反了，毕竟两个int呢。\n就这个不大不小的点，一直没看到，当然我也想过，write** readInt**操作的值的顺序必须一致，不然就会错\n写了一小段代码跑了下，确实必须按照顺序来，因为底层就是个指针在挪动，挨个读取，比如取一个int的值，就会挪动4字节，所以顺序错了有时会拿到错的值，甚至拿不到正确的值（读到null直接crash）\n\n```java\n    var name: String = \"\"\n    var nickName: String = \"\"\n    var id: Int = 0\n\n    constructor(parcel: Parcel) {\n        id = parcel.readInt()\n        nickName = parcel.readString()\n        name = parcel.readString()\n    }\n\n    override fun writeToParcel(parcel: Parcel, flags: Int) {\n        parcel.writeString(name)\n        parcel.writeString(nickName)\n        parcel.writeInt(id)\n    }\n```\n然后直接崩了\n![](https://raw.githubusercontent.com/HirayClay/draft/master/ParcelableCrash.png)\n\n这里有篇歪果仁写的[博客](https://www.sitepoint.com/transfer-data-between-activities-with-android-parcelable/)，很详细\n\nThe End","source":"_posts/Parcelable.md","raw":"---\ntitle: Parcelable\ndate: 2018-01-05 10:11:07\ntags:\n    - Android \n    - Parcelable\n---\n这里并不是要仔细说一遍Parcelable，而是看了一些Parcelable的国内博客，发现都是说怎么用。怎么用官方文档就有例子，而是有个点，没有一篇博客说出来（也有可能我看的不仔细？）。\n这个疑惑估计你也有过，在使用Parcelable 序列化和序列化的时候都是write** read**方法调用，但是发现如果有两个相同类型的值，比如有两个int要序列化，我们是不是要调用writeInt两次，然后反序列化的时候调用两次readInt，那么问题来了，反序列化的时候调用readInt怎么就知道是拿到的正确的值，而不会拿反了，毕竟两个int呢。\n就这个不大不小的点，一直没看到，当然我也想过，write** readInt**操作的值的顺序必须一致，不然就会错\n写了一小段代码跑了下，确实必须按照顺序来，因为底层就是个指针在挪动，挨个读取，比如取一个int的值，就会挪动4字节，所以顺序错了有时会拿到错的值，甚至拿不到正确的值（读到null直接crash）\n\n```java\n    var name: String = \"\"\n    var nickName: String = \"\"\n    var id: Int = 0\n\n    constructor(parcel: Parcel) {\n        id = parcel.readInt()\n        nickName = parcel.readString()\n        name = parcel.readString()\n    }\n\n    override fun writeToParcel(parcel: Parcel, flags: Int) {\n        parcel.writeString(name)\n        parcel.writeString(nickName)\n        parcel.writeInt(id)\n    }\n```\n然后直接崩了\n![](https://raw.githubusercontent.com/HirayClay/draft/master/ParcelableCrash.png)\n\n这里有篇歪果仁写的[博客](https://www.sitepoint.com/transfer-data-between-activities-with-android-parcelable/)，很详细\n\nThe End","slug":"Parcelable","published":1,"updated":"2018-01-17T08:38:01.665Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl1qvap70005y472yxib7sa5","content":"<p>这里并不是要仔细说一遍Parcelable，而是看了一些Parcelable的国内博客，发现都是说怎么用。怎么用官方文档就有例子，而是有个点，没有一篇博客说出来（也有可能我看的不仔细？）。<br>这个疑惑估计你也有过，在使用Parcelable 序列化和序列化的时候都是write<strong> read</strong>方法调用，但是发现如果有两个相同类型的值，比如有两个int要序列化，我们是不是要调用writeInt两次，然后反序列化的时候调用两次readInt，那么问题来了，反序列化的时候调用readInt怎么就知道是拿到的正确的值，而不会拿反了，毕竟两个int呢。<br>就这个不大不小的点，一直没看到，当然我也想过，write<strong> readInt</strong>操作的值的顺序必须一致，不然就会错<br>写了一小段代码跑了下，确实必须按照顺序来，因为底层就是个指针在挪动，挨个读取，比如取一个int的值，就会挪动4字节，所以顺序错了有时会拿到错的值，甚至拿不到正确的值（读到null直接crash）</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">    var name<span class=\"token operator\">:</span> String <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span>\n    var nickName<span class=\"token operator\">:</span> String <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span>\n    var id<span class=\"token operator\">:</span> Int <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n    <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>parcel<span class=\"token operator\">:</span> Parcel<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        id <span class=\"token operator\">=</span> parcel<span class=\"token punctuation\">.</span><span class=\"token function\">readInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        nickName <span class=\"token operator\">=</span> parcel<span class=\"token punctuation\">.</span><span class=\"token function\">readString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        name <span class=\"token operator\">=</span> parcel<span class=\"token punctuation\">.</span><span class=\"token function\">readString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    override fun <span class=\"token function\">writeToParcel</span><span class=\"token punctuation\">(</span>parcel<span class=\"token operator\">:</span> Parcel<span class=\"token punctuation\">,</span> flags<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        parcel<span class=\"token punctuation\">.</span><span class=\"token function\">writeString</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span>\n        parcel<span class=\"token punctuation\">.</span><span class=\"token function\">writeString</span><span class=\"token punctuation\">(</span>nickName<span class=\"token punctuation\">)</span>\n        parcel<span class=\"token punctuation\">.</span><span class=\"token function\">writeInt</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>然后直接崩了<br><img src=\"https://raw.githubusercontent.com/HirayClay/draft/master/ParcelableCrash.png\" alt=\"\"></p>\n<p>这里有篇歪果仁写的<a href=\"https://www.sitepoint.com/transfer-data-between-activities-with-android-parcelable/\" target=\"_blank\" rel=\"external\">博客</a>，很详细</p>\n<p>The End</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这里并不是要仔细说一遍Parcelable，而是看了一些Parcelable的国内博客，发现都是说怎么用。怎么用官方文档就有例子，而是有个点，没有一篇博客说出来（也有可能我看的不仔细？）。<br>这个疑惑估计你也有过，在使用Parcelable 序列化和序列化的时候都是write<strong> read</strong>方法调用，但是发现如果有两个相同类型的值，比如有两个int要序列化，我们是不是要调用writeInt两次，然后反序列化的时候调用两次readInt，那么问题来了，反序列化的时候调用readInt怎么就知道是拿到的正确的值，而不会拿反了，毕竟两个int呢。<br>就这个不大不小的点，一直没看到，当然我也想过，write<strong> readInt</strong>操作的值的顺序必须一致，不然就会错<br>写了一小段代码跑了下，确实必须按照顺序来，因为底层就是个指针在挪动，挨个读取，比如取一个int的值，就会挪动4字节，所以顺序错了有时会拿到错的值，甚至拿不到正确的值（读到null直接crash）</p>\n<pre><code class=\"java\">    var name: String = &quot;&quot;\n    var nickName: String = &quot;&quot;\n    var id: Int = 0\n\n    constructor(parcel: Parcel) {\n        id = parcel.readInt()\n        nickName = parcel.readString()\n        name = parcel.readString()\n    }\n\n    override fun writeToParcel(parcel: Parcel, flags: Int) {\n        parcel.writeString(name)\n        parcel.writeString(nickName)\n        parcel.writeInt(id)\n    }\n</code></pre>\n<p>然后直接崩了<br><img src=\"https://raw.githubusercontent.com/HirayClay/draft/master/ParcelableCrash.png\" alt=\"\"></p>\n<p>这里有篇歪果仁写的<a href=\"https://www.sitepoint.com/transfer-data-between-activities-with-android-parcelable/\" target=\"_blank\" rel=\"external\">博客</a>，很详细</p>\n<p>The End</p>\n"},{"title":"LinearLayoutManager源码阅读(滚动分析)","date":"2017-12-19T07:45:56.000Z","_content":"\n\n实现自定义的通用的LayoutManager，但是卡住了，遂看下Android 官方的几种LayoutManager是如何优雅实现的，大致的以及一些细节都看懂了，但是还是没找到什么好办法解决自己的问题，不如趁着热度把自己的分析过程写下来，也给其他需要的Androider.其实真的要对RecyclerView有个全面的认识，其实LayoutManager、Adapter、动画以及测量流程等细节都是要清楚的，因为虽然说RV给人使用上非常灵活解耦，但是其实内部也是这几者的紧密配合才达到的效果，所以有一点不明白其他地方可能也就会很模糊看不下去。也不细分章节了，就按照滚动的流程来写。至于为什么从滚动开始分析，是因为看源码还是讲究切入点，从RecyclerView的滑动开始是最佳切入点，很直观，要是第一次直接就从onLayoutChildren看起，我觉得看不了几行就得放弃。当然这篇文章的内容很多没说清楚的其实都是onLayoutChildren的一些逻辑，所以都略过了，只关注滑动。\n\n由于自定的LayoutManager如果要(肯定要，不然还定义啥)支持滚动都必须至少重写以下两个方法中的一个，并且返回true，分别表示支持垂直滚动和水平滚动\n```java\n public boolean canScrollHorizontally() {\n            return true;\n        }\n public boolean canScrollVertically() {\n            return true;\n        }\n```\n在发生滚动的时候，会在以下两个方法回调滚动的距离dy/dx\n```java\n    public int scrollVerticallyBy(int dy, Recycler recycler, State state) {\n            return 0;\n        }\n\n    public int scrollHorizontallyBy(int dx, Recycler recycler, State state) {\n            return 0;\n        }\n```\n这里我们从LinearLayoutManager的垂直滚动分析起，进入scrollBy方法,\n```java\n    int scrollBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) {\n        if (getChildCount() == 0 || dy == 0) {\n            return 0;\n        }\n        //滚动发生时，是需要回收View的\n        mLayoutState.mRecycle = true;\n        ensureLayoutState();\n        //手指向上滑动时dy>0\n        final int layoutDirection = dy > 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;\n        final int absDy = Math.abs(dy);\n        //更新LayoutState\n        updateLayoutState(layoutDirection, absDy, true, state);\n        final int consumed = mLayoutState.mScrollingOffset\n                + fill(recycler, mLayoutState, state, false);\n        if (consumed < 0) {\n            if (DEBUG) {\n                Log.d(TAG, \"Don't have any more elements to scroll\");\n            }\n            return 0;\n        }\n        final int scrolled = absDy > consumed ? layoutDirection * consumed : dy;\n        //layout view结束，所有View整体平移；这里需要注意的是LLM并非是从头到尾一个个layout view，而是先根据偏移把需要回收的view回收掉，会显示的view显示出来，最后进行整体的平移。想一想这样效率确实要高\n        mOrientationHelper.offsetChildren(-scrolled);\n        if (DEBUG) {\n            Log.d(TAG, \"scroll req: \" + dy + \" scrolled: \" + scrolled);\n        }\n        mLayoutState.mLastScrollDelta = scrolled;\n        return scrolled;\n    }\n```\n写了部分注释，具体分析一下updateLayoutState方法\n分析这个方法前，先看下LayoutState这个类，了解一下我们需要关注的几个重要参数的含义\n\nmRecycle 表示是否需要回收View,滑动情况下这个值是true，但是在有item 添加删除的情况是false，因为锚点什么的得靠view来确定，不能回收\n\nmOffset   layout View时候的起始坐标(垂直方向的LinearLayoutManager 表示y值)，e.g.比如发生滑动后，下一个item需要显示出来，那么mOffset的值就等于最后一个可见item的bottom值(不考虑margin，向上滑动)\n\nmAvailable 表示可用距离，在layout View的时候用到\n\nmCurrentPosition  表示获取View的起始索引，在layout View的时候循环取View的时候用到\n\nmItemDirection  获取item 数据的方向，是从前到后（值为1），还是从后往前（值为-1），本篇分析的是正序情况\n\nmExtra 在LayoutManager支持predictive动画的时候这个值很有用，具体的需要了解RV的动画机制才明白这个值怎么回事，简单的说就是即使一个item此时(当他即将进入RV可见范围时)对用户不可见，但是还是得把他layout出来，虽然已经超出了RV的边界用户看不到，这样做的目的是为了更好的动画体验（因为需要两次layout，一次pre-layout 一次post-layout来确定动画的起始和终止位置，不然就只能做最简单的fadeIn fadeOut。只有当item add remove发生时才有值，一般为0\n\n再回过来看updateLayoutState方法(并不喜欢贴太长串的代码。。。)\n```java\n     private void updateLayoutState(int layoutDirection, int requiredSpace,\n            boolean canUseExistingSpace, RecyclerView.State state) {\n        // If parent provides a hint, don't measure unlimited.\n        mLayoutState.mInfinite = resolveIsInfinite();\n        mLayoutState.mExtra = getExtraLayoutSpace(state);\n        mLayoutState.mLayoutDirection = layoutDirection;\n        int scrollingOffset;\n        if (layoutDirection == LayoutState.LAYOUT_END) {\n            mLayoutState.mExtra += mOrientationHelper.getEndPadding();\n            // get the first child in the direction we are going\n            final View child = getChildClosestToEnd();\n            // the direction in which we are traversing children\n            mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD\n                    : LayoutState.ITEM_DIRECTION_TAIL;\n            mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;\n            mLayoutState.mOffset = mOrientationHelper.getDecoratedEnd(child);\n            // calculate how much we can scroll without adding new children (independent of layout)\n            scrollingOffset = mOrientationHelper.getDecoratedEnd(child)\n                    - mOrientationHelper.getEndAfterPadding();\n\n        } else {\n            final View child = getChildClosestToStart();\n            mLayoutState.mExtra += mOrientationHelper.getStartAfterPadding();\n            mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL\n                    : LayoutState.ITEM_DIRECTION_HEAD;\n            mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;\n            mLayoutState.mOffset = mOrientationHelper.getDecoratedStart(child);\n            scrollingOffset = -mOrientationHelper.getDecoratedStart(child)\n                    + mOrientationHelper.getStartAfterPadding();\n        }\n        mLayoutState.mAvailable = requiredSpace;\n        if (canUseExistingSpace) {\n            mLayoutState.mAvailable -= scrollingOffset;\n        }\n        mLayoutState.mScrollingOffset = scrollingOffset;\n    }\n```\n前面几行就是简单的赋值更新状态，然后是根据layoutDirection的方向进行其他参数的计算，我们这里是分析的手指上滑，对应的layoutDireciton是LAYOUT_END，我们进入layoutDirection == LayoutState.LAYOUT_END成立的情况下去看：\n\n 1.通过getChildClosestToEnd方法拿到RV最接近End的child(如果是水平布局，那么end就是RV的right，垂直布局end就是RV的bottom)\n\n 2.根据mShouldReverseLayout变量给mItemDirection赋值，我们一般都不使用逆序布局，所以mItemDirection的值是ITEM_DIRECTION_HEAD，也就是说待会在fill方法内部取child来放的时候是正序，也就是从前往后依次取，反之亦然\n\n 3.根据刚才取到的child获取到其在adapter中的位置，加上mItemDirection后赋值给mCurrentPosition，这个好理解，mCurrentPosition表示的就是取child的开始索引，LayoutState里面有个next方法就是这么做的，可以看下代码\n\n ```java\n        View next(RecyclerView.Recycler recycler) {\n            if (mScrapList != null) {\n                return nextViewFromScrapList();\n            }\n            final View view = recycler.getViewForPosition(mCurrentPosition);\n            mCurrentPosition += mItemDirection;\n            return view;\n        }\n ```\n 4.给mOffset赋值，也就是下图最后一个item的bottom值，是后续依次放child的起始坐标\n ![](https://github.com/HirayClay/draft/blob/master/RV_LLM.png?raw=true)\n\n 5.至于scrollingOffset就是上面这张图里面最后一个item底部距离RV底部的距离，官方也有注释----\"不需要添加新的children的情况下滚动的最大距离\"-----也就是说最后一个item刚好完全滚进来，但是又不会有新的item滚进来的意思\n\n 6最后给mAvailable赋值为requiredSpace，也就是此次滚动的距离,然后判断canUseExistingSpace为true就减去刚才的scrollingOffset；这里为什么要减去这个scrollingOffset呢\n  ，其实就是把这个零头减掉方便计算而已，最后一句mScrollingOffset又把scrollingOffse\n  t保存起来了。最后所有child都放置好之后，返回消耗的滑动距离时候，在scrollBy方法那里\n  最后又把这个值加上去了，就这句：\n\n  ```java\n     final int consumed = mLayoutState.mScrollingOffset\n                + fill(recycler, mLayoutState, state, false);\n  ```\n\n  好了，这个方法看完了，进去fill方法，没有贴全部的代码，还是一块一块看紧凑点\n\n```java\n        if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {\n            // TODO ugly bug fix. should not happen\n            if (layoutState.mAvailable < 0) {\n                layoutState.mScrollingOffset += layoutState.mAvailable;\n            }\n            recycleByLayoutState(recycler, layoutState);\n        }\n```\n这句确实不太明白什么意思也不敢说我现在看明白了。外层这个if是为了避开首次初始化的情况，只有正常滑动的情况时候才会进来，但是滑动情况下 layoutState.mAvailable < 0 这个条件只有在滑动距离过小不足以把最后一个item的底部完全滑进来的情况才满足，不过看官方的注释好像是有bug，可能就做了一个防御性的if判断，防止特殊情况发生把，就假设这个条件满足了，不做if里面的处理，好像也不会发生什么问题把，不过回头想一下mScrollingOffset这个字段的意思是“在不需要添加新的View时候能滑动的最大距离”，按照这么理解，当mAvailable<0时候，说明滑动距离太小，没法把item底部全滑进来，最多也就只能滑动此次滑动的距离，所以这么处理之后mSrollingOffset就是此次滑动距离；所以这个TODO注释看的挺烦的，还以为是bug，让人很纠结是个什么bug-_-，最后recycleByLayoutState方法回收了一下此次滚动发生之后会越界不见的View\n\n```java\n       private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) {\n        if (!layoutState.mRecycle || layoutState.mInfinite) {\n            return;\n        }\n        if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {\n            recycleViewsFromEnd(recycler, layoutState.mScrollingOffset);\n        } else {\n            recycleViewsFromStart(recycler, layoutState.mScrollingOffset);\n        }\n    }\n```\n根据滑动方向选择是从后往前回收还是从前往后回收，我们考虑手指上滑，所以可能会有头部的View出界被滑出去，所以是调用的recycleViewsFromStart方法\n\n```java\n  private void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt) {\n        if (dt < 0) {\n            if (DEBUG) {\n                Log.d(TAG, \"Called recycle from start with a negative value. This might happen\"\n                        + \" during layout changes but may be sign of a bug\");\n            }\n            return;\n        }\n        // ignore padding, ViewGroup may not clip children.\n        final int limit = dt;\n        final int childCount = getChildCount();\n        if (mShouldReverseLayout) {\n            for (int i = childCount - 1; i >= 0; i--) {\n                View child = getChildAt(i);\n                if (mOrientationHelper.getDecoratedEnd(child) > limit\n                        || mOrientationHelper.getTransformedEndWithDecoration(child) > limit) {\n                    // stop here\n                    recycleChildren(recycler, childCount - 1, i);\n                    return;\n                }\n            }\n        } else {\n            for (int i = 0; i < childCount; i++) {\n                View child = getChildAt(i);\n                if (mOrientationHelper.getDecoratedEnd(child) > limit\n                        || mOrientationHelper.getTransformedEndWithDecoration(child) > limit) {\n                    // stop here\n                    recycleChildren(recycler, 0, i);\n                    return;\n                }\n            }\n        }\n    }\n```\n看代码的第一句，如果dt<0就直接返回结束了，这也解释了为什么前面的纠结为什么当mAvailable < 0时候让mScrollingOffset加上mAvailable,就是为了让这里传入的dt是正值，也就是实际发生的滑动距离。由于不考虑逆序布局，直接看第二个for循环，其实这个循环要表达的意思是从头到尾遍历所有View直到找到一个滑动之后底部还没出界的View，那么在这个View之前的View全部要被回收掉。所谓回收掉就是把View节点从ViewHierarchy上删除掉了，但是被缓存起来了供重新绑定和重用。\n\n继续往fill方法下面看，进入while循环\n```java\n      while ((layoutState.mInfinite || remainingSpace > 0) && layoutState.hasMore(state)) {\n            layoutChunkResult.resetInternal();\n            if (VERBOSE_TRACING) {\n                TraceCompat.beginSection(\"LLM LayoutChunk\");\n            }\n            layoutChunk(recycler, state, layoutState, layoutChunkResult);\n            if (VERBOSE_TRACING) {\n                TraceCompat.endSection();\n            }\n            if (layoutChunkResult.mFinished) {\n                break;\n            }\n            layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;\n            /**\n             * Consume the available space if:\n             * * layoutChunk did not request to be ignored\n             * * OR we are laying out scrap children\n             * * OR we are not doing pre-layout\n             */\n            if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != null\n                    || !state.isPreLayout()) {\n                layoutState.mAvailable -= layoutChunkResult.mConsumed;\n                // we keep a separate remaining space because mAvailable is important for recycling\n                remainingSpace -= layoutChunkResult.mConsumed;\n            }\n\n            if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {\n                layoutState.mScrollingOffset += layoutChunkResult.mConsumed;\n                if (layoutState.mAvailable < 0) {\n                    layoutState.mScrollingOffset += layoutState.mAvailable;\n                }\n                recycleByLayoutState(recycler, layoutState);\n            }\n            if (stopOnFocusable && layoutChunkResult.mFocusable) {\n                break;\n            }\n        }\n```\n只要还有可用空间就依次取 View 并添加layout出来，之后更新mOffset和mAvailable,当然如果某个view是有焦点的，那么直接结束\n\n看LayoutChunk方法，顾名思义，就是layout小块的意思，就是把单个的itemView放置到合适的位置，并且传入了一个LayoutResult用于记录放置Item后的信息，就几个字段：\n mConsumed 消耗的距离\n mFinished 是否结束layout\n mIgnoreConsumed 是否忽略此次消耗的距离，滑动情况下这个值一直都是false\n mFocusable 当前item是否有焦点\n\n layoutChunk方法里面的逻辑，也没什么，就是测量，然后计算left top right bottom值。有一段逻辑比较重要，判断了mScrapList 是否为null，如果是null就调用了addDisappearingView方法，反之调用了addView;addView方法不用说就是简单的添加了View，但是addDisappearingView就是告诉RV，添加的这个View是马上就要移出屏幕的，注意是不可见了并不代表就是item被移除了也有可能是在屏幕之外。好了，我们再回头想象为什么是判断mScrapList为null就调用addDisappearingView。具体原因是mScapList其实绝大部分情况都是null，只有发生layout时候才不为空，而这个时候都是发生了item的增删改操作，导致有些View可能会超出RV的边界，也就是变成所谓的“hidden view”，不要被这个方法名迷惑，只是尝试加入hidden view，方法内部实际还是会根据flag判断之后决定是否需要hide 这个view。反过来mScrapList为null的时候就是对应滑动情况。\n\nlayoutChunk 方法内容不多，另外还需要注意的是这句：\n```java\n    if (params.isItemRemoved() || params.isItemChanged()) {\n            result.mIgnoreConsumed = true;\n        }\n```\n 意思很简单，就是Item被删除了或者变化了，就忽略消耗，也就是不计入消耗。最开始我也觉得奇怪，后来知道动画之后明白这么做是有意义的，虽然这个Item被删除了，但是你不能立马就给不显示了还是添加进来，毕竟还有动画在这个Item要执行，所以就得等到这个Item的动画完了才删除。那么不计入消耗的好处就是，会多layout一个Item出来，就是在底部，屏幕外面，虽然不可见，如图：\n ![](https://github.com/HirayClay/draft/blob/master/rv_removed.png?raw=true)\n item 2已经被移除了，并且item5会被加进来，但是在屏幕外我们看不到，等到item2动画结束item5就会滑进来。当然这个if判断在滑动情况下是不会进来的。\n\n 最后，所有的view添加完之后，其实view并没有在正确的位置，所以整体又进行平移，至此整个滑动流程都结束\n\n\nthe end","source":"_posts/LinearLayoutManager源码阅读（滑动）.md","raw":"---\ntitle: LinearLayoutManager源码阅读(滚动分析)\ndate: 2017-12-19 15:45:56\ntags: \n    - RecyclerView LayoutManager LinearLayoutManager\n    - Android\n\n---\n\n\n实现自定义的通用的LayoutManager，但是卡住了，遂看下Android 官方的几种LayoutManager是如何优雅实现的，大致的以及一些细节都看懂了，但是还是没找到什么好办法解决自己的问题，不如趁着热度把自己的分析过程写下来，也给其他需要的Androider.其实真的要对RecyclerView有个全面的认识，其实LayoutManager、Adapter、动画以及测量流程等细节都是要清楚的，因为虽然说RV给人使用上非常灵活解耦，但是其实内部也是这几者的紧密配合才达到的效果，所以有一点不明白其他地方可能也就会很模糊看不下去。也不细分章节了，就按照滚动的流程来写。至于为什么从滚动开始分析，是因为看源码还是讲究切入点，从RecyclerView的滑动开始是最佳切入点，很直观，要是第一次直接就从onLayoutChildren看起，我觉得看不了几行就得放弃。当然这篇文章的内容很多没说清楚的其实都是onLayoutChildren的一些逻辑，所以都略过了，只关注滑动。\n\n由于自定的LayoutManager如果要(肯定要，不然还定义啥)支持滚动都必须至少重写以下两个方法中的一个，并且返回true，分别表示支持垂直滚动和水平滚动\n```java\n public boolean canScrollHorizontally() {\n            return true;\n        }\n public boolean canScrollVertically() {\n            return true;\n        }\n```\n在发生滚动的时候，会在以下两个方法回调滚动的距离dy/dx\n```java\n    public int scrollVerticallyBy(int dy, Recycler recycler, State state) {\n            return 0;\n        }\n\n    public int scrollHorizontallyBy(int dx, Recycler recycler, State state) {\n            return 0;\n        }\n```\n这里我们从LinearLayoutManager的垂直滚动分析起，进入scrollBy方法,\n```java\n    int scrollBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) {\n        if (getChildCount() == 0 || dy == 0) {\n            return 0;\n        }\n        //滚动发生时，是需要回收View的\n        mLayoutState.mRecycle = true;\n        ensureLayoutState();\n        //手指向上滑动时dy>0\n        final int layoutDirection = dy > 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;\n        final int absDy = Math.abs(dy);\n        //更新LayoutState\n        updateLayoutState(layoutDirection, absDy, true, state);\n        final int consumed = mLayoutState.mScrollingOffset\n                + fill(recycler, mLayoutState, state, false);\n        if (consumed < 0) {\n            if (DEBUG) {\n                Log.d(TAG, \"Don't have any more elements to scroll\");\n            }\n            return 0;\n        }\n        final int scrolled = absDy > consumed ? layoutDirection * consumed : dy;\n        //layout view结束，所有View整体平移；这里需要注意的是LLM并非是从头到尾一个个layout view，而是先根据偏移把需要回收的view回收掉，会显示的view显示出来，最后进行整体的平移。想一想这样效率确实要高\n        mOrientationHelper.offsetChildren(-scrolled);\n        if (DEBUG) {\n            Log.d(TAG, \"scroll req: \" + dy + \" scrolled: \" + scrolled);\n        }\n        mLayoutState.mLastScrollDelta = scrolled;\n        return scrolled;\n    }\n```\n写了部分注释，具体分析一下updateLayoutState方法\n分析这个方法前，先看下LayoutState这个类，了解一下我们需要关注的几个重要参数的含义\n\nmRecycle 表示是否需要回收View,滑动情况下这个值是true，但是在有item 添加删除的情况是false，因为锚点什么的得靠view来确定，不能回收\n\nmOffset   layout View时候的起始坐标(垂直方向的LinearLayoutManager 表示y值)，e.g.比如发生滑动后，下一个item需要显示出来，那么mOffset的值就等于最后一个可见item的bottom值(不考虑margin，向上滑动)\n\nmAvailable 表示可用距离，在layout View的时候用到\n\nmCurrentPosition  表示获取View的起始索引，在layout View的时候循环取View的时候用到\n\nmItemDirection  获取item 数据的方向，是从前到后（值为1），还是从后往前（值为-1），本篇分析的是正序情况\n\nmExtra 在LayoutManager支持predictive动画的时候这个值很有用，具体的需要了解RV的动画机制才明白这个值怎么回事，简单的说就是即使一个item此时(当他即将进入RV可见范围时)对用户不可见，但是还是得把他layout出来，虽然已经超出了RV的边界用户看不到，这样做的目的是为了更好的动画体验（因为需要两次layout，一次pre-layout 一次post-layout来确定动画的起始和终止位置，不然就只能做最简单的fadeIn fadeOut。只有当item add remove发生时才有值，一般为0\n\n再回过来看updateLayoutState方法(并不喜欢贴太长串的代码。。。)\n```java\n     private void updateLayoutState(int layoutDirection, int requiredSpace,\n            boolean canUseExistingSpace, RecyclerView.State state) {\n        // If parent provides a hint, don't measure unlimited.\n        mLayoutState.mInfinite = resolveIsInfinite();\n        mLayoutState.mExtra = getExtraLayoutSpace(state);\n        mLayoutState.mLayoutDirection = layoutDirection;\n        int scrollingOffset;\n        if (layoutDirection == LayoutState.LAYOUT_END) {\n            mLayoutState.mExtra += mOrientationHelper.getEndPadding();\n            // get the first child in the direction we are going\n            final View child = getChildClosestToEnd();\n            // the direction in which we are traversing children\n            mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD\n                    : LayoutState.ITEM_DIRECTION_TAIL;\n            mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;\n            mLayoutState.mOffset = mOrientationHelper.getDecoratedEnd(child);\n            // calculate how much we can scroll without adding new children (independent of layout)\n            scrollingOffset = mOrientationHelper.getDecoratedEnd(child)\n                    - mOrientationHelper.getEndAfterPadding();\n\n        } else {\n            final View child = getChildClosestToStart();\n            mLayoutState.mExtra += mOrientationHelper.getStartAfterPadding();\n            mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL\n                    : LayoutState.ITEM_DIRECTION_HEAD;\n            mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;\n            mLayoutState.mOffset = mOrientationHelper.getDecoratedStart(child);\n            scrollingOffset = -mOrientationHelper.getDecoratedStart(child)\n                    + mOrientationHelper.getStartAfterPadding();\n        }\n        mLayoutState.mAvailable = requiredSpace;\n        if (canUseExistingSpace) {\n            mLayoutState.mAvailable -= scrollingOffset;\n        }\n        mLayoutState.mScrollingOffset = scrollingOffset;\n    }\n```\n前面几行就是简单的赋值更新状态，然后是根据layoutDirection的方向进行其他参数的计算，我们这里是分析的手指上滑，对应的layoutDireciton是LAYOUT_END，我们进入layoutDirection == LayoutState.LAYOUT_END成立的情况下去看：\n\n 1.通过getChildClosestToEnd方法拿到RV最接近End的child(如果是水平布局，那么end就是RV的right，垂直布局end就是RV的bottom)\n\n 2.根据mShouldReverseLayout变量给mItemDirection赋值，我们一般都不使用逆序布局，所以mItemDirection的值是ITEM_DIRECTION_HEAD，也就是说待会在fill方法内部取child来放的时候是正序，也就是从前往后依次取，反之亦然\n\n 3.根据刚才取到的child获取到其在adapter中的位置，加上mItemDirection后赋值给mCurrentPosition，这个好理解，mCurrentPosition表示的就是取child的开始索引，LayoutState里面有个next方法就是这么做的，可以看下代码\n\n ```java\n        View next(RecyclerView.Recycler recycler) {\n            if (mScrapList != null) {\n                return nextViewFromScrapList();\n            }\n            final View view = recycler.getViewForPosition(mCurrentPosition);\n            mCurrentPosition += mItemDirection;\n            return view;\n        }\n ```\n 4.给mOffset赋值，也就是下图最后一个item的bottom值，是后续依次放child的起始坐标\n ![](https://github.com/HirayClay/draft/blob/master/RV_LLM.png?raw=true)\n\n 5.至于scrollingOffset就是上面这张图里面最后一个item底部距离RV底部的距离，官方也有注释----\"不需要添加新的children的情况下滚动的最大距离\"-----也就是说最后一个item刚好完全滚进来，但是又不会有新的item滚进来的意思\n\n 6最后给mAvailable赋值为requiredSpace，也就是此次滚动的距离,然后判断canUseExistingSpace为true就减去刚才的scrollingOffset；这里为什么要减去这个scrollingOffset呢\n  ，其实就是把这个零头减掉方便计算而已，最后一句mScrollingOffset又把scrollingOffse\n  t保存起来了。最后所有child都放置好之后，返回消耗的滑动距离时候，在scrollBy方法那里\n  最后又把这个值加上去了，就这句：\n\n  ```java\n     final int consumed = mLayoutState.mScrollingOffset\n                + fill(recycler, mLayoutState, state, false);\n  ```\n\n  好了，这个方法看完了，进去fill方法，没有贴全部的代码，还是一块一块看紧凑点\n\n```java\n        if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {\n            // TODO ugly bug fix. should not happen\n            if (layoutState.mAvailable < 0) {\n                layoutState.mScrollingOffset += layoutState.mAvailable;\n            }\n            recycleByLayoutState(recycler, layoutState);\n        }\n```\n这句确实不太明白什么意思也不敢说我现在看明白了。外层这个if是为了避开首次初始化的情况，只有正常滑动的情况时候才会进来，但是滑动情况下 layoutState.mAvailable < 0 这个条件只有在滑动距离过小不足以把最后一个item的底部完全滑进来的情况才满足，不过看官方的注释好像是有bug，可能就做了一个防御性的if判断，防止特殊情况发生把，就假设这个条件满足了，不做if里面的处理，好像也不会发生什么问题把，不过回头想一下mScrollingOffset这个字段的意思是“在不需要添加新的View时候能滑动的最大距离”，按照这么理解，当mAvailable<0时候，说明滑动距离太小，没法把item底部全滑进来，最多也就只能滑动此次滑动的距离，所以这么处理之后mSrollingOffset就是此次滑动距离；所以这个TODO注释看的挺烦的，还以为是bug，让人很纠结是个什么bug-_-，最后recycleByLayoutState方法回收了一下此次滚动发生之后会越界不见的View\n\n```java\n       private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) {\n        if (!layoutState.mRecycle || layoutState.mInfinite) {\n            return;\n        }\n        if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {\n            recycleViewsFromEnd(recycler, layoutState.mScrollingOffset);\n        } else {\n            recycleViewsFromStart(recycler, layoutState.mScrollingOffset);\n        }\n    }\n```\n根据滑动方向选择是从后往前回收还是从前往后回收，我们考虑手指上滑，所以可能会有头部的View出界被滑出去，所以是调用的recycleViewsFromStart方法\n\n```java\n  private void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt) {\n        if (dt < 0) {\n            if (DEBUG) {\n                Log.d(TAG, \"Called recycle from start with a negative value. This might happen\"\n                        + \" during layout changes but may be sign of a bug\");\n            }\n            return;\n        }\n        // ignore padding, ViewGroup may not clip children.\n        final int limit = dt;\n        final int childCount = getChildCount();\n        if (mShouldReverseLayout) {\n            for (int i = childCount - 1; i >= 0; i--) {\n                View child = getChildAt(i);\n                if (mOrientationHelper.getDecoratedEnd(child) > limit\n                        || mOrientationHelper.getTransformedEndWithDecoration(child) > limit) {\n                    // stop here\n                    recycleChildren(recycler, childCount - 1, i);\n                    return;\n                }\n            }\n        } else {\n            for (int i = 0; i < childCount; i++) {\n                View child = getChildAt(i);\n                if (mOrientationHelper.getDecoratedEnd(child) > limit\n                        || mOrientationHelper.getTransformedEndWithDecoration(child) > limit) {\n                    // stop here\n                    recycleChildren(recycler, 0, i);\n                    return;\n                }\n            }\n        }\n    }\n```\n看代码的第一句，如果dt<0就直接返回结束了，这也解释了为什么前面的纠结为什么当mAvailable < 0时候让mScrollingOffset加上mAvailable,就是为了让这里传入的dt是正值，也就是实际发生的滑动距离。由于不考虑逆序布局，直接看第二个for循环，其实这个循环要表达的意思是从头到尾遍历所有View直到找到一个滑动之后底部还没出界的View，那么在这个View之前的View全部要被回收掉。所谓回收掉就是把View节点从ViewHierarchy上删除掉了，但是被缓存起来了供重新绑定和重用。\n\n继续往fill方法下面看，进入while循环\n```java\n      while ((layoutState.mInfinite || remainingSpace > 0) && layoutState.hasMore(state)) {\n            layoutChunkResult.resetInternal();\n            if (VERBOSE_TRACING) {\n                TraceCompat.beginSection(\"LLM LayoutChunk\");\n            }\n            layoutChunk(recycler, state, layoutState, layoutChunkResult);\n            if (VERBOSE_TRACING) {\n                TraceCompat.endSection();\n            }\n            if (layoutChunkResult.mFinished) {\n                break;\n            }\n            layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;\n            /**\n             * Consume the available space if:\n             * * layoutChunk did not request to be ignored\n             * * OR we are laying out scrap children\n             * * OR we are not doing pre-layout\n             */\n            if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != null\n                    || !state.isPreLayout()) {\n                layoutState.mAvailable -= layoutChunkResult.mConsumed;\n                // we keep a separate remaining space because mAvailable is important for recycling\n                remainingSpace -= layoutChunkResult.mConsumed;\n            }\n\n            if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {\n                layoutState.mScrollingOffset += layoutChunkResult.mConsumed;\n                if (layoutState.mAvailable < 0) {\n                    layoutState.mScrollingOffset += layoutState.mAvailable;\n                }\n                recycleByLayoutState(recycler, layoutState);\n            }\n            if (stopOnFocusable && layoutChunkResult.mFocusable) {\n                break;\n            }\n        }\n```\n只要还有可用空间就依次取 View 并添加layout出来，之后更新mOffset和mAvailable,当然如果某个view是有焦点的，那么直接结束\n\n看LayoutChunk方法，顾名思义，就是layout小块的意思，就是把单个的itemView放置到合适的位置，并且传入了一个LayoutResult用于记录放置Item后的信息，就几个字段：\n mConsumed 消耗的距离\n mFinished 是否结束layout\n mIgnoreConsumed 是否忽略此次消耗的距离，滑动情况下这个值一直都是false\n mFocusable 当前item是否有焦点\n\n layoutChunk方法里面的逻辑，也没什么，就是测量，然后计算left top right bottom值。有一段逻辑比较重要，判断了mScrapList 是否为null，如果是null就调用了addDisappearingView方法，反之调用了addView;addView方法不用说就是简单的添加了View，但是addDisappearingView就是告诉RV，添加的这个View是马上就要移出屏幕的，注意是不可见了并不代表就是item被移除了也有可能是在屏幕之外。好了，我们再回头想象为什么是判断mScrapList为null就调用addDisappearingView。具体原因是mScapList其实绝大部分情况都是null，只有发生layout时候才不为空，而这个时候都是发生了item的增删改操作，导致有些View可能会超出RV的边界，也就是变成所谓的“hidden view”，不要被这个方法名迷惑，只是尝试加入hidden view，方法内部实际还是会根据flag判断之后决定是否需要hide 这个view。反过来mScrapList为null的时候就是对应滑动情况。\n\nlayoutChunk 方法内容不多，另外还需要注意的是这句：\n```java\n    if (params.isItemRemoved() || params.isItemChanged()) {\n            result.mIgnoreConsumed = true;\n        }\n```\n 意思很简单，就是Item被删除了或者变化了，就忽略消耗，也就是不计入消耗。最开始我也觉得奇怪，后来知道动画之后明白这么做是有意义的，虽然这个Item被删除了，但是你不能立马就给不显示了还是添加进来，毕竟还有动画在这个Item要执行，所以就得等到这个Item的动画完了才删除。那么不计入消耗的好处就是，会多layout一个Item出来，就是在底部，屏幕外面，虽然不可见，如图：\n ![](https://github.com/HirayClay/draft/blob/master/rv_removed.png?raw=true)\n item 2已经被移除了，并且item5会被加进来，但是在屏幕外我们看不到，等到item2动画结束item5就会滑进来。当然这个if判断在滑动情况下是不会进来的。\n\n 最后，所有的view添加完之后，其实view并没有在正确的位置，所以整体又进行平移，至此整个滑动流程都结束\n\n\nthe end","slug":"LinearLayoutManager源码阅读（滑动）","published":1,"updated":"2018-01-23T08:07:05.241Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl1qvapa0006y4727tgg540r","content":"<p>实现自定义的通用的LayoutManager，但是卡住了，遂看下Android 官方的几种LayoutManager是如何优雅实现的，大致的以及一些细节都看懂了，但是还是没找到什么好办法解决自己的问题，不如趁着热度把自己的分析过程写下来，也给其他需要的Androider.其实真的要对RecyclerView有个全面的认识，其实LayoutManager、Adapter、动画以及测量流程等细节都是要清楚的，因为虽然说RV给人使用上非常灵活解耦，但是其实内部也是这几者的紧密配合才达到的效果，所以有一点不明白其他地方可能也就会很模糊看不下去。也不细分章节了，就按照滚动的流程来写。至于为什么从滚动开始分析，是因为看源码还是讲究切入点，从RecyclerView的滑动开始是最佳切入点，很直观，要是第一次直接就从onLayoutChildren看起，我觉得看不了几行就得放弃。当然这篇文章的内容很多没说清楚的其实都是onLayoutChildren的一些逻辑，所以都略过了，只关注滑动。</p>\n<p>由于自定的LayoutManager如果要(肯定要，不然还定义啥)支持滚动都必须至少重写以下两个方法中的一个，并且返回true，分别表示支持垂直滚动和水平滚动</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"> <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">canScrollHorizontally</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">canScrollVertically</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在发生滚动的时候，会在以下两个方法回调滚动的距离dy/dx</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">scrollVerticallyBy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> dy<span class=\"token punctuation\">,</span> Recycler recycler<span class=\"token punctuation\">,</span> State state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">scrollHorizontallyBy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> dx<span class=\"token punctuation\">,</span> Recycler recycler<span class=\"token punctuation\">,</span> State state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里我们从LinearLayoutManager的垂直滚动分析起，进入scrollBy方法,</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">    <span class=\"token keyword\">int</span> <span class=\"token function\">scrollBy</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> dy<span class=\"token punctuation\">,</span> RecyclerView<span class=\"token punctuation\">.</span>Recycler recycler<span class=\"token punctuation\">,</span> RecyclerView<span class=\"token punctuation\">.</span>State state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">getChildCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> dy <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//滚动发生时，是需要回收View的</span>\n        mLayoutState<span class=\"token punctuation\">.</span>mRecycle <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">ensureLayoutState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//手指向上滑动时dy>0</span>\n        <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> layoutDirection <span class=\"token operator\">=</span> dy <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> LayoutState<span class=\"token punctuation\">.</span>LAYOUT_END <span class=\"token operator\">:</span> LayoutState<span class=\"token punctuation\">.</span>LAYOUT_START<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> absDy <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>dy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//更新LayoutState</span>\n        <span class=\"token function\">updateLayoutState</span><span class=\"token punctuation\">(</span>layoutDirection<span class=\"token punctuation\">,</span> absDy<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> consumed <span class=\"token operator\">=</span> mLayoutState<span class=\"token punctuation\">.</span>mScrollingOffset\n                <span class=\"token operator\">+</span> <span class=\"token function\">fill</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> mLayoutState<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>consumed <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>DEBUG<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                Log<span class=\"token punctuation\">.</span><span class=\"token function\">d</span><span class=\"token punctuation\">(</span>TAG<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Don't have any more elements to scroll\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> scrolled <span class=\"token operator\">=</span> absDy <span class=\"token operator\">></span> consumed <span class=\"token operator\">?</span> layoutDirection <span class=\"token operator\">*</span> consumed <span class=\"token operator\">:</span> dy<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//layout view结束，所有View整体平移；这里需要注意的是LLM并非是从头到尾一个个layout view，而是先根据偏移把需要回收的view回收掉，会显示的view显示出来，最后进行整体的平移。想一想这样效率确实要高</span>\n        mOrientationHelper<span class=\"token punctuation\">.</span><span class=\"token function\">offsetChildren</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>scrolled<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>DEBUG<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Log<span class=\"token punctuation\">.</span><span class=\"token function\">d</span><span class=\"token punctuation\">(</span>TAG<span class=\"token punctuation\">,</span> <span class=\"token string\">\"scroll req: \"</span> <span class=\"token operator\">+</span> dy <span class=\"token operator\">+</span> <span class=\"token string\">\" scrolled: \"</span> <span class=\"token operator\">+</span> scrolled<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        mLayoutState<span class=\"token punctuation\">.</span>mLastScrollDelta <span class=\"token operator\">=</span> scrolled<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> scrolled<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>写了部分注释，具体分析一下updateLayoutState方法<br>分析这个方法前，先看下LayoutState这个类，了解一下我们需要关注的几个重要参数的含义</p>\n<p>mRecycle 表示是否需要回收View,滑动情况下这个值是true，但是在有item 添加删除的情况是false，因为锚点什么的得靠view来确定，不能回收</p>\n<p>mOffset   layout View时候的起始坐标(垂直方向的LinearLayoutManager 表示y值)，e.g.比如发生滑动后，下一个item需要显示出来，那么mOffset的值就等于最后一个可见item的bottom值(不考虑margin，向上滑动)</p>\n<p>mAvailable 表示可用距离，在layout View的时候用到</p>\n<p>mCurrentPosition  表示获取View的起始索引，在layout View的时候循环取View的时候用到</p>\n<p>mItemDirection  获取item 数据的方向，是从前到后（值为1），还是从后往前（值为-1），本篇分析的是正序情况</p>\n<p>mExtra 在LayoutManager支持predictive动画的时候这个值很有用，具体的需要了解RV的动画机制才明白这个值怎么回事，简单的说就是即使一个item此时(当他即将进入RV可见范围时)对用户不可见，但是还是得把他layout出来，虽然已经超出了RV的边界用户看不到，这样做的目的是为了更好的动画体验（因为需要两次layout，一次pre-layout 一次post-layout来确定动画的起始和终止位置，不然就只能做最简单的fadeIn fadeOut。只有当item add remove发生时才有值，一般为0</p>\n<p>再回过来看updateLayoutState方法(并不喜欢贴太长串的代码。。。)</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">     <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">updateLayoutState</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> layoutDirection<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> requiredSpace<span class=\"token punctuation\">,</span>\n            <span class=\"token keyword\">boolean</span> canUseExistingSpace<span class=\"token punctuation\">,</span> RecyclerView<span class=\"token punctuation\">.</span>State state<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// If parent provides a hint, don't measure unlimited.</span>\n        mLayoutState<span class=\"token punctuation\">.</span>mInfinite <span class=\"token operator\">=</span> <span class=\"token function\">resolveIsInfinite</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        mLayoutState<span class=\"token punctuation\">.</span>mExtra <span class=\"token operator\">=</span> <span class=\"token function\">getExtraLayoutSpace</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        mLayoutState<span class=\"token punctuation\">.</span>mLayoutDirection <span class=\"token operator\">=</span> layoutDirection<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> scrollingOffset<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>layoutDirection <span class=\"token operator\">==</span> LayoutState<span class=\"token punctuation\">.</span>LAYOUT_END<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            mLayoutState<span class=\"token punctuation\">.</span>mExtra <span class=\"token operator\">+=</span> mOrientationHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getEndPadding</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// get the first child in the direction we are going</span>\n            <span class=\"token keyword\">final</span> View child <span class=\"token operator\">=</span> <span class=\"token function\">getChildClosestToEnd</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// the direction in which we are traversing children</span>\n            mLayoutState<span class=\"token punctuation\">.</span>mItemDirection <span class=\"token operator\">=</span> mShouldReverseLayout <span class=\"token operator\">?</span> LayoutState<span class=\"token punctuation\">.</span>ITEM_DIRECTION_HEAD\n                    <span class=\"token operator\">:</span> LayoutState<span class=\"token punctuation\">.</span>ITEM_DIRECTION_TAIL<span class=\"token punctuation\">;</span>\n            mLayoutState<span class=\"token punctuation\">.</span>mCurrentPosition <span class=\"token operator\">=</span> <span class=\"token function\">getPosition</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> mLayoutState<span class=\"token punctuation\">.</span>mItemDirection<span class=\"token punctuation\">;</span>\n            mLayoutState<span class=\"token punctuation\">.</span>mOffset <span class=\"token operator\">=</span> mOrientationHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getDecoratedEnd</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// calculate how much we can scroll without adding new children (independent of layout)</span>\n            scrollingOffset <span class=\"token operator\">=</span> mOrientationHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getDecoratedEnd</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span>\n                    <span class=\"token operator\">-</span> mOrientationHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getEndAfterPadding</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span> View child <span class=\"token operator\">=</span> <span class=\"token function\">getChildClosestToStart</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            mLayoutState<span class=\"token punctuation\">.</span>mExtra <span class=\"token operator\">+=</span> mOrientationHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getStartAfterPadding</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            mLayoutState<span class=\"token punctuation\">.</span>mItemDirection <span class=\"token operator\">=</span> mShouldReverseLayout <span class=\"token operator\">?</span> LayoutState<span class=\"token punctuation\">.</span>ITEM_DIRECTION_TAIL\n                    <span class=\"token operator\">:</span> LayoutState<span class=\"token punctuation\">.</span>ITEM_DIRECTION_HEAD<span class=\"token punctuation\">;</span>\n            mLayoutState<span class=\"token punctuation\">.</span>mCurrentPosition <span class=\"token operator\">=</span> <span class=\"token function\">getPosition</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> mLayoutState<span class=\"token punctuation\">.</span>mItemDirection<span class=\"token punctuation\">;</span>\n            mLayoutState<span class=\"token punctuation\">.</span>mOffset <span class=\"token operator\">=</span> mOrientationHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getDecoratedStart</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            scrollingOffset <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>mOrientationHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getDecoratedStart</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span>\n                    <span class=\"token operator\">+</span> mOrientationHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getStartAfterPadding</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        mLayoutState<span class=\"token punctuation\">.</span>mAvailable <span class=\"token operator\">=</span> requiredSpace<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>canUseExistingSpace<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            mLayoutState<span class=\"token punctuation\">.</span>mAvailable <span class=\"token operator\">-=</span> scrollingOffset<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        mLayoutState<span class=\"token punctuation\">.</span>mScrollingOffset <span class=\"token operator\">=</span> scrollingOffset<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>前面几行就是简单的赋值更新状态，然后是根据layoutDirection的方向进行其他参数的计算，我们这里是分析的手指上滑，对应的layoutDireciton是LAYOUT_END，我们进入layoutDirection == LayoutState.LAYOUT_END成立的情况下去看：</p>\n<p> 1.通过getChildClosestToEnd方法拿到RV最接近End的child(如果是水平布局，那么end就是RV的right，垂直布局end就是RV的bottom)</p>\n<p> 2.根据mShouldReverseLayout变量给mItemDirection赋值，我们一般都不使用逆序布局，所以mItemDirection的值是ITEM_DIRECTION_HEAD，也就是说待会在fill方法内部取child来放的时候是正序，也就是从前往后依次取，反之亦然</p>\n<p> 3.根据刚才取到的child获取到其在adapter中的位置，加上mItemDirection后赋值给mCurrentPosition，这个好理解，mCurrentPosition表示的就是取child的开始索引，LayoutState里面有个next方法就是这么做的，可以看下代码</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">        View <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span>Recycler recycler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mScrapList <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> <span class=\"token function\">nextViewFromScrapList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">final</span> View view <span class=\"token operator\">=</span> recycler<span class=\"token punctuation\">.</span><span class=\"token function\">getViewForPosition</span><span class=\"token punctuation\">(</span>mCurrentPosition<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            mCurrentPosition <span class=\"token operator\">+=</span> mItemDirection<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> view<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p> 4.给mOffset赋值，也就是下图最后一个item的bottom值，是后续依次放child的起始坐标<br> <img src=\"https://github.com/HirayClay/draft/blob/master/RV_LLM.png?raw=true\" alt=\"\"></p>\n<p> 5.至于scrollingOffset就是上面这张图里面最后一个item底部距离RV底部的距离，官方也有注释—-“不需要添加新的children的情况下滚动的最大距离”—–也就是说最后一个item刚好完全滚进来，但是又不会有新的item滚进来的意思</p>\n<p> 6最后给mAvailable赋值为requiredSpace，也就是此次滚动的距离,然后判断canUseExistingSpace为true就减去刚才的scrollingOffset；这里为什么要减去这个scrollingOffset呢<br>  ，其实就是把这个零头减掉方便计算而已，最后一句mScrollingOffset又把scrollingOffse<br>  t保存起来了。最后所有child都放置好之后，返回消耗的滑动距离时候，在scrollBy方法那里<br>  最后又把这个值加上去了，就这句：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">     <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> consumed <span class=\"token operator\">=</span> mLayoutState<span class=\"token punctuation\">.</span>mScrollingOffset\n                <span class=\"token operator\">+</span> <span class=\"token function\">fill</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> mLayoutState<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p>  好了，这个方法看完了，进去fill方法，没有贴全部的代码，还是一块一块看紧凑点</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mScrollingOffset <span class=\"token operator\">!=</span> LayoutState<span class=\"token punctuation\">.</span>SCROLLING_OFFSET_NaN<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// TODO ugly bug fix. should not happen</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mAvailable <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                layoutState<span class=\"token punctuation\">.</span>mScrollingOffset <span class=\"token operator\">+=</span> layoutState<span class=\"token punctuation\">.</span>mAvailable<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token function\">recycleByLayoutState</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> layoutState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这句确实不太明白什么意思也不敢说我现在看明白了。外层这个if是为了避开首次初始化的情况，只有正常滑动的情况时候才会进来，但是滑动情况下 layoutState.mAvailable &lt; 0 这个条件只有在滑动距离过小不足以把最后一个item的底部完全滑进来的情况才满足，不过看官方的注释好像是有bug，可能就做了一个防御性的if判断，防止特殊情况发生把，就假设这个条件满足了，不做if里面的处理，好像也不会发生什么问题把，不过回头想一下mScrollingOffset这个字段的意思是“在不需要添加新的View时候能滑动的最大距离”，按照这么理解，当mAvailable&lt;0时候，说明滑动距离太小，没法把item底部全滑进来，最多也就只能滑动此次滑动的距离，所以这么处理之后mSrollingOffset就是此次滑动距离；所以这个TODO注释看的挺烦的，还以为是bug，让人很纠结是个什么bug-_-，最后recycleByLayoutState方法回收了一下此次滚动发生之后会越界不见的View</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">       <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">recycleByLayoutState</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span>Recycler recycler<span class=\"token punctuation\">,</span> LayoutState layoutState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>layoutState<span class=\"token punctuation\">.</span>mRecycle <span class=\"token operator\">||</span> layoutState<span class=\"token punctuation\">.</span>mInfinite<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mLayoutDirection <span class=\"token operator\">==</span> LayoutState<span class=\"token punctuation\">.</span>LAYOUT_START<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">recycleViewsFromEnd</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> layoutState<span class=\"token punctuation\">.</span>mScrollingOffset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">recycleViewsFromStart</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> layoutState<span class=\"token punctuation\">.</span>mScrollingOffset<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>根据滑动方向选择是从后往前回收还是从前往后回收，我们考虑手指上滑，所以可能会有头部的View出界被滑出去，所以是调用的recycleViewsFromStart方法</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">  <span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">recycleViewsFromStart</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span>Recycler recycler<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> dt<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dt <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>DEBUG<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                Log<span class=\"token punctuation\">.</span><span class=\"token function\">d</span><span class=\"token punctuation\">(</span>TAG<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Called recycle from start with a negative value. This might happen\"</span>\n                        <span class=\"token operator\">+</span> <span class=\"token string\">\" during layout changes but may be sign of a bug\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// ignore padding, ViewGroup may not clip children.</span>\n        <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> limit <span class=\"token operator\">=</span> dt<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> childCount <span class=\"token operator\">=</span> <span class=\"token function\">getChildCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mShouldReverseLayout<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> childCount <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                View child <span class=\"token operator\">=</span> <span class=\"token function\">getChildAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mOrientationHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getDecoratedEnd</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> limit\n                        <span class=\"token operator\">||</span> mOrientationHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getTransformedEndWithDecoration</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> limit<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// stop here</span>\n                    <span class=\"token function\">recycleChildren</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> childCount <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> childCount<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                View child <span class=\"token operator\">=</span> <span class=\"token function\">getChildAt</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mOrientationHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getDecoratedEnd</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> limit\n                        <span class=\"token operator\">||</span> mOrientationHelper<span class=\"token punctuation\">.</span><span class=\"token function\">getTransformedEndWithDecoration</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> limit<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// stop here</span>\n                    <span class=\"token function\">recycleChildren</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>看代码的第一句，如果dt&lt;0就直接返回结束了，这也解释了为什么前面的纠结为什么当mAvailable &lt; 0时候让mScrollingOffset加上mAvailable,就是为了让这里传入的dt是正值，也就是实际发生的滑动距离。由于不考虑逆序布局，直接看第二个for循环，其实这个循环要表达的意思是从头到尾遍历所有View直到找到一个滑动之后底部还没出界的View，那么在这个View之前的View全部要被回收掉。所谓回收掉就是把View节点从ViewHierarchy上删除掉了，但是被缓存起来了供重新绑定和重用。</p>\n<p>继续往fill方法下面看，进入while循环</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">      <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mInfinite <span class=\"token operator\">||</span> remainingSpace <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> layoutState<span class=\"token punctuation\">.</span><span class=\"token function\">hasMore</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            layoutChunkResult<span class=\"token punctuation\">.</span><span class=\"token function\">resetInternal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>VERBOSE_TRACING<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                TraceCompat<span class=\"token punctuation\">.</span><span class=\"token function\">beginSection</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"LLM LayoutChunk\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token function\">layoutChunk</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> layoutState<span class=\"token punctuation\">,</span> layoutChunkResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>VERBOSE_TRACING<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                TraceCompat<span class=\"token punctuation\">.</span><span class=\"token function\">endSection</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>layoutChunkResult<span class=\"token punctuation\">.</span>mFinished<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            layoutState<span class=\"token punctuation\">.</span>mOffset <span class=\"token operator\">+=</span> layoutChunkResult<span class=\"token punctuation\">.</span>mConsumed <span class=\"token operator\">*</span> layoutState<span class=\"token punctuation\">.</span>mLayoutDirection<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">/**\n             * Consume the available space if:\n             * * layoutChunk did not request to be ignored\n             * * OR we are laying out scrap children\n             * * OR we are not doing pre-layout\n             */</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>layoutChunkResult<span class=\"token punctuation\">.</span>mIgnoreConsumed <span class=\"token operator\">||</span> mLayoutState<span class=\"token punctuation\">.</span>mScrapList <span class=\"token operator\">!=</span> null\n                    <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>state<span class=\"token punctuation\">.</span><span class=\"token function\">isPreLayout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                layoutState<span class=\"token punctuation\">.</span>mAvailable <span class=\"token operator\">-=</span> layoutChunkResult<span class=\"token punctuation\">.</span>mConsumed<span class=\"token punctuation\">;</span>\n                <span class=\"token comment\" spellcheck=\"true\">// we keep a separate remaining space because mAvailable is important for recycling</span>\n                remainingSpace <span class=\"token operator\">-=</span> layoutChunkResult<span class=\"token punctuation\">.</span>mConsumed<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mScrollingOffset <span class=\"token operator\">!=</span> LayoutState<span class=\"token punctuation\">.</span>SCROLLING_OFFSET_NaN<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                layoutState<span class=\"token punctuation\">.</span>mScrollingOffset <span class=\"token operator\">+=</span> layoutChunkResult<span class=\"token punctuation\">.</span>mConsumed<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mAvailable <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    layoutState<span class=\"token punctuation\">.</span>mScrollingOffset <span class=\"token operator\">+=</span> layoutState<span class=\"token punctuation\">.</span>mAvailable<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token function\">recycleByLayoutState</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> layoutState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>stopOnFocusable <span class=\"token operator\">&amp;&amp;</span> layoutChunkResult<span class=\"token punctuation\">.</span>mFocusable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>只要还有可用空间就依次取 View 并添加layout出来，之后更新mOffset和mAvailable,当然如果某个view是有焦点的，那么直接结束</p>\n<p>看LayoutChunk方法，顾名思义，就是layout小块的意思，就是把单个的itemView放置到合适的位置，并且传入了一个LayoutResult用于记录放置Item后的信息，就几个字段：<br> mConsumed 消耗的距离<br> mFinished 是否结束layout<br> mIgnoreConsumed 是否忽略此次消耗的距离，滑动情况下这个值一直都是false<br> mFocusable 当前item是否有焦点</p>\n<p> layoutChunk方法里面的逻辑，也没什么，就是测量，然后计算left top right bottom值。有一段逻辑比较重要，判断了mScrapList 是否为null，如果是null就调用了addDisappearingView方法，反之调用了addView;addView方法不用说就是简单的添加了View，但是addDisappearingView就是告诉RV，添加的这个View是马上就要移出屏幕的，注意是不可见了并不代表就是item被移除了也有可能是在屏幕之外。好了，我们再回头想象为什么是判断mScrapList为null就调用addDisappearingView。具体原因是mScapList其实绝大部分情况都是null，只有发生layout时候才不为空，而这个时候都是发生了item的增删改操作，导致有些View可能会超出RV的边界，也就是变成所谓的“hidden view”，不要被这个方法名迷惑，只是尝试加入hidden view，方法内部实际还是会根据flag判断之后决定是否需要hide 这个view。反过来mScrapList为null的时候就是对应滑动情况。</p>\n<p>layoutChunk 方法内容不多，另外还需要注意的是这句：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>params<span class=\"token punctuation\">.</span><span class=\"token function\">isItemRemoved</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> params<span class=\"token punctuation\">.</span><span class=\"token function\">isItemChanged</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            result<span class=\"token punctuation\">.</span>mIgnoreConsumed <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p> 意思很简单，就是Item被删除了或者变化了，就忽略消耗，也就是不计入消耗。最开始我也觉得奇怪，后来知道动画之后明白这么做是有意义的，虽然这个Item被删除了，但是你不能立马就给不显示了还是添加进来，毕竟还有动画在这个Item要执行，所以就得等到这个Item的动画完了才删除。那么不计入消耗的好处就是，会多layout一个Item出来，就是在底部，屏幕外面，虽然不可见，如图：<br> <img src=\"https://github.com/HirayClay/draft/blob/master/rv_removed.png?raw=true\" alt=\"\"><br> item 2已经被移除了，并且item5会被加进来，但是在屏幕外我们看不到，等到item2动画结束item5就会滑进来。当然这个if判断在滑动情况下是不会进来的。</p>\n<p> 最后，所有的view添加完之后，其实view并没有在正确的位置，所以整体又进行平移，至此整个滑动流程都结束</p>\n<p>the end</p>\n","site":{"data":{}},"excerpt":"","more":"<p>实现自定义的通用的LayoutManager，但是卡住了，遂看下Android 官方的几种LayoutManager是如何优雅实现的，大致的以及一些细节都看懂了，但是还是没找到什么好办法解决自己的问题，不如趁着热度把自己的分析过程写下来，也给其他需要的Androider.其实真的要对RecyclerView有个全面的认识，其实LayoutManager、Adapter、动画以及测量流程等细节都是要清楚的，因为虽然说RV给人使用上非常灵活解耦，但是其实内部也是这几者的紧密配合才达到的效果，所以有一点不明白其他地方可能也就会很模糊看不下去。也不细分章节了，就按照滚动的流程来写。至于为什么从滚动开始分析，是因为看源码还是讲究切入点，从RecyclerView的滑动开始是最佳切入点，很直观，要是第一次直接就从onLayoutChildren看起，我觉得看不了几行就得放弃。当然这篇文章的内容很多没说清楚的其实都是onLayoutChildren的一些逻辑，所以都略过了，只关注滑动。</p>\n<p>由于自定的LayoutManager如果要(肯定要，不然还定义啥)支持滚动都必须至少重写以下两个方法中的一个，并且返回true，分别表示支持垂直滚动和水平滚动</p>\n<pre><code class=\"java\"> public boolean canScrollHorizontally() {\n            return true;\n        }\n public boolean canScrollVertically() {\n            return true;\n        }\n</code></pre>\n<p>在发生滚动的时候，会在以下两个方法回调滚动的距离dy/dx</p>\n<pre><code class=\"java\">    public int scrollVerticallyBy(int dy, Recycler recycler, State state) {\n            return 0;\n        }\n\n    public int scrollHorizontallyBy(int dx, Recycler recycler, State state) {\n            return 0;\n        }\n</code></pre>\n<p>这里我们从LinearLayoutManager的垂直滚动分析起，进入scrollBy方法,</p>\n<pre><code class=\"java\">    int scrollBy(int dy, RecyclerView.Recycler recycler, RecyclerView.State state) {\n        if (getChildCount() == 0 || dy == 0) {\n            return 0;\n        }\n        //滚动发生时，是需要回收View的\n        mLayoutState.mRecycle = true;\n        ensureLayoutState();\n        //手指向上滑动时dy&gt;0\n        final int layoutDirection = dy &gt; 0 ? LayoutState.LAYOUT_END : LayoutState.LAYOUT_START;\n        final int absDy = Math.abs(dy);\n        //更新LayoutState\n        updateLayoutState(layoutDirection, absDy, true, state);\n        final int consumed = mLayoutState.mScrollingOffset\n                + fill(recycler, mLayoutState, state, false);\n        if (consumed &lt; 0) {\n            if (DEBUG) {\n                Log.d(TAG, &quot;Don&#39;t have any more elements to scroll&quot;);\n            }\n            return 0;\n        }\n        final int scrolled = absDy &gt; consumed ? layoutDirection * consumed : dy;\n        //layout view结束，所有View整体平移；这里需要注意的是LLM并非是从头到尾一个个layout view，而是先根据偏移把需要回收的view回收掉，会显示的view显示出来，最后进行整体的平移。想一想这样效率确实要高\n        mOrientationHelper.offsetChildren(-scrolled);\n        if (DEBUG) {\n            Log.d(TAG, &quot;scroll req: &quot; + dy + &quot; scrolled: &quot; + scrolled);\n        }\n        mLayoutState.mLastScrollDelta = scrolled;\n        return scrolled;\n    }\n</code></pre>\n<p>写了部分注释，具体分析一下updateLayoutState方法<br>分析这个方法前，先看下LayoutState这个类，了解一下我们需要关注的几个重要参数的含义</p>\n<p>mRecycle 表示是否需要回收View,滑动情况下这个值是true，但是在有item 添加删除的情况是false，因为锚点什么的得靠view来确定，不能回收</p>\n<p>mOffset   layout View时候的起始坐标(垂直方向的LinearLayoutManager 表示y值)，e.g.比如发生滑动后，下一个item需要显示出来，那么mOffset的值就等于最后一个可见item的bottom值(不考虑margin，向上滑动)</p>\n<p>mAvailable 表示可用距离，在layout View的时候用到</p>\n<p>mCurrentPosition  表示获取View的起始索引，在layout View的时候循环取View的时候用到</p>\n<p>mItemDirection  获取item 数据的方向，是从前到后（值为1），还是从后往前（值为-1），本篇分析的是正序情况</p>\n<p>mExtra 在LayoutManager支持predictive动画的时候这个值很有用，具体的需要了解RV的动画机制才明白这个值怎么回事，简单的说就是即使一个item此时(当他即将进入RV可见范围时)对用户不可见，但是还是得把他layout出来，虽然已经超出了RV的边界用户看不到，这样做的目的是为了更好的动画体验（因为需要两次layout，一次pre-layout 一次post-layout来确定动画的起始和终止位置，不然就只能做最简单的fadeIn fadeOut。只有当item add remove发生时才有值，一般为0</p>\n<p>再回过来看updateLayoutState方法(并不喜欢贴太长串的代码。。。)</p>\n<pre><code class=\"java\">     private void updateLayoutState(int layoutDirection, int requiredSpace,\n            boolean canUseExistingSpace, RecyclerView.State state) {\n        // If parent provides a hint, don&#39;t measure unlimited.\n        mLayoutState.mInfinite = resolveIsInfinite();\n        mLayoutState.mExtra = getExtraLayoutSpace(state);\n        mLayoutState.mLayoutDirection = layoutDirection;\n        int scrollingOffset;\n        if (layoutDirection == LayoutState.LAYOUT_END) {\n            mLayoutState.mExtra += mOrientationHelper.getEndPadding();\n            // get the first child in the direction we are going\n            final View child = getChildClosestToEnd();\n            // the direction in which we are traversing children\n            mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD\n                    : LayoutState.ITEM_DIRECTION_TAIL;\n            mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;\n            mLayoutState.mOffset = mOrientationHelper.getDecoratedEnd(child);\n            // calculate how much we can scroll without adding new children (independent of layout)\n            scrollingOffset = mOrientationHelper.getDecoratedEnd(child)\n                    - mOrientationHelper.getEndAfterPadding();\n\n        } else {\n            final View child = getChildClosestToStart();\n            mLayoutState.mExtra += mOrientationHelper.getStartAfterPadding();\n            mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL\n                    : LayoutState.ITEM_DIRECTION_HEAD;\n            mLayoutState.mCurrentPosition = getPosition(child) + mLayoutState.mItemDirection;\n            mLayoutState.mOffset = mOrientationHelper.getDecoratedStart(child);\n            scrollingOffset = -mOrientationHelper.getDecoratedStart(child)\n                    + mOrientationHelper.getStartAfterPadding();\n        }\n        mLayoutState.mAvailable = requiredSpace;\n        if (canUseExistingSpace) {\n            mLayoutState.mAvailable -= scrollingOffset;\n        }\n        mLayoutState.mScrollingOffset = scrollingOffset;\n    }\n</code></pre>\n<p>前面几行就是简单的赋值更新状态，然后是根据layoutDirection的方向进行其他参数的计算，我们这里是分析的手指上滑，对应的layoutDireciton是LAYOUT_END，我们进入layoutDirection == LayoutState.LAYOUT_END成立的情况下去看：</p>\n<p> 1.通过getChildClosestToEnd方法拿到RV最接近End的child(如果是水平布局，那么end就是RV的right，垂直布局end就是RV的bottom)</p>\n<p> 2.根据mShouldReverseLayout变量给mItemDirection赋值，我们一般都不使用逆序布局，所以mItemDirection的值是ITEM_DIRECTION_HEAD，也就是说待会在fill方法内部取child来放的时候是正序，也就是从前往后依次取，反之亦然</p>\n<p> 3.根据刚才取到的child获取到其在adapter中的位置，加上mItemDirection后赋值给mCurrentPosition，这个好理解，mCurrentPosition表示的就是取child的开始索引，LayoutState里面有个next方法就是这么做的，可以看下代码</p>\n<pre><code class=\"java\">        View next(RecyclerView.Recycler recycler) {\n            if (mScrapList != null) {\n                return nextViewFromScrapList();\n            }\n            final View view = recycler.getViewForPosition(mCurrentPosition);\n            mCurrentPosition += mItemDirection;\n            return view;\n        }\n</code></pre>\n<p> 4.给mOffset赋值，也就是下图最后一个item的bottom值，是后续依次放child的起始坐标<br> <img src=\"https://github.com/HirayClay/draft/blob/master/RV_LLM.png?raw=true\" alt=\"\"></p>\n<p> 5.至于scrollingOffset就是上面这张图里面最后一个item底部距离RV底部的距离，官方也有注释—-“不需要添加新的children的情况下滚动的最大距离”—–也就是说最后一个item刚好完全滚进来，但是又不会有新的item滚进来的意思</p>\n<p> 6最后给mAvailable赋值为requiredSpace，也就是此次滚动的距离,然后判断canUseExistingSpace为true就减去刚才的scrollingOffset；这里为什么要减去这个scrollingOffset呢<br>  ，其实就是把这个零头减掉方便计算而已，最后一句mScrollingOffset又把scrollingOffse<br>  t保存起来了。最后所有child都放置好之后，返回消耗的滑动距离时候，在scrollBy方法那里<br>  最后又把这个值加上去了，就这句：</p>\n<pre><code class=\"java\">     final int consumed = mLayoutState.mScrollingOffset\n                + fill(recycler, mLayoutState, state, false);\n</code></pre>\n<p>  好了，这个方法看完了，进去fill方法，没有贴全部的代码，还是一块一块看紧凑点</p>\n<pre><code class=\"java\">        if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {\n            // TODO ugly bug fix. should not happen\n            if (layoutState.mAvailable &lt; 0) {\n                layoutState.mScrollingOffset += layoutState.mAvailable;\n            }\n            recycleByLayoutState(recycler, layoutState);\n        }\n</code></pre>\n<p>这句确实不太明白什么意思也不敢说我现在看明白了。外层这个if是为了避开首次初始化的情况，只有正常滑动的情况时候才会进来，但是滑动情况下 layoutState.mAvailable &lt; 0 这个条件只有在滑动距离过小不足以把最后一个item的底部完全滑进来的情况才满足，不过看官方的注释好像是有bug，可能就做了一个防御性的if判断，防止特殊情况发生把，就假设这个条件满足了，不做if里面的处理，好像也不会发生什么问题把，不过回头想一下mScrollingOffset这个字段的意思是“在不需要添加新的View时候能滑动的最大距离”，按照这么理解，当mAvailable&lt;0时候，说明滑动距离太小，没法把item底部全滑进来，最多也就只能滑动此次滑动的距离，所以这么处理之后mSrollingOffset就是此次滑动距离；所以这个TODO注释看的挺烦的，还以为是bug，让人很纠结是个什么bug-_-，最后recycleByLayoutState方法回收了一下此次滚动发生之后会越界不见的View</p>\n<pre><code class=\"java\">       private void recycleByLayoutState(RecyclerView.Recycler recycler, LayoutState layoutState) {\n        if (!layoutState.mRecycle || layoutState.mInfinite) {\n            return;\n        }\n        if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {\n            recycleViewsFromEnd(recycler, layoutState.mScrollingOffset);\n        } else {\n            recycleViewsFromStart(recycler, layoutState.mScrollingOffset);\n        }\n    }\n</code></pre>\n<p>根据滑动方向选择是从后往前回收还是从前往后回收，我们考虑手指上滑，所以可能会有头部的View出界被滑出去，所以是调用的recycleViewsFromStart方法</p>\n<pre><code class=\"java\">  private void recycleViewsFromStart(RecyclerView.Recycler recycler, int dt) {\n        if (dt &lt; 0) {\n            if (DEBUG) {\n                Log.d(TAG, &quot;Called recycle from start with a negative value. This might happen&quot;\n                        + &quot; during layout changes but may be sign of a bug&quot;);\n            }\n            return;\n        }\n        // ignore padding, ViewGroup may not clip children.\n        final int limit = dt;\n        final int childCount = getChildCount();\n        if (mShouldReverseLayout) {\n            for (int i = childCount - 1; i &gt;= 0; i--) {\n                View child = getChildAt(i);\n                if (mOrientationHelper.getDecoratedEnd(child) &gt; limit\n                        || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) {\n                    // stop here\n                    recycleChildren(recycler, childCount - 1, i);\n                    return;\n                }\n            }\n        } else {\n            for (int i = 0; i &lt; childCount; i++) {\n                View child = getChildAt(i);\n                if (mOrientationHelper.getDecoratedEnd(child) &gt; limit\n                        || mOrientationHelper.getTransformedEndWithDecoration(child) &gt; limit) {\n                    // stop here\n                    recycleChildren(recycler, 0, i);\n                    return;\n                }\n            }\n        }\n    }\n</code></pre>\n<p>看代码的第一句，如果dt&lt;0就直接返回结束了，这也解释了为什么前面的纠结为什么当mAvailable &lt; 0时候让mScrollingOffset加上mAvailable,就是为了让这里传入的dt是正值，也就是实际发生的滑动距离。由于不考虑逆序布局，直接看第二个for循环，其实这个循环要表达的意思是从头到尾遍历所有View直到找到一个滑动之后底部还没出界的View，那么在这个View之前的View全部要被回收掉。所谓回收掉就是把View节点从ViewHierarchy上删除掉了，但是被缓存起来了供重新绑定和重用。</p>\n<p>继续往fill方法下面看，进入while循环</p>\n<pre><code class=\"java\">      while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) {\n            layoutChunkResult.resetInternal();\n            if (VERBOSE_TRACING) {\n                TraceCompat.beginSection(&quot;LLM LayoutChunk&quot;);\n            }\n            layoutChunk(recycler, state, layoutState, layoutChunkResult);\n            if (VERBOSE_TRACING) {\n                TraceCompat.endSection();\n            }\n            if (layoutChunkResult.mFinished) {\n                break;\n            }\n            layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;\n            /**\n             * Consume the available space if:\n             * * layoutChunk did not request to be ignored\n             * * OR we are laying out scrap children\n             * * OR we are not doing pre-layout\n             */\n            if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != null\n                    || !state.isPreLayout()) {\n                layoutState.mAvailable -= layoutChunkResult.mConsumed;\n                // we keep a separate remaining space because mAvailable is important for recycling\n                remainingSpace -= layoutChunkResult.mConsumed;\n            }\n\n            if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {\n                layoutState.mScrollingOffset += layoutChunkResult.mConsumed;\n                if (layoutState.mAvailable &lt; 0) {\n                    layoutState.mScrollingOffset += layoutState.mAvailable;\n                }\n                recycleByLayoutState(recycler, layoutState);\n            }\n            if (stopOnFocusable &amp;&amp; layoutChunkResult.mFocusable) {\n                break;\n            }\n        }\n</code></pre>\n<p>只要还有可用空间就依次取 View 并添加layout出来，之后更新mOffset和mAvailable,当然如果某个view是有焦点的，那么直接结束</p>\n<p>看LayoutChunk方法，顾名思义，就是layout小块的意思，就是把单个的itemView放置到合适的位置，并且传入了一个LayoutResult用于记录放置Item后的信息，就几个字段：<br> mConsumed 消耗的距离<br> mFinished 是否结束layout<br> mIgnoreConsumed 是否忽略此次消耗的距离，滑动情况下这个值一直都是false<br> mFocusable 当前item是否有焦点</p>\n<p> layoutChunk方法里面的逻辑，也没什么，就是测量，然后计算left top right bottom值。有一段逻辑比较重要，判断了mScrapList 是否为null，如果是null就调用了addDisappearingView方法，反之调用了addView;addView方法不用说就是简单的添加了View，但是addDisappearingView就是告诉RV，添加的这个View是马上就要移出屏幕的，注意是不可见了并不代表就是item被移除了也有可能是在屏幕之外。好了，我们再回头想象为什么是判断mScrapList为null就调用addDisappearingView。具体原因是mScapList其实绝大部分情况都是null，只有发生layout时候才不为空，而这个时候都是发生了item的增删改操作，导致有些View可能会超出RV的边界，也就是变成所谓的“hidden view”，不要被这个方法名迷惑，只是尝试加入hidden view，方法内部实际还是会根据flag判断之后决定是否需要hide 这个view。反过来mScrapList为null的时候就是对应滑动情况。</p>\n<p>layoutChunk 方法内容不多，另外还需要注意的是这句：</p>\n<pre><code class=\"java\">    if (params.isItemRemoved() || params.isItemChanged()) {\n            result.mIgnoreConsumed = true;\n        }\n</code></pre>\n<p> 意思很简单，就是Item被删除了或者变化了，就忽略消耗，也就是不计入消耗。最开始我也觉得奇怪，后来知道动画之后明白这么做是有意义的，虽然这个Item被删除了，但是你不能立马就给不显示了还是添加进来，毕竟还有动画在这个Item要执行，所以就得等到这个Item的动画完了才删除。那么不计入消耗的好处就是，会多layout一个Item出来，就是在底部，屏幕外面，虽然不可见，如图：<br> <img src=\"https://github.com/HirayClay/draft/blob/master/rv_removed.png?raw=true\" alt=\"\"><br> item 2已经被移除了，并且item5会被加进来，但是在屏幕外我们看不到，等到item2动画结束item5就会滑进来。当然这个if判断在滑动情况下是不会进来的。</p>\n<p> 最后，所有的view添加完之后，其实view并没有在正确的位置，所以整体又进行平移，至此整个滑动流程都结束</p>\n<p>the end</p>\n"},{"title":"ProducerArbiter","date":"2018-08-16T06:32:41.000Z","_content":"\n### Producer并不是一层不变\n前面说过Subscriber可以通过setProducer设置Producer，而且这个方法也是支持并发调用的，意味着我们的Producer是可能不断变化的————换个说法————我们的数据源可能会改变。关于Producer的逻辑看这个{% post_link RxJava中的-Producer %}。但是那篇文章没有提到的是，如果我们的Producer在中途改变了，会发生什么情况。举个例子(这个例子实际来自RxJava开发者的一篇进阶[博文](https://blog.piasy.com/AdvancedRxJava/2016/07/02/operator-concurrency-primitives-7/))：\n\n给定两个Observable,希望观察第一个Observable，当一个Observable结束之后，观察第二个Observable，第二个Observable结束了，那么才会结束,自定义了一个TheObserve操作符\n```java\n    public static final class ThenObserve<T> implements Observable.Operator<T, T> {\n        final Observable<? extends T> other;\n        public ThenObserve(Observable<? extends T> other) {\n            this.other = other;\n        }\n\n        @Override\n        public Subscriber<? super T> call(Subscriber<? super T> child) {\n            Subscriber<T> parent = new Subscriber<T>(child, false) {\n                @Override\n                public void onNext(T t) {\n                    child.onNext(t);\n                }\n                @Override\n                public void onError(Throwable e) {\n                    child.onError(e);\n                }\n                @Override\n                public void onCompleted() {\n                    other.unsafeSubscribe(child);\n                }\n            };\n            child.add(parent);\n            return parent;\n        }\n    }\n\n    Observable<Integer> source = Observable\n                .range(1, 10)\n                .lift(new ThenObserve<>(Observable.range(11, 90)));\n\n    TestSubscriber<Integer> ts = new TestSubscriber<>();\n    ts.requestMore(20);\n\n    source.subscribe(ts);\n\n    ts.getOnNextEvents().forEach(System.out::println);\n```\n结果输出了1到30一共30个数字，并不像预想的先输出1-10 然后输出剩下的11-20 一共20个数字。问题出在Subscriber上。\n\n我们知道Subscriber可以向上游请求数据，如果没有设置Producer，内部有个requested计数器会将这个请求先保存起来，待到调用了setProducer的时候会把请求传递到上游。\n而问题在于这个计数器只负责累计计数，并不会在请求已经到达的时候，减去已经完成的请求。那么在这个例子导致的问题就是第一个range(1,10)发出了10个数后，紧接着数据源变成了range(11,90),此时这个range(11,90)依然得到这个 数值为20个requested ，所以依然发射了 20个数字，所以最后导致一共产生了30个数据。那么应对这种数据源发生变化的场景我们需要用到ProducerArbiter。\n\n\n？？emitLoop 实际使用underlying producer在发射数据？？ProducerArbiter实际是完善了Subscriber只能累加已经产生的请求，而不能减去已经生产的请求而导致同一个请求，在生产者变化的情况下，请求会被执行两次，而ProducerArbiter做了加法减法计数两项工作。","source":"_posts/ProducerArbiter.md","raw":"---\ntitle: ProducerArbiter\ndate: 2018-08-16 14:32:41\ntags:\n---\n\n### Producer并不是一层不变\n前面说过Subscriber可以通过setProducer设置Producer，而且这个方法也是支持并发调用的，意味着我们的Producer是可能不断变化的————换个说法————我们的数据源可能会改变。关于Producer的逻辑看这个{% post_link RxJava中的-Producer %}。但是那篇文章没有提到的是，如果我们的Producer在中途改变了，会发生什么情况。举个例子(这个例子实际来自RxJava开发者的一篇进阶[博文](https://blog.piasy.com/AdvancedRxJava/2016/07/02/operator-concurrency-primitives-7/))：\n\n给定两个Observable,希望观察第一个Observable，当一个Observable结束之后，观察第二个Observable，第二个Observable结束了，那么才会结束,自定义了一个TheObserve操作符\n```java\n    public static final class ThenObserve<T> implements Observable.Operator<T, T> {\n        final Observable<? extends T> other;\n        public ThenObserve(Observable<? extends T> other) {\n            this.other = other;\n        }\n\n        @Override\n        public Subscriber<? super T> call(Subscriber<? super T> child) {\n            Subscriber<T> parent = new Subscriber<T>(child, false) {\n                @Override\n                public void onNext(T t) {\n                    child.onNext(t);\n                }\n                @Override\n                public void onError(Throwable e) {\n                    child.onError(e);\n                }\n                @Override\n                public void onCompleted() {\n                    other.unsafeSubscribe(child);\n                }\n            };\n            child.add(parent);\n            return parent;\n        }\n    }\n\n    Observable<Integer> source = Observable\n                .range(1, 10)\n                .lift(new ThenObserve<>(Observable.range(11, 90)));\n\n    TestSubscriber<Integer> ts = new TestSubscriber<>();\n    ts.requestMore(20);\n\n    source.subscribe(ts);\n\n    ts.getOnNextEvents().forEach(System.out::println);\n```\n结果输出了1到30一共30个数字，并不像预想的先输出1-10 然后输出剩下的11-20 一共20个数字。问题出在Subscriber上。\n\n我们知道Subscriber可以向上游请求数据，如果没有设置Producer，内部有个requested计数器会将这个请求先保存起来，待到调用了setProducer的时候会把请求传递到上游。\n而问题在于这个计数器只负责累计计数，并不会在请求已经到达的时候，减去已经完成的请求。那么在这个例子导致的问题就是第一个range(1,10)发出了10个数后，紧接着数据源变成了range(11,90),此时这个range(11,90)依然得到这个 数值为20个requested ，所以依然发射了 20个数字，所以最后导致一共产生了30个数据。那么应对这种数据源发生变化的场景我们需要用到ProducerArbiter。\n\n\n？？emitLoop 实际使用underlying producer在发射数据？？ProducerArbiter实际是完善了Subscriber只能累加已经产生的请求，而不能减去已经生产的请求而导致同一个请求，在生产者变化的情况下，请求会被执行两次，而ProducerArbiter做了加法减法计数两项工作。","slug":"ProducerArbiter","published":1,"updated":"2018-08-16T09:55:24.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl1qvapc0008y472ga6i9d69","content":"<h3 id=\"Producer并不是一层不变\"><a href=\"#Producer并不是一层不变\" class=\"headerlink\" title=\"Producer并不是一层不变\"></a>Producer并不是一层不变</h3><p>前面说过Subscriber可以通过setProducer设置Producer，而且这个方法也是支持并发调用的，意味着我们的Producer是可能不断变化的————换个说法————我们的数据源可能会改变。关于Producer的逻辑看这个<a href=\"/2018/08/15/RxJava中的-Producer/\" title=\"RxJava中的 Producer\">RxJava中的 Producer</a>。但是那篇文章没有提到的是，如果我们的Producer在中途改变了，会发生什么情况。举个例子(这个例子实际来自RxJava开发者的一篇进阶<a href=\"https://blog.piasy.com/AdvancedRxJava/2016/07/02/operator-concurrency-primitives-7/\" target=\"_blank\" rel=\"external\">博文</a>)：</p>\n<p>给定两个Observable,希望观察第一个Observable，当一个Observable结束之后，观察第二个Observable，第二个Observable结束了，那么才会结束,自定义了一个TheObserve操作符</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThenObserve</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Observable<span class=\"token punctuation\">.</span>Operator</span><span class=\"token operator\">&lt;</span>T<span class=\"token punctuation\">,</span> T<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">final</span> Observable<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> other<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">public</span> <span class=\"token function\">ThenObserve</span><span class=\"token punctuation\">(</span>Observable<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> other<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>other <span class=\"token operator\">=</span> other<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> Subscriber<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> T<span class=\"token operator\">></span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>Subscriber<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> T<span class=\"token operator\">></span> child<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Subscriber<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> parent <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Subscriber</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token annotation punctuation\">@Override</span>\n                <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span>T t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    child<span class=\"token punctuation\">.</span><span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token annotation punctuation\">@Override</span>\n                <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>Throwable e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    child<span class=\"token punctuation\">.</span><span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token annotation punctuation\">@Override</span>\n                <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onCompleted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    other<span class=\"token punctuation\">.</span><span class=\"token function\">unsafeSubscribe</span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            child<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> parent<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    Observable<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> source <span class=\"token operator\">=</span> Observable\n                <span class=\"token punctuation\">.</span><span class=\"token function\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">lift</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ThenObserve</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>Observable<span class=\"token punctuation\">.</span><span class=\"token function\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">,</span> <span class=\"token number\">90</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    TestSubscriber<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> ts <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TestSubscriber</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ts<span class=\"token punctuation\">.</span><span class=\"token function\">requestMore</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    source<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span>ts<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    ts<span class=\"token punctuation\">.</span><span class=\"token function\">getOnNextEvents</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>System<span class=\"token punctuation\">.</span>out<span class=\"token operator\">:</span><span class=\"token operator\">:</span>println<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>结果输出了1到30一共30个数字，并不像预想的先输出1-10 然后输出剩下的11-20 一共20个数字。问题出在Subscriber上。</p>\n<p>我们知道Subscriber可以向上游请求数据，如果没有设置Producer，内部有个requested计数器会将这个请求先保存起来，待到调用了setProducer的时候会把请求传递到上游。<br>而问题在于这个计数器只负责累计计数，并不会在请求已经到达的时候，减去已经完成的请求。那么在这个例子导致的问题就是第一个range(1,10)发出了10个数后，紧接着数据源变成了range(11,90),此时这个range(11,90)依然得到这个 数值为20个requested ，所以依然发射了 20个数字，所以最后导致一共产生了30个数据。那么应对这种数据源发生变化的场景我们需要用到ProducerArbiter。</p>\n<p>？？emitLoop 实际使用underlying producer在发射数据？？ProducerArbiter实际是完善了Subscriber只能累加已经产生的请求，而不能减去已经生产的请求而导致同一个请求，在生产者变化的情况下，请求会被执行两次，而ProducerArbiter做了加法减法计数两项工作。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Producer并不是一层不变\"><a href=\"#Producer并不是一层不变\" class=\"headerlink\" title=\"Producer并不是一层不变\"></a>Producer并不是一层不变</h3><p>前面说过Subscriber可以通过setProducer设置Producer，而且这个方法也是支持并发调用的，意味着我们的Producer是可能不断变化的————换个说法————我们的数据源可能会改变。关于Producer的逻辑看这个<a href=\"/2018/08/15/RxJava中的-Producer/\" title=\"RxJava中的 Producer\">RxJava中的 Producer</a>。但是那篇文章没有提到的是，如果我们的Producer在中途改变了，会发生什么情况。举个例子(这个例子实际来自RxJava开发者的一篇进阶<a href=\"https://blog.piasy.com/AdvancedRxJava/2016/07/02/operator-concurrency-primitives-7/\" target=\"_blank\" rel=\"external\">博文</a>)：</p>\n<p>给定两个Observable,希望观察第一个Observable，当一个Observable结束之后，观察第二个Observable，第二个Observable结束了，那么才会结束,自定义了一个TheObserve操作符</p>\n<pre><code class=\"java\">    public static final class ThenObserve&lt;T&gt; implements Observable.Operator&lt;T, T&gt; {\n        final Observable&lt;? extends T&gt; other;\n        public ThenObserve(Observable&lt;? extends T&gt; other) {\n            this.other = other;\n        }\n\n        @Override\n        public Subscriber&lt;? super T&gt; call(Subscriber&lt;? super T&gt; child) {\n            Subscriber&lt;T&gt; parent = new Subscriber&lt;T&gt;(child, false) {\n                @Override\n                public void onNext(T t) {\n                    child.onNext(t);\n                }\n                @Override\n                public void onError(Throwable e) {\n                    child.onError(e);\n                }\n                @Override\n                public void onCompleted() {\n                    other.unsafeSubscribe(child);\n                }\n            };\n            child.add(parent);\n            return parent;\n        }\n    }\n\n    Observable&lt;Integer&gt; source = Observable\n                .range(1, 10)\n                .lift(new ThenObserve&lt;&gt;(Observable.range(11, 90)));\n\n    TestSubscriber&lt;Integer&gt; ts = new TestSubscriber&lt;&gt;();\n    ts.requestMore(20);\n\n    source.subscribe(ts);\n\n    ts.getOnNextEvents().forEach(System.out::println);\n</code></pre>\n<p>结果输出了1到30一共30个数字，并不像预想的先输出1-10 然后输出剩下的11-20 一共20个数字。问题出在Subscriber上。</p>\n<p>我们知道Subscriber可以向上游请求数据，如果没有设置Producer，内部有个requested计数器会将这个请求先保存起来，待到调用了setProducer的时候会把请求传递到上游。<br>而问题在于这个计数器只负责累计计数，并不会在请求已经到达的时候，减去已经完成的请求。那么在这个例子导致的问题就是第一个range(1,10)发出了10个数后，紧接着数据源变成了range(11,90),此时这个range(11,90)依然得到这个 数值为20个requested ，所以依然发射了 20个数字，所以最后导致一共产生了30个数据。那么应对这种数据源发生变化的场景我们需要用到ProducerArbiter。</p>\n<p>？？emitLoop 实际使用underlying producer在发射数据？？ProducerArbiter实际是完善了Subscriber只能累加已经产生的请求，而不能减去已经生产的请求而导致同一个请求，在生产者变化的情况下，请求会被执行两次，而ProducerArbiter做了加法减法计数两项工作。</p>\n"},{"title":"RxJava Scheduler一点理解","date":"2018-08-15T09:32:59.000Z","_content":"\n### subscribeOn\n通过subscribeOn 和 ObserveOn 两个方法rxjava可以灵活的指定任务执行的线程和指定收到事件的线程\n直接看源码：\n```java\n        public final Observable<T> subscribeOn(Scheduler scheduler, boolean requestOn) {\n        if (this instanceof ScalarSynchronousObservable) {\n            return ((ScalarSynchronousObservable<T>)this).scalarScheduleOn(scheduler);\n        }\n        return unsafeCreate(new OperatorSubscribeOn<T>(this, scheduler, requestOn));\n    }\n```\n使用了lift操作，看一下OperatorSubscribeOn这个操作符,重点是call方法：\n\n```java\n   @Override\n    public void call(final Subscriber<? super T> subscriber) {\n        final Worker inner = scheduler.createWorker();\n\n        SubscribeOnSubscriber<T> parent = new SubscribeOnSubscriber<T>(subscriber, requestOn, inner, source);\n        subscriber.add(parent);\n        subscriber.add(inner);\n\n        inner.schedule(parent);\n    }\n```\n这个SubscribeOnSubscriber类型的parent实际是个Action0,然后inner.schedule(parent)直接让这个任务在指定的线程执行了，\n然后事件到来的时候，简单调用这个call方法参数传来的Subscriber 调用一下onNext onError onComplete就完了。嗯，其实也很简单，一下就懂了，就是把source Observable的订阅放到一个指定的Scheduler中执行，然后事件也会在所在的Scheduler中发出来。其实可以得出一个结论：无论subscribeOn调用多少次，调度都只会在第一次调用subscribeOn指定的线程中执行。比如一个Observable 调用了subscribeOn(Schedulers.io).subscribeOn(Schedulers.compution()),其实这样做的效果可以拆分看，第一次调用subscribeOn把调度指定在io线程，那么后面的调度就是想把  '把调度指定在io' 的调度指定在computation线程，换个说法，我有一个操作是要指定调度在io线程 ，只不过我把这个操作放在了computation线程去执行而已，有种脱了什么放什么的多余+_+(实在找不出什么恰当的比喻了)。\n\n我们以一个小栗子来看一下整个流程：\n<pre><code>\n val observable = Observable.create(Observable.OnSubscribe<Int> { subscriber ->\n            Log.i(\"source===>\", Thread.currentThread().name)\n            for (i in 0..0) {\n                subscriber.onNext(i)\n            }\n\n            subscriber.onCompleted()\n        })\n val map = observable\n                .observeOn(Schedulers.computation())\n                .subscribeOn(Schedulers.newThread())\n                .map(Func1<Int, String> { integer ->\n                    Log.i(\"map===>\", Thread.currentThread().name)\n                    integer!!.toString()\n                })\n\n\n map.observeOn(Schedulers.newThread())\n                .subscribe(Action1<String> { s -> Log.i(\"onNext===>\", Thread.currentThread().name) })\n</code></pre>\n\n首先创建一个简单的发射一个数字的Observable，然后调用map操作转换成string 然后打印出来。注意subscribeOn 和ObserveOn的位置，我们是先observeOn 然后subscribeOn\n打印结果：\n\n<pre>\n    <code>\n    source===>: RxNewThreadScheduler-2\n    map===>: RxComputationScheduler-1\n    onNext===>: RxNewThreadScheduler-1\n    </code>\n</pre>\n\n可以看到最后的onNext 调用并没有像预想的那样 发生在observeOn指定的computation 线程中，而是subscribeOn指定的创建的新线程中。\n其实结合前面的subscribeOn的源码分析可以知道，调用subscribeOn之后的所有操作其实都会在subscribeOn 指定的线程中，这也是为什么map 和subscribe 两个操作都发生在RxNewThreadScheduler的原因。\n\n### observeOn\nObserveOn和SubscribeOn不太一样，subscribeOn方法是放在哪儿都可以调用多次也只有第一次调用的效果。ObserveOn也可以多次调用，但是每次都会生效，要理解清楚还得看代码，直接进入OperatorObserveOn操作符的call方法\n<pre><code>\n       @Override\n    public Subscriber<? super T> call(Subscriber<? super T> child) {\n        if (scheduler instanceof ImmediateScheduler) {\n            // avoid overhead, execute directly\n            return child;\n        } else if (scheduler instanceof TrampolineScheduler) {\n            // avoid overhead, execute directly\n            return child;\n        } else {\n            ObserveOnSubscriber<T> parent = new ObserveOnSubscriber<T>(scheduler, child, delayError, bufferSize);\n            parent.init();\n            return parent;\n        }\n    }\n\n</code></pre>\n不同的是 observeOn 的call方法是有返回值的，对于很多call方法有返回值的操作符，其实都可以认作是代理模式。包装了下游的subscriber，生成新的subscriber,然后让这个新的subscriber订阅上游observable,自己内部先处理，然后转发给下游的subscriber,达到代理的目的。我们再看一下这个ObserveOnSubscriber:\n\n1)\n<pre><code>\n         @Override\n        public void onNext(final T t) {\n            if (isUnsubscribed() || finished) {\n                return;\n            }\n            if (!queue.offer(NotificationLite.next(t))) {\n                onError(new MissingBackpressureException());\n                return;\n            }\n            schedule();\n        }\n</code></pre>\n\n当接收到上游发来的事件时，调用onNext,然后先存入队列，存入成功，则会执行schedule方法进行调度，schedule方法了解一下：\n\n2)\n<pre><code>\n            protected void schedule() {\n            if (counter.getAndIncrement() == 0) {\n                recursiveScheduler.schedule(this);\n            }\n        }\n</code></pre>\n非常简单的一句，如果当前没有任务（发射事件）调度，那么开始，并且把计数器加一，这里实际是对多线程的考虑，同一时刻只能有一个线程进行调度 。结合上面的onNext方法一起看就是——————如果有任务，先放入队列，放不进去就调用onError，不然就调度，而调度的话又必须满足当前没有其他线程在调度。调度任务会执行ObserveOnSubscriber的call方法,这样就实现了线程切换。call方法内部就是让传进来的child subscriber接收上游的事件，到这里我们可以得出结论ObserveOn 其实只对ObserveOn调用之后的操作生效。举个例子(kotlin编写)：\n<pre><code>\n val ob = Observable.create(Observable.OnSubscribe<Int> { t ->\n            t.onNext(1)\n            t.onCompleted()\n        })\n ob.observeOn(Schedulers.io())\n                .map { it->it.toString() }\n                .observeOn(Schedulers.computation())\n                .map { it-> it.toCharArray() }\n                .subscribe {  }\n</code></pre>\n上游简单发射一个Int数字,第一次调用ObserveOn 那么对于这第一个ObserveOn的操作符而言call方法传入的subscriber是下游map 生成的MapSubscriber,所以第一个map的操作发生在io线程，当同理第二个map 也会发生在computation线程。其实到这里可以总结出来ObserveOn方法的作用其实就是将之后的操作调度ObserveOn指定的线程中执行。\n\n3)\ncall 方法实现：\n<pre><code>\n     @Override\n        public void call() {\n            long missed = 1L;//能进入到call这个方法，说明进入前，说明只有一次调度（就是本次调度）\n            long currentEmission = emitted;\n            final Queue<Object> q = this.queue;\n            final Subscriber<? super T> localChild = this.child;\n            for (;;) {\n                long requestAmount = requested.get();//获取下游的请求数量\n\n                while (requestAmount != currentEmission) { //直到把下游的请求都发射完为止\n                    boolean done = finished;\n                    Object v = q.poll();\n                    boolean empty = v == null;\n\n                    if (checkTerminated(done, empty, localChild, q)) { //是否已经结束\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    localChild.onNext(NotificationLite.<T>getValue(v));\n\n                    currentEmission++;\n                    if (currentEmission == limit) {\n                        requestAmount = BackpressureUtils.produced(requested, currentEmission);\n                        request(currentEmission);\n                        currentEmission = 0L;\n                    }\n                }\n\n                if (requestAmount == currentEmission) {\n                    if (checkTerminated(finished, q.isEmpty(), localChild, q)) {\n                        return;\n                    }\n                }\n\n                emitted = currentEmission;\n                missed = counter.addAndGet(-missed);//如果不是0，其他线程可能也在请求，导致新的多个调度任务，那么还得继续处理，记录调度任务数量，进入下次循环，直到任务全部处理完为止\n                if (missed == 0L) {\n                    break;\n                }\n            }\n        }\n</code></pre>\n大致逻辑梳理一下：\n- 首先声明了一个missed  = 1L记录需要调度的数量以及一个currentMission记录已经发射的事件数量；\n- 一个for循环嵌套了一个while循环：\n    1. while循环的作用就是发射事件，发射事件之前检查是否已经结束，结束的原因可能是已经结束了或者发生错误\n    2. 每发射一个事件就计数","source":"_posts/RxJava-Scheduler一点理解.md","raw":"---\ntitle: RxJava Scheduler一点理解\ndate: 2018-08-15 17:32:59\ntags:\n    - RxJava\n    - Scheduler\n    - 线程调度\n---\n\n### subscribeOn\n通过subscribeOn 和 ObserveOn 两个方法rxjava可以灵活的指定任务执行的线程和指定收到事件的线程\n直接看源码：\n```java\n        public final Observable<T> subscribeOn(Scheduler scheduler, boolean requestOn) {\n        if (this instanceof ScalarSynchronousObservable) {\n            return ((ScalarSynchronousObservable<T>)this).scalarScheduleOn(scheduler);\n        }\n        return unsafeCreate(new OperatorSubscribeOn<T>(this, scheduler, requestOn));\n    }\n```\n使用了lift操作，看一下OperatorSubscribeOn这个操作符,重点是call方法：\n\n```java\n   @Override\n    public void call(final Subscriber<? super T> subscriber) {\n        final Worker inner = scheduler.createWorker();\n\n        SubscribeOnSubscriber<T> parent = new SubscribeOnSubscriber<T>(subscriber, requestOn, inner, source);\n        subscriber.add(parent);\n        subscriber.add(inner);\n\n        inner.schedule(parent);\n    }\n```\n这个SubscribeOnSubscriber类型的parent实际是个Action0,然后inner.schedule(parent)直接让这个任务在指定的线程执行了，\n然后事件到来的时候，简单调用这个call方法参数传来的Subscriber 调用一下onNext onError onComplete就完了。嗯，其实也很简单，一下就懂了，就是把source Observable的订阅放到一个指定的Scheduler中执行，然后事件也会在所在的Scheduler中发出来。其实可以得出一个结论：无论subscribeOn调用多少次，调度都只会在第一次调用subscribeOn指定的线程中执行。比如一个Observable 调用了subscribeOn(Schedulers.io).subscribeOn(Schedulers.compution()),其实这样做的效果可以拆分看，第一次调用subscribeOn把调度指定在io线程，那么后面的调度就是想把  '把调度指定在io' 的调度指定在computation线程，换个说法，我有一个操作是要指定调度在io线程 ，只不过我把这个操作放在了computation线程去执行而已，有种脱了什么放什么的多余+_+(实在找不出什么恰当的比喻了)。\n\n我们以一个小栗子来看一下整个流程：\n<pre><code>\n val observable = Observable.create(Observable.OnSubscribe<Int> { subscriber ->\n            Log.i(\"source===>\", Thread.currentThread().name)\n            for (i in 0..0) {\n                subscriber.onNext(i)\n            }\n\n            subscriber.onCompleted()\n        })\n val map = observable\n                .observeOn(Schedulers.computation())\n                .subscribeOn(Schedulers.newThread())\n                .map(Func1<Int, String> { integer ->\n                    Log.i(\"map===>\", Thread.currentThread().name)\n                    integer!!.toString()\n                })\n\n\n map.observeOn(Schedulers.newThread())\n                .subscribe(Action1<String> { s -> Log.i(\"onNext===>\", Thread.currentThread().name) })\n</code></pre>\n\n首先创建一个简单的发射一个数字的Observable，然后调用map操作转换成string 然后打印出来。注意subscribeOn 和ObserveOn的位置，我们是先observeOn 然后subscribeOn\n打印结果：\n\n<pre>\n    <code>\n    source===>: RxNewThreadScheduler-2\n    map===>: RxComputationScheduler-1\n    onNext===>: RxNewThreadScheduler-1\n    </code>\n</pre>\n\n可以看到最后的onNext 调用并没有像预想的那样 发生在observeOn指定的computation 线程中，而是subscribeOn指定的创建的新线程中。\n其实结合前面的subscribeOn的源码分析可以知道，调用subscribeOn之后的所有操作其实都会在subscribeOn 指定的线程中，这也是为什么map 和subscribe 两个操作都发生在RxNewThreadScheduler的原因。\n\n### observeOn\nObserveOn和SubscribeOn不太一样，subscribeOn方法是放在哪儿都可以调用多次也只有第一次调用的效果。ObserveOn也可以多次调用，但是每次都会生效，要理解清楚还得看代码，直接进入OperatorObserveOn操作符的call方法\n<pre><code>\n       @Override\n    public Subscriber<? super T> call(Subscriber<? super T> child) {\n        if (scheduler instanceof ImmediateScheduler) {\n            // avoid overhead, execute directly\n            return child;\n        } else if (scheduler instanceof TrampolineScheduler) {\n            // avoid overhead, execute directly\n            return child;\n        } else {\n            ObserveOnSubscriber<T> parent = new ObserveOnSubscriber<T>(scheduler, child, delayError, bufferSize);\n            parent.init();\n            return parent;\n        }\n    }\n\n</code></pre>\n不同的是 observeOn 的call方法是有返回值的，对于很多call方法有返回值的操作符，其实都可以认作是代理模式。包装了下游的subscriber，生成新的subscriber,然后让这个新的subscriber订阅上游observable,自己内部先处理，然后转发给下游的subscriber,达到代理的目的。我们再看一下这个ObserveOnSubscriber:\n\n1)\n<pre><code>\n         @Override\n        public void onNext(final T t) {\n            if (isUnsubscribed() || finished) {\n                return;\n            }\n            if (!queue.offer(NotificationLite.next(t))) {\n                onError(new MissingBackpressureException());\n                return;\n            }\n            schedule();\n        }\n</code></pre>\n\n当接收到上游发来的事件时，调用onNext,然后先存入队列，存入成功，则会执行schedule方法进行调度，schedule方法了解一下：\n\n2)\n<pre><code>\n            protected void schedule() {\n            if (counter.getAndIncrement() == 0) {\n                recursiveScheduler.schedule(this);\n            }\n        }\n</code></pre>\n非常简单的一句，如果当前没有任务（发射事件）调度，那么开始，并且把计数器加一，这里实际是对多线程的考虑，同一时刻只能有一个线程进行调度 。结合上面的onNext方法一起看就是——————如果有任务，先放入队列，放不进去就调用onError，不然就调度，而调度的话又必须满足当前没有其他线程在调度。调度任务会执行ObserveOnSubscriber的call方法,这样就实现了线程切换。call方法内部就是让传进来的child subscriber接收上游的事件，到这里我们可以得出结论ObserveOn 其实只对ObserveOn调用之后的操作生效。举个例子(kotlin编写)：\n<pre><code>\n val ob = Observable.create(Observable.OnSubscribe<Int> { t ->\n            t.onNext(1)\n            t.onCompleted()\n        })\n ob.observeOn(Schedulers.io())\n                .map { it->it.toString() }\n                .observeOn(Schedulers.computation())\n                .map { it-> it.toCharArray() }\n                .subscribe {  }\n</code></pre>\n上游简单发射一个Int数字,第一次调用ObserveOn 那么对于这第一个ObserveOn的操作符而言call方法传入的subscriber是下游map 生成的MapSubscriber,所以第一个map的操作发生在io线程，当同理第二个map 也会发生在computation线程。其实到这里可以总结出来ObserveOn方法的作用其实就是将之后的操作调度ObserveOn指定的线程中执行。\n\n3)\ncall 方法实现：\n<pre><code>\n     @Override\n        public void call() {\n            long missed = 1L;//能进入到call这个方法，说明进入前，说明只有一次调度（就是本次调度）\n            long currentEmission = emitted;\n            final Queue<Object> q = this.queue;\n            final Subscriber<? super T> localChild = this.child;\n            for (;;) {\n                long requestAmount = requested.get();//获取下游的请求数量\n\n                while (requestAmount != currentEmission) { //直到把下游的请求都发射完为止\n                    boolean done = finished;\n                    Object v = q.poll();\n                    boolean empty = v == null;\n\n                    if (checkTerminated(done, empty, localChild, q)) { //是否已经结束\n                        return;\n                    }\n\n                    if (empty) {\n                        break;\n                    }\n\n                    localChild.onNext(NotificationLite.<T>getValue(v));\n\n                    currentEmission++;\n                    if (currentEmission == limit) {\n                        requestAmount = BackpressureUtils.produced(requested, currentEmission);\n                        request(currentEmission);\n                        currentEmission = 0L;\n                    }\n                }\n\n                if (requestAmount == currentEmission) {\n                    if (checkTerminated(finished, q.isEmpty(), localChild, q)) {\n                        return;\n                    }\n                }\n\n                emitted = currentEmission;\n                missed = counter.addAndGet(-missed);//如果不是0，其他线程可能也在请求，导致新的多个调度任务，那么还得继续处理，记录调度任务数量，进入下次循环，直到任务全部处理完为止\n                if (missed == 0L) {\n                    break;\n                }\n            }\n        }\n</code></pre>\n大致逻辑梳理一下：\n- 首先声明了一个missed  = 1L记录需要调度的数量以及一个currentMission记录已经发射的事件数量；\n- 一个for循环嵌套了一个while循环：\n    1. while循环的作用就是发射事件，发射事件之前检查是否已经结束，结束的原因可能是已经结束了或者发生错误\n    2. 每发射一个事件就计数","slug":"RxJava-Scheduler一点理解","published":1,"updated":"2018-08-16T02:36:47.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl1qvapg0009y472t6rsc1lt","content":"<h3 id=\"subscribeOn\"><a href=\"#subscribeOn\" class=\"headerlink\" title=\"subscribeOn\"></a>subscribeOn</h3><p>通过subscribeOn 和 ObserveOn 两个方法rxjava可以灵活的指定任务执行的线程和指定收到事件的线程<br>直接看源码：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">        <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> Observable<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">subscribeOn</span><span class=\"token punctuation\">(</span>Scheduler scheduler<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> requestOn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">ScalarSynchronousObservable</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ScalarSynchronousObservable<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">scalarScheduleOn</span><span class=\"token punctuation\">(</span>scheduler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">unsafeCreate</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">OperatorSubscribeOn</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> scheduler<span class=\"token punctuation\">,</span> requestOn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>使用了lift操作，看一下OperatorSubscribeOn这个操作符,重点是call方法：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">   <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> Subscriber<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> T<span class=\"token operator\">></span> subscriber<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">final</span> Worker inner <span class=\"token operator\">=</span> scheduler<span class=\"token punctuation\">.</span><span class=\"token function\">createWorker</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        SubscribeOnSubscriber<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> parent <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SubscribeOnSubscriber</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>subscriber<span class=\"token punctuation\">,</span> requestOn<span class=\"token punctuation\">,</span> inner<span class=\"token punctuation\">,</span> source<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        subscriber<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        subscriber<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>inner<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        inner<span class=\"token punctuation\">.</span><span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span>parent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这个SubscribeOnSubscriber类型的parent实际是个Action0,然后inner.schedule(parent)直接让这个任务在指定的线程执行了，<br>然后事件到来的时候，简单调用这个call方法参数传来的Subscriber 调用一下onNext onError onComplete就完了。嗯，其实也很简单，一下就懂了，就是把source Observable的订阅放到一个指定的Scheduler中执行，然后事件也会在所在的Scheduler中发出来。其实可以得出一个结论：无论subscribeOn调用多少次，调度都只会在第一次调用subscribeOn指定的线程中执行。比如一个Observable 调用了subscribeOn(Schedulers.io).subscribeOn(Schedulers.compution()),其实这样做的效果可以拆分看，第一次调用subscribeOn把调度指定在io线程，那么后面的调度就是想把  ‘把调度指定在io’ 的调度指定在computation线程，换个说法，我有一个操作是要指定调度在io线程 ，只不过我把这个操作放在了computation线程去执行而已，有种脱了什么放什么的多余+_+(实在找不出什么恰当的比喻了)。</p>\n<p>我们以一个小栗子来看一下整个流程：</p>\n<pre><code>\n val observable = Observable.create(Observable.OnSubscribe<int> { subscriber ->\n            Log.i(\"source===>\", Thread.currentThread().name)\n            for (i in 0..0) {\n                subscriber.onNext(i)\n            }\n\n            subscriber.onCompleted()\n        })\n val map = observable\n                .observeOn(Schedulers.computation())\n                .subscribeOn(Schedulers.newThread())\n                .map(Func1<int, string=\"\"> { integer ->\n                    Log.i(\"map===>\", Thread.currentThread().name)\n                    integer!!.toString()\n                })\n\n\n map.observeOn(Schedulers.newThread())\n                .subscribe(Action1<string> { s -> Log.i(\"onNext===>\", Thread.currentThread().name) })\n</string></int,></int></code></pre>\n\n<p>首先创建一个简单的发射一个数字的Observable，然后调用map操作转换成string 然后打印出来。注意subscribeOn 和ObserveOn的位置，我们是先observeOn 然后subscribeOn<br>打印结果：</p>\n<pre>\n    <code>\n    source===>: RxNewThreadScheduler-2\n    map===>: RxComputationScheduler-1\n    onNext===>: RxNewThreadScheduler-1\n    </code>\n</pre>\n\n<p>可以看到最后的onNext 调用并没有像预想的那样 发生在observeOn指定的computation 线程中，而是subscribeOn指定的创建的新线程中。<br>其实结合前面的subscribeOn的源码分析可以知道，调用subscribeOn之后的所有操作其实都会在subscribeOn 指定的线程中，这也是为什么map 和subscribe 两个操作都发生在RxNewThreadScheduler的原因。</p>\n<h3 id=\"observeOn\"><a href=\"#observeOn\" class=\"headerlink\" title=\"observeOn\"></a>observeOn</h3><p>ObserveOn和SubscribeOn不太一样，subscribeOn方法是放在哪儿都可以调用多次也只有第一次调用的效果。ObserveOn也可以多次调用，但是每次都会生效，要理解清楚还得看代码，直接进入OperatorObserveOn操作符的call方法</p>\n<pre><code>\n       @Override\n    public Subscriber<? super T> call(Subscriber<? super T> child) {\n        if (scheduler instanceof ImmediateScheduler) {\n            // avoid overhead, execute directly\n            return child;\n        } else if (scheduler instanceof TrampolineScheduler) {\n            // avoid overhead, execute directly\n            return child;\n        } else {\n            ObserveOnSubscriber<t> parent = new ObserveOnSubscriber<t>(scheduler, child, delayError, bufferSize);\n            parent.init();\n            return parent;\n        }\n    }\n\n</t></t></code></pre>\n不同的是 observeOn 的call方法是有返回值的，对于很多call方法有返回值的操作符，其实都可以认作是代理模式。包装了下游的subscriber，生成新的subscriber,然后让这个新的subscriber订阅上游observable,自己内部先处理，然后转发给下游的subscriber,达到代理的目的。我们再看一下这个ObserveOnSubscriber:\n\n1)\n<pre><code>\n         @Override\n        public void onNext(final T t) {\n            if (isUnsubscribed() || finished) {\n                return;\n            }\n            if (!queue.offer(NotificationLite.next(t))) {\n                onError(new MissingBackpressureException());\n                return;\n            }\n            schedule();\n        }\n</code></pre>\n\n<p>当接收到上游发来的事件时，调用onNext,然后先存入队列，存入成功，则会执行schedule方法进行调度，schedule方法了解一下：</p>\n<p>2)</p>\n<p><pre><code><br>            protected void schedule() {<br>            if (counter.getAndIncrement() == 0) {<br>                recursiveScheduler.schedule(this);<br>            }<br>        }<br></code></pre><br>非常简单的一句，如果当前没有任务（发射事件）调度，那么开始，并且把计数器加一，这里实际是对多线程的考虑，同一时刻只能有一个线程进行调度 。结合上面的onNext方法一起看就是——————如果有任务，先放入队列，放不进去就调用onError，不然就调度，而调度的话又必须满足当前没有其他线程在调度。调度任务会执行ObserveOnSubscriber的call方法,这样就实现了线程切换。call方法内部就是让传进来的child subscriber接收上游的事件，到这里我们可以得出结论ObserveOn 其实只对ObserveOn调用之后的操作生效。举个例子(kotlin编写)：</p>\n<p><pre><code><br> val ob = Observable.create(Observable.OnSubscribe<int> { t -&gt;<br>            t.onNext(1)<br>            t.onCompleted()<br>        })<br> ob.observeOn(Schedulers.io())<br>                .map { it-&gt;it.toString() }<br>                .observeOn(Schedulers.computation())<br>                .map { it-&gt; it.toCharArray() }<br>                .subscribe {  }<br></int></code></pre><br>上游简单发射一个Int数字,第一次调用ObserveOn 那么对于这第一个ObserveOn的操作符而言call方法传入的subscriber是下游map 生成的MapSubscriber,所以第一个map的操作发生在io线程，当同理第二个map 也会发生在computation线程。其实到这里可以总结出来ObserveOn方法的作用其实就是将之后的操作调度ObserveOn指定的线程中执行。</p>\n<p>3)<br>call 方法实现：</p>\n<p><pre><code><br>     @Override<br>        public void call() {<br>            long missed = 1L;//能进入到call这个方法，说明进入前，说明只有一次调度（就是本次调度）<br>            long currentEmission = emitted;<br>            final Queue<object> q = this.queue;<br>            final Subscriber&lt;? super T&gt; localChild = this.child;<br>            for (;;) {<br>                long requestAmount = requested.get();//获取下游的请求数量</object></code></pre></p>\n<pre><code>            while (requestAmount != currentEmission) { //直到把下游的请求都发射完为止\n                boolean done = finished;\n                Object v = q.poll();\n                boolean empty = v == null;\n\n                if (checkTerminated(done, empty, localChild, q)) { //是否已经结束\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                localChild.onNext(NotificationLite.&lt;T&gt;getValue(v));\n\n                currentEmission++;\n                if (currentEmission == limit) {\n                    requestAmount = BackpressureUtils.produced(requested, currentEmission);\n                    request(currentEmission);\n                    currentEmission = 0L;\n                }\n            }\n\n            if (requestAmount == currentEmission) {\n                if (checkTerminated(finished, q.isEmpty(), localChild, q)) {\n                    return;\n                }\n            }\n\n            emitted = currentEmission;\n            missed = counter.addAndGet(-missed);//如果不是0，其他线程可能也在请求，导致新的多个调度任务，那么还得继续处理，记录调度任务数量，进入下次循环，直到任务全部处理完为止\n            if (missed == 0L) {\n                break;\n            }\n        }\n    }\n</code></pre><p><br>大致逻辑梳理一下：</p>\n<ul>\n<li>首先声明了一个missed  = 1L记录需要调度的数量以及一个currentMission记录已经发射的事件数量；</li>\n<li>一个for循环嵌套了一个while循环：<ol>\n<li>while循环的作用就是发射事件，发射事件之前检查是否已经结束，结束的原因可能是已经结束了或者发生错误</li>\n<li>每发射一个事件就计数</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"subscribeOn\"><a href=\"#subscribeOn\" class=\"headerlink\" title=\"subscribeOn\"></a>subscribeOn</h3><p>通过subscribeOn 和 ObserveOn 两个方法rxjava可以灵活的指定任务执行的线程和指定收到事件的线程<br>直接看源码：</p>\n<pre><code class=\"java\">        public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler, boolean requestOn) {\n        if (this instanceof ScalarSynchronousObservable) {\n            return ((ScalarSynchronousObservable&lt;T&gt;)this).scalarScheduleOn(scheduler);\n        }\n        return unsafeCreate(new OperatorSubscribeOn&lt;T&gt;(this, scheduler, requestOn));\n    }\n</code></pre>\n<p>使用了lift操作，看一下OperatorSubscribeOn这个操作符,重点是call方法：</p>\n<pre><code class=\"java\">   @Override\n    public void call(final Subscriber&lt;? super T&gt; subscriber) {\n        final Worker inner = scheduler.createWorker();\n\n        SubscribeOnSubscriber&lt;T&gt; parent = new SubscribeOnSubscriber&lt;T&gt;(subscriber, requestOn, inner, source);\n        subscriber.add(parent);\n        subscriber.add(inner);\n\n        inner.schedule(parent);\n    }\n</code></pre>\n<p>这个SubscribeOnSubscriber类型的parent实际是个Action0,然后inner.schedule(parent)直接让这个任务在指定的线程执行了，<br>然后事件到来的时候，简单调用这个call方法参数传来的Subscriber 调用一下onNext onError onComplete就完了。嗯，其实也很简单，一下就懂了，就是把source Observable的订阅放到一个指定的Scheduler中执行，然后事件也会在所在的Scheduler中发出来。其实可以得出一个结论：无论subscribeOn调用多少次，调度都只会在第一次调用subscribeOn指定的线程中执行。比如一个Observable 调用了subscribeOn(Schedulers.io).subscribeOn(Schedulers.compution()),其实这样做的效果可以拆分看，第一次调用subscribeOn把调度指定在io线程，那么后面的调度就是想把  ‘把调度指定在io’ 的调度指定在computation线程，换个说法，我有一个操作是要指定调度在io线程 ，只不过我把这个操作放在了computation线程去执行而已，有种脱了什么放什么的多余+_+(实在找不出什么恰当的比喻了)。</p>\n<p>我们以一个小栗子来看一下整个流程：</p>\n<pre><code>\n val observable = Observable.create(Observable.OnSubscribe<int> { subscriber ->\n            Log.i(\"source===>\", Thread.currentThread().name)\n            for (i in 0..0) {\n                subscriber.onNext(i)\n            }\n\n            subscriber.onCompleted()\n        })\n val map = observable\n                .observeOn(Schedulers.computation())\n                .subscribeOn(Schedulers.newThread())\n                .map(Func1<int, string=\"\"> { integer ->\n                    Log.i(\"map===>\", Thread.currentThread().name)\n                    integer!!.toString()\n                })\n\n\n map.observeOn(Schedulers.newThread())\n                .subscribe(Action1<string> { s -> Log.i(\"onNext===>\", Thread.currentThread().name) })\n</string></int,></int></code></pre>\n\n<p>首先创建一个简单的发射一个数字的Observable，然后调用map操作转换成string 然后打印出来。注意subscribeOn 和ObserveOn的位置，我们是先observeOn 然后subscribeOn<br>打印结果：</p>\n<pre>\n    <code>\n    source===>: RxNewThreadScheduler-2\n    map===>: RxComputationScheduler-1\n    onNext===>: RxNewThreadScheduler-1\n    </code>\n</pre>\n\n<p>可以看到最后的onNext 调用并没有像预想的那样 发生在observeOn指定的computation 线程中，而是subscribeOn指定的创建的新线程中。<br>其实结合前面的subscribeOn的源码分析可以知道，调用subscribeOn之后的所有操作其实都会在subscribeOn 指定的线程中，这也是为什么map 和subscribe 两个操作都发生在RxNewThreadScheduler的原因。</p>\n<h3 id=\"observeOn\"><a href=\"#observeOn\" class=\"headerlink\" title=\"observeOn\"></a>observeOn</h3><p>ObserveOn和SubscribeOn不太一样，subscribeOn方法是放在哪儿都可以调用多次也只有第一次调用的效果。ObserveOn也可以多次调用，但是每次都会生效，要理解清楚还得看代码，直接进入OperatorObserveOn操作符的call方法</p>\n<pre><code>\n       @Override\n    public Subscriber<? super T> call(Subscriber<? super T> child) {\n        if (scheduler instanceof ImmediateScheduler) {\n            // avoid overhead, execute directly\n            return child;\n        } else if (scheduler instanceof TrampolineScheduler) {\n            // avoid overhead, execute directly\n            return child;\n        } else {\n            ObserveOnSubscriber<t> parent = new ObserveOnSubscriber<t>(scheduler, child, delayError, bufferSize);\n            parent.init();\n            return parent;\n        }\n    }\n\n</t></t></code></pre>\n不同的是 observeOn 的call方法是有返回值的，对于很多call方法有返回值的操作符，其实都可以认作是代理模式。包装了下游的subscriber，生成新的subscriber,然后让这个新的subscriber订阅上游observable,自己内部先处理，然后转发给下游的subscriber,达到代理的目的。我们再看一下这个ObserveOnSubscriber:\n\n1)\n<pre><code>\n         @Override\n        public void onNext(final T t) {\n            if (isUnsubscribed() || finished) {\n                return;\n            }\n            if (!queue.offer(NotificationLite.next(t))) {\n                onError(new MissingBackpressureException());\n                return;\n            }\n            schedule();\n        }\n</code></pre>\n\n<p>当接收到上游发来的事件时，调用onNext,然后先存入队列，存入成功，则会执行schedule方法进行调度，schedule方法了解一下：</p>\n<p>2)</p>\n<p><pre><code><br>            protected void schedule() {<br>            if (counter.getAndIncrement() == 0) {<br>                recursiveScheduler.schedule(this);<br>            }<br>        }<br></code></pre><br>非常简单的一句，如果当前没有任务（发射事件）调度，那么开始，并且把计数器加一，这里实际是对多线程的考虑，同一时刻只能有一个线程进行调度 。结合上面的onNext方法一起看就是——————如果有任务，先放入队列，放不进去就调用onError，不然就调度，而调度的话又必须满足当前没有其他线程在调度。调度任务会执行ObserveOnSubscriber的call方法,这样就实现了线程切换。call方法内部就是让传进来的child subscriber接收上游的事件，到这里我们可以得出结论ObserveOn 其实只对ObserveOn调用之后的操作生效。举个例子(kotlin编写)：</p>\n<p><pre><code><br> val ob = Observable.create(Observable.OnSubscribe<int> { t -&gt;<br>            t.onNext(1)<br>            t.onCompleted()<br>        })<br> ob.observeOn(Schedulers.io())<br>                .map { it-&gt;it.toString() }<br>                .observeOn(Schedulers.computation())<br>                .map { it-&gt; it.toCharArray() }<br>                .subscribe {  }<br></int></code></pre><br>上游简单发射一个Int数字,第一次调用ObserveOn 那么对于这第一个ObserveOn的操作符而言call方法传入的subscriber是下游map 生成的MapSubscriber,所以第一个map的操作发生在io线程，当同理第二个map 也会发生在computation线程。其实到这里可以总结出来ObserveOn方法的作用其实就是将之后的操作调度ObserveOn指定的线程中执行。</p>\n<p>3)<br>call 方法实现：</p>\n<p><pre><code><br>     @Override<br>        public void call() {<br>            long missed = 1L;//能进入到call这个方法，说明进入前，说明只有一次调度（就是本次调度）<br>            long currentEmission = emitted;<br>            final Queue<object> q = this.queue;<br>            final Subscriber&lt;? super T&gt; localChild = this.child;<br>            for (;;) {<br>                long requestAmount = requested.get();//获取下游的请求数量</object></code></pre></p>\n<pre><code>            while (requestAmount != currentEmission) { //直到把下游的请求都发射完为止\n                boolean done = finished;\n                Object v = q.poll();\n                boolean empty = v == null;\n\n                if (checkTerminated(done, empty, localChild, q)) { //是否已经结束\n                    return;\n                }\n\n                if (empty) {\n                    break;\n                }\n\n                localChild.onNext(NotificationLite.&lt;T&gt;getValue(v));\n\n                currentEmission++;\n                if (currentEmission == limit) {\n                    requestAmount = BackpressureUtils.produced(requested, currentEmission);\n                    request(currentEmission);\n                    currentEmission = 0L;\n                }\n            }\n\n            if (requestAmount == currentEmission) {\n                if (checkTerminated(finished, q.isEmpty(), localChild, q)) {\n                    return;\n                }\n            }\n\n            emitted = currentEmission;\n            missed = counter.addAndGet(-missed);//如果不是0，其他线程可能也在请求，导致新的多个调度任务，那么还得继续处理，记录调度任务数量，进入下次循环，直到任务全部处理完为止\n            if (missed == 0L) {\n                break;\n            }\n        }\n    }\n</code></pre><p><br>大致逻辑梳理一下：</p>\n<ul>\n<li>首先声明了一个missed  = 1L记录需要调度的数量以及一个currentMission记录已经发射的事件数量；</li>\n<li>一个for循环嵌套了一个while循环：<ol>\n<li>while循环的作用就是发射事件，发射事件之前检查是否已经结束，结束的原因可能是已经结束了或者发生错误</li>\n<li>每发射一个事件就计数</li>\n</ol>\n</li>\n</ul>\n"},{"title":"RxJava中的 Producer","date":"2018-08-15T07:04:18.000Z","_content":"本文基于 rxjava 1.3.8\n\n### 背压\nProducer本身是作为沟通上下游的一个接口，只有一个方法：\n```java\nvoid request(long n);\n```\n如果传入的n是Long.MAX_VALUE，表明是放弃背压，上游会有多少就生产多少。比如range()操作符内部的RangeProducer，如果遇到n = Long.MAX_VALUE,直接用fastPath方法，一口气把事件全部发射出去，反之是请求多少生产多少。\n\n但是平时我们调用range操作符，好像都没有考虑过什么背压，都是这样：\n```java\n            Observable.range(1, 2)\n                .subscribe(new Subscriber<Integer>() {\n                    @Override\n                    public void onCompleted() {\n                        \n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n\n                    }\n\n                    @Override\n                    public void onNext(Integer integer) {\n                            System.out.println(integer)\n                    }\n                });\n```\n也同样是一口气把数据全部给我了，似乎也没有调用request(Long.MAX_VALUE)\n\n### Range操作符内部\n进入到range操作符，实际内部只有这么一句：\n```java\n    public void call(final Subscriber<? super Integer> childSubscriber) {\n        childSubscriber.setProducer(new RangeProducer(childSubscriber, startIndex, endIndex));\n    }\n```\n\nRangeProducer这个Producer实际上就是一个fastPath和slowPath，分别对应没有背压和有背压的情况\n\n那么实际childSubscriber是下游的subscriber，也就是我们调用subscriber的时候new 出来的那个,那么问题来了，到这里都没有什么问题，为何range操作符还是会一口气把数据全部发射出去呢？这里setProducer我们漏掉了。\n看一下setProducer做了什么。setProducer方法是subscriber的方法，这里很好理解，下游的subscriber需要数据属于消费者，消费者需要通知生产者，所以给消费者一个方法设置合适（不同场景下有不同的生产者）的生产者。\n\n```java\n        public void setProducer(Producer p) {\n        long toRequest;\n        boolean passToSubscriber = false;\n        synchronized (this) {\n            toRequest = requested;\n            producer = p;\n            if (subscriber != null) {\n                // middle operator ... we pass through unless a request has been made\n                if (toRequest == NOT_SET) {\n                    // we pass through to the next producer as nothing has been requested\n                    passToSubscriber = true;\n                }\n            }\n        }\n        // do after releasing lock\n        if (passToSubscriber) {\n            subscriber.setProducer(producer);\n        } else {\n            // we execute the request with whatever has been requested (or Long.MAX_VALUE)\n            if (toRequest == NOT_SET) {\n                producer.request(Long.MAX_VALUE);\n            } else {\n                producer.request(toRequest);\n            }\n        }\n    }\n```\n官方的注释其实已经是对这段代码的最简洁的解释了：如果Subscriber是通过Subscriber(Subscriber)或者Subscriber(Subscriber, boolean)方法设置了subscriber，那么就会对这个subscriber调用setProducer，反之如果没有设置subscriber并且已经有请求到来，那么就会直接调用producer.request(n)，其中n是已经累积的请求。\n\n当然官方解释遗漏一个情况，那就是当没有设置subscriber，而且也没有请求到来的时候，那么就会调用producer.request(Long.MAX_VALUE),也就是让上游有多少就生产多少。\n\n当然为了更容易明白这个方法的作用，总结一下：如果Subscriber自身设置了内部Subcriber那么会把这个producer设置给这个内部Subscriber;不然就请求上游（request(n))开始生产积累的数据,没有累积请求那就一口气全部生产完。有些时候我们要深刻理解前面半句，因为setProducer可能会形成很长的调用链:)。\n\n回到最开始的具体的例子range(1,2).subscribe(subscriber),实际range操作内部那个childSubscriber 是我们new的那个subscriber（准确说是包装了之后的SafeSubscriber） 调用setProducer设置了RangeProducer。\n由于我们new 的Subscriber是没有设置内置的subscriber的，那么最后实际会走到 “producer.request(Long.MAX_VALUE);”那句来，导致的结果就是RangeProducer 调用fastPath不考虑背压一口气全部生产完数据。\n\n### 多个操作符的情况\n这里我们有一个自定义的操作符，目的是过滤掉奇数，只要偶数：\n```java\nEvenFilter implements Observable.Operator<Integer, Integer> {\n        public Subscriber<? super Integer> call(final Subscriber<? super Integer> child) {\n\n            return new Subscriber<Integer>(child) {\n\n                public void onNext(Integer t) {\n                    if ((t & 1) == 0) {\n                        child.onNext(t);\n                    }\n                }\n\n\n                public void onError(Throwable e) {\n                    child.onError(e);\n                }\n\n\n                public void onCompleted() {\n                    child.onCompleted();\n                }\n            };\n        }\n    }\n```\n操作符本身很简单，在onNext那里简单过滤了一下，看上去很完美。我们再写个例子：\n\n```java\n     Observable.range(1, 2)\n                .lift(new EvenFilter())\n                .subscribe(new Subscriber<Integer>() {\n                    @Override\n                    public void onCompleted() {\n\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n\n                    }\n\n                    @Override\n                    public void onNext(Integer integer) {\n                        System.out.println(integer);\n                    }\n                });\n```\n逻辑也很简单，最后打印出了 2，符合预期。我们再加上一个操作符take()\n```java\n     Observable.range(1, 2)\n                .lift(new EvenFilter())\n                .take(1).subscribe(new Action1<Integer>() {\n                    @Override\n                    public void call(Integer integer) {\n                        System.out.println(integer);\n                    }\n                })\n```\n然后就出问题了，什么都没有打印。有点反常，因为加上了take(1),逻辑上是没有改变的，应该会输出一样的结果。 一直到lift(new EvenFilter())操作都是可以正常往下游发射数据的，那么为什么只是加入了take会变得奇怪导致没有数据打印。很明显问题出在take操作符上。\n\n分析，必须给他分析————range操作符 childSubscriber.setProducer那句实际上childSubscriber是我们下游EventFilter call方法返回的Subscriber，由于EvenFilter 返回的这个Subscriber设置了child这个Subscriber，所以实际上还会调用这个child的setProducer\n把RangeProuducer设置给这个child。而这个child实际又是下游take操作符内部返回的Subscriber ，take操作符返回的这个Subscriber的setProducer方法是这样的：\n```java\n     public void setProducer(final Producer producer) {\n                child.setProducer(new Producer() {\n\n                    // keeps track of requests up to maximum of `limit`\n                    final AtomicLong requested = new AtomicLong(0);\n\n                    @Override\n                    public void request(long n) {\n                        if (n > 0 && !completed) {\n                            // because requests may happen concurrently use a CAS loop to\n                            // ensure we only request as much as needed, no more no less\n                            while (true) {\n                                long r = requested.get();\n                                long c = Math.min(n, limit - r);\n                                if (c == 0) {\n                                    break;\n                                } else if (requested.compareAndSet(r, r + c)) {\n                                    producer.request(c);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n```\n这里实际上是调用了下游的child Subscriber(就是我们最后new的Subscriber)setProducer，根据前面的总结，最后会调用这里这个匿名Producer的request方法，并且n = Long.MAX_VALUE,最后会走到producer.request(c)这句，而且c = limit,啊哈！！！！，因为我们是take(1) 所以limit = 1，上游的RangeProducer 生产一个数据之后就没了，没了！导致2不会被发射出来！\n\n做一整个问题就出在take操作符这里，因为take认为自己只要一个数据，所以只向上游请求了一个数据，这其实非常符合take的逻辑，然而它的上游，可以认为此时take的上游是我们的EvenFilter，EvenFilter自身数据来自range，而不是对range发来的数据做缓存，然后根据下游的请求来发射偶数2。所以这里与其说是take的错误，不如说是我们的Operator实现不够完美。那么我们这里其实有三种解决办法，一种是简单的修改EvenFilter\n- request(1)\n```java\n    public void onNext(Integer t) {\n                    if ((t & 1) == 0) {\n                        child.onNext(t);\n                    }else request(1)\n                }\n```\n这样达到的效果是，如果符合要求，发往下游，不然请求下一个数据，这样所有的数据都会被发射出来\n\n- 使用filter操作符\n或者是使用rxjava提供的操作符，因为我们的EvenFilter实在有点多次一举，只是简单的过滤偶数，可以使用filter操作符：\n```java\n    Observable.range(1, 2)\n                .filter(new Func1<Integer, Boolean>() {\n                    @Override\n                    public Boolean call(Integer integer) {\n                        return (integer & 1) == 0;\n                    }\n                })\n                .take(1)\n```\n- 使用其余的构造方法返回Subscriber\n由于我们的EvenFilter返回的Subscriber使用的是Subscriber(subscriber)构造方法，所以使得 会调用child.setProducer，这里我们使用空的构造方法：\n\n\n```java\n return new Subscriber<Integer>(/*child*/) {\n\n                public void onNext(Integer t) {\n                    System.out.println(\"inner: \" + t);\n                    if ((t & 1) == 0) {\n                        child.onNext(t);\n                    }\n                }\n\n\n                public void onError(Throwable e) {\n                    child.onError(e);\n                }\n\n\n                public void onCompleted() {\n                    child.onCompleted();\n                }\n            };\n```\n\n为什么这样可以呢，因为这样就不会调用child的setProducer,而是返回的这个Subscriber的setProducer，根据前面总结的，由于这个Subscriber没有内置的Subscriber,最后会导致调用RangeProducer的 request(Long.MAX_VALUE),一口气生产全部的数据\n\n其实这个例子暗含一个教训，我们在实现自己的操作符的时候尽量不要去使用Subscriber(subscriber)这个构造方法返回Subscriber给上游，因为导致的问题是我们操作符自己被跨越了，下游和上游单独在联系，跨越了操作符自己，导致有些问题不能按照上游到下游一条连贯的线去思考，容易出现一些反常识的bug。","source":"_posts/RxJava中的-Producer.md","raw":"---\ntitle: RxJava中的 Producer\ndate: 2018-08-15 15:04:18\ntags: \n    - RxJava\n    - Producer \n    - 背压\n---\n本文基于 rxjava 1.3.8\n\n### 背压\nProducer本身是作为沟通上下游的一个接口，只有一个方法：\n```java\nvoid request(long n);\n```\n如果传入的n是Long.MAX_VALUE，表明是放弃背压，上游会有多少就生产多少。比如range()操作符内部的RangeProducer，如果遇到n = Long.MAX_VALUE,直接用fastPath方法，一口气把事件全部发射出去，反之是请求多少生产多少。\n\n但是平时我们调用range操作符，好像都没有考虑过什么背压，都是这样：\n```java\n            Observable.range(1, 2)\n                .subscribe(new Subscriber<Integer>() {\n                    @Override\n                    public void onCompleted() {\n                        \n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n\n                    }\n\n                    @Override\n                    public void onNext(Integer integer) {\n                            System.out.println(integer)\n                    }\n                });\n```\n也同样是一口气把数据全部给我了，似乎也没有调用request(Long.MAX_VALUE)\n\n### Range操作符内部\n进入到range操作符，实际内部只有这么一句：\n```java\n    public void call(final Subscriber<? super Integer> childSubscriber) {\n        childSubscriber.setProducer(new RangeProducer(childSubscriber, startIndex, endIndex));\n    }\n```\n\nRangeProducer这个Producer实际上就是一个fastPath和slowPath，分别对应没有背压和有背压的情况\n\n那么实际childSubscriber是下游的subscriber，也就是我们调用subscriber的时候new 出来的那个,那么问题来了，到这里都没有什么问题，为何range操作符还是会一口气把数据全部发射出去呢？这里setProducer我们漏掉了。\n看一下setProducer做了什么。setProducer方法是subscriber的方法，这里很好理解，下游的subscriber需要数据属于消费者，消费者需要通知生产者，所以给消费者一个方法设置合适（不同场景下有不同的生产者）的生产者。\n\n```java\n        public void setProducer(Producer p) {\n        long toRequest;\n        boolean passToSubscriber = false;\n        synchronized (this) {\n            toRequest = requested;\n            producer = p;\n            if (subscriber != null) {\n                // middle operator ... we pass through unless a request has been made\n                if (toRequest == NOT_SET) {\n                    // we pass through to the next producer as nothing has been requested\n                    passToSubscriber = true;\n                }\n            }\n        }\n        // do after releasing lock\n        if (passToSubscriber) {\n            subscriber.setProducer(producer);\n        } else {\n            // we execute the request with whatever has been requested (or Long.MAX_VALUE)\n            if (toRequest == NOT_SET) {\n                producer.request(Long.MAX_VALUE);\n            } else {\n                producer.request(toRequest);\n            }\n        }\n    }\n```\n官方的注释其实已经是对这段代码的最简洁的解释了：如果Subscriber是通过Subscriber(Subscriber)或者Subscriber(Subscriber, boolean)方法设置了subscriber，那么就会对这个subscriber调用setProducer，反之如果没有设置subscriber并且已经有请求到来，那么就会直接调用producer.request(n)，其中n是已经累积的请求。\n\n当然官方解释遗漏一个情况，那就是当没有设置subscriber，而且也没有请求到来的时候，那么就会调用producer.request(Long.MAX_VALUE),也就是让上游有多少就生产多少。\n\n当然为了更容易明白这个方法的作用，总结一下：如果Subscriber自身设置了内部Subcriber那么会把这个producer设置给这个内部Subscriber;不然就请求上游（request(n))开始生产积累的数据,没有累积请求那就一口气全部生产完。有些时候我们要深刻理解前面半句，因为setProducer可能会形成很长的调用链:)。\n\n回到最开始的具体的例子range(1,2).subscribe(subscriber),实际range操作内部那个childSubscriber 是我们new的那个subscriber（准确说是包装了之后的SafeSubscriber） 调用setProducer设置了RangeProducer。\n由于我们new 的Subscriber是没有设置内置的subscriber的，那么最后实际会走到 “producer.request(Long.MAX_VALUE);”那句来，导致的结果就是RangeProducer 调用fastPath不考虑背压一口气全部生产完数据。\n\n### 多个操作符的情况\n这里我们有一个自定义的操作符，目的是过滤掉奇数，只要偶数：\n```java\nEvenFilter implements Observable.Operator<Integer, Integer> {\n        public Subscriber<? super Integer> call(final Subscriber<? super Integer> child) {\n\n            return new Subscriber<Integer>(child) {\n\n                public void onNext(Integer t) {\n                    if ((t & 1) == 0) {\n                        child.onNext(t);\n                    }\n                }\n\n\n                public void onError(Throwable e) {\n                    child.onError(e);\n                }\n\n\n                public void onCompleted() {\n                    child.onCompleted();\n                }\n            };\n        }\n    }\n```\n操作符本身很简单，在onNext那里简单过滤了一下，看上去很完美。我们再写个例子：\n\n```java\n     Observable.range(1, 2)\n                .lift(new EvenFilter())\n                .subscribe(new Subscriber<Integer>() {\n                    @Override\n                    public void onCompleted() {\n\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n\n                    }\n\n                    @Override\n                    public void onNext(Integer integer) {\n                        System.out.println(integer);\n                    }\n                });\n```\n逻辑也很简单，最后打印出了 2，符合预期。我们再加上一个操作符take()\n```java\n     Observable.range(1, 2)\n                .lift(new EvenFilter())\n                .take(1).subscribe(new Action1<Integer>() {\n                    @Override\n                    public void call(Integer integer) {\n                        System.out.println(integer);\n                    }\n                })\n```\n然后就出问题了，什么都没有打印。有点反常，因为加上了take(1),逻辑上是没有改变的，应该会输出一样的结果。 一直到lift(new EvenFilter())操作都是可以正常往下游发射数据的，那么为什么只是加入了take会变得奇怪导致没有数据打印。很明显问题出在take操作符上。\n\n分析，必须给他分析————range操作符 childSubscriber.setProducer那句实际上childSubscriber是我们下游EventFilter call方法返回的Subscriber，由于EvenFilter 返回的这个Subscriber设置了child这个Subscriber，所以实际上还会调用这个child的setProducer\n把RangeProuducer设置给这个child。而这个child实际又是下游take操作符内部返回的Subscriber ，take操作符返回的这个Subscriber的setProducer方法是这样的：\n```java\n     public void setProducer(final Producer producer) {\n                child.setProducer(new Producer() {\n\n                    // keeps track of requests up to maximum of `limit`\n                    final AtomicLong requested = new AtomicLong(0);\n\n                    @Override\n                    public void request(long n) {\n                        if (n > 0 && !completed) {\n                            // because requests may happen concurrently use a CAS loop to\n                            // ensure we only request as much as needed, no more no less\n                            while (true) {\n                                long r = requested.get();\n                                long c = Math.min(n, limit - r);\n                                if (c == 0) {\n                                    break;\n                                } else if (requested.compareAndSet(r, r + c)) {\n                                    producer.request(c);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n```\n这里实际上是调用了下游的child Subscriber(就是我们最后new的Subscriber)setProducer，根据前面的总结，最后会调用这里这个匿名Producer的request方法，并且n = Long.MAX_VALUE,最后会走到producer.request(c)这句，而且c = limit,啊哈！！！！，因为我们是take(1) 所以limit = 1，上游的RangeProducer 生产一个数据之后就没了，没了！导致2不会被发射出来！\n\n做一整个问题就出在take操作符这里，因为take认为自己只要一个数据，所以只向上游请求了一个数据，这其实非常符合take的逻辑，然而它的上游，可以认为此时take的上游是我们的EvenFilter，EvenFilter自身数据来自range，而不是对range发来的数据做缓存，然后根据下游的请求来发射偶数2。所以这里与其说是take的错误，不如说是我们的Operator实现不够完美。那么我们这里其实有三种解决办法，一种是简单的修改EvenFilter\n- request(1)\n```java\n    public void onNext(Integer t) {\n                    if ((t & 1) == 0) {\n                        child.onNext(t);\n                    }else request(1)\n                }\n```\n这样达到的效果是，如果符合要求，发往下游，不然请求下一个数据，这样所有的数据都会被发射出来\n\n- 使用filter操作符\n或者是使用rxjava提供的操作符，因为我们的EvenFilter实在有点多次一举，只是简单的过滤偶数，可以使用filter操作符：\n```java\n    Observable.range(1, 2)\n                .filter(new Func1<Integer, Boolean>() {\n                    @Override\n                    public Boolean call(Integer integer) {\n                        return (integer & 1) == 0;\n                    }\n                })\n                .take(1)\n```\n- 使用其余的构造方法返回Subscriber\n由于我们的EvenFilter返回的Subscriber使用的是Subscriber(subscriber)构造方法，所以使得 会调用child.setProducer，这里我们使用空的构造方法：\n\n\n```java\n return new Subscriber<Integer>(/*child*/) {\n\n                public void onNext(Integer t) {\n                    System.out.println(\"inner: \" + t);\n                    if ((t & 1) == 0) {\n                        child.onNext(t);\n                    }\n                }\n\n\n                public void onError(Throwable e) {\n                    child.onError(e);\n                }\n\n\n                public void onCompleted() {\n                    child.onCompleted();\n                }\n            };\n```\n\n为什么这样可以呢，因为这样就不会调用child的setProducer,而是返回的这个Subscriber的setProducer，根据前面总结的，由于这个Subscriber没有内置的Subscriber,最后会导致调用RangeProducer的 request(Long.MAX_VALUE),一口气生产全部的数据\n\n其实这个例子暗含一个教训，我们在实现自己的操作符的时候尽量不要去使用Subscriber(subscriber)这个构造方法返回Subscriber给上游，因为导致的问题是我们操作符自己被跨越了，下游和上游单独在联系，跨越了操作符自己，导致有些问题不能按照上游到下游一条连贯的线去思考，容易出现一些反常识的bug。","slug":"RxJava中的-Producer","published":1,"updated":"2018-08-20T03:52:13.053Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl1qvapi000by472hx154hys","content":"<p>本文基于 rxjava 1.3.8</p>\n<h3 id=\"背压\"><a href=\"#背压\" class=\"headerlink\" title=\"背压\"></a>背压</h3><p>Producer本身是作为沟通上下游的一个接口，只有一个方法：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">void</span> <span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>如果传入的n是Long.MAX_VALUE，表明是放弃背压，上游会有多少就生产多少。比如range()操作符内部的RangeProducer，如果遇到n = Long.MAX_VALUE,直接用fastPath方法，一口气把事件全部发射出去，反之是请求多少生产多少。</p>\n<p>但是平时我们调用range操作符，好像都没有考虑过什么背压，都是这样：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">            Observable<span class=\"token punctuation\">.</span><span class=\"token function\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Subscriber</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token annotation punctuation\">@Override</span>\n                    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onCompleted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n                    <span class=\"token punctuation\">}</span>\n\n                    <span class=\"token annotation punctuation\">@Override</span>\n                    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>Throwable e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n                    <span class=\"token punctuation\">}</span>\n\n                    <span class=\"token annotation punctuation\">@Override</span>\n                    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span>Integer integer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>也同样是一口气把数据全部给我了，似乎也没有调用request(Long.MAX_VALUE)</p>\n<h3 id=\"Range操作符内部\"><a href=\"#Range操作符内部\" class=\"headerlink\" title=\"Range操作符内部\"></a>Range操作符内部</h3><p>进入到range操作符，实际内部只有这么一句：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> Subscriber<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> Integer<span class=\"token operator\">></span> childSubscriber<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        childSubscriber<span class=\"token punctuation\">.</span><span class=\"token function\">setProducer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">RangeProducer</span><span class=\"token punctuation\">(</span>childSubscriber<span class=\"token punctuation\">,</span> startIndex<span class=\"token punctuation\">,</span> endIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>RangeProducer这个Producer实际上就是一个fastPath和slowPath，分别对应没有背压和有背压的情况</p>\n<p>那么实际childSubscriber是下游的subscriber，也就是我们调用subscriber的时候new 出来的那个,那么问题来了，到这里都没有什么问题，为何range操作符还是会一口气把数据全部发射出去呢？这里setProducer我们漏掉了。<br>看一下setProducer做了什么。setProducer方法是subscriber的方法，这里很好理解，下游的subscriber需要数据属于消费者，消费者需要通知生产者，所以给消费者一个方法设置合适（不同场景下有不同的生产者）的生产者。</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setProducer</span><span class=\"token punctuation\">(</span>Producer p<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">long</span> toRequest<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">boolean</span> passToSubscriber <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            toRequest <span class=\"token operator\">=</span> requested<span class=\"token punctuation\">;</span>\n            producer <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>subscriber <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// middle operator ... we pass through unless a request has been made</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>toRequest <span class=\"token operator\">==</span> NOT_SET<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// we pass through to the next producer as nothing has been requested</span>\n                    passToSubscriber <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// do after releasing lock</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>passToSubscriber<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            subscriber<span class=\"token punctuation\">.</span><span class=\"token function\">setProducer</span><span class=\"token punctuation\">(</span>producer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// we execute the request with whatever has been requested (or Long.MAX_VALUE)</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>toRequest <span class=\"token operator\">==</span> NOT_SET<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                producer<span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span>Long<span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                producer<span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span>toRequest<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>官方的注释其实已经是对这段代码的最简洁的解释了：如果Subscriber是通过Subscriber(Subscriber)或者Subscriber(Subscriber, boolean)方法设置了subscriber，那么就会对这个subscriber调用setProducer，反之如果没有设置subscriber并且已经有请求到来，那么就会直接调用producer.request(n)，其中n是已经累积的请求。</p>\n<p>当然官方解释遗漏一个情况，那就是当没有设置subscriber，而且也没有请求到来的时候，那么就会调用producer.request(Long.MAX_VALUE),也就是让上游有多少就生产多少。</p>\n<p>当然为了更容易明白这个方法的作用，总结一下：如果Subscriber自身设置了内部Subcriber那么会把这个producer设置给这个内部Subscriber;不然就请求上游（request(n))开始生产积累的数据,没有累积请求那就一口气全部生产完。有些时候我们要深刻理解前面半句，因为setProducer可能会形成很长的调用链:)。</p>\n<p>回到最开始的具体的例子range(1,2).subscribe(subscriber),实际range操作内部那个childSubscriber 是我们new的那个subscriber（准确说是包装了之后的SafeSubscriber） 调用setProducer设置了RangeProducer。<br>由于我们new 的Subscriber是没有设置内置的subscriber的，那么最后实际会走到 “producer.request(Long.MAX_VALUE);”那句来，导致的结果就是RangeProducer 调用fastPath不考虑背压一口气全部生产完数据。</p>\n<h3 id=\"多个操作符的情况\"><a href=\"#多个操作符的情况\" class=\"headerlink\" title=\"多个操作符的情况\"></a>多个操作符的情况</h3><p>这里我们有一个自定义的操作符，目的是过滤掉奇数，只要偶数：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">EvenFilter <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Observable<span class=\"token punctuation\">.</span>Operator</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">public</span> Subscriber<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> Integer<span class=\"token operator\">></span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> Subscriber<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> Integer<span class=\"token operator\">></span> child<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Subscriber</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n                <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span>Integer t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        child<span class=\"token punctuation\">.</span><span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n\n\n                <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>Throwable e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    child<span class=\"token punctuation\">.</span><span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n\n\n                <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onCompleted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    child<span class=\"token punctuation\">.</span><span class=\"token function\">onCompleted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>操作符本身很简单，在onNext那里简单过滤了一下，看上去很完美。我们再写个例子：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">     Observable<span class=\"token punctuation\">.</span><span class=\"token function\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">lift</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">EvenFilter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Subscriber</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token annotation punctuation\">@Override</span>\n                    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onCompleted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n                    <span class=\"token punctuation\">}</span>\n\n                    <span class=\"token annotation punctuation\">@Override</span>\n                    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>Throwable e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n                    <span class=\"token punctuation\">}</span>\n\n                    <span class=\"token annotation punctuation\">@Override</span>\n                    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span>Integer integer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>逻辑也很简单，最后打印出了 2，符合预期。我们再加上一个操作符take()</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">     Observable<span class=\"token punctuation\">.</span><span class=\"token function\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">lift</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">EvenFilter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Action1</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token annotation punctuation\">@Override</span>\n                    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>Integer integer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>然后就出问题了，什么都没有打印。有点反常，因为加上了take(1),逻辑上是没有改变的，应该会输出一样的结果。 一直到lift(new EvenFilter())操作都是可以正常往下游发射数据的，那么为什么只是加入了take会变得奇怪导致没有数据打印。很明显问题出在take操作符上。</p>\n<p>分析，必须给他分析————range操作符 childSubscriber.setProducer那句实际上childSubscriber是我们下游EventFilter call方法返回的Subscriber，由于EvenFilter 返回的这个Subscriber设置了child这个Subscriber，所以实际上还会调用这个child的setProducer<br>把RangeProuducer设置给这个child。而这个child实际又是下游take操作符内部返回的Subscriber ，take操作符返回的这个Subscriber的setProducer方法是这样的：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">     <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setProducer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> Producer producer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                child<span class=\"token punctuation\">.</span><span class=\"token function\">setProducer</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Producer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n                    <span class=\"token comment\" spellcheck=\"true\">// keeps track of requests up to maximum of `limit`</span>\n                    <span class=\"token keyword\">final</span> AtomicLong requested <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicLong</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                    <span class=\"token annotation punctuation\">@Override</span>\n                    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>completed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                            <span class=\"token comment\" spellcheck=\"true\">// because requests may happen concurrently use a CAS loop to</span>\n                            <span class=\"token comment\" spellcheck=\"true\">// ensure we only request as much as needed, no more no less</span>\n                            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                <span class=\"token keyword\">long</span> r <span class=\"token operator\">=</span> requested<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token keyword\">long</span> c <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> limit <span class=\"token operator\">-</span> r<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>requested<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">,</span> r <span class=\"token operator\">+</span> c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                    producer<span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token punctuation\">}</span>\n                            <span class=\"token punctuation\">}</span>\n                        <span class=\"token punctuation\">}</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里实际上是调用了下游的child Subscriber(就是我们最后new的Subscriber)setProducer，根据前面的总结，最后会调用这里这个匿名Producer的request方法，并且n = Long.MAX_VALUE,最后会走到producer.request(c)这句，而且c = limit,啊哈！！！！，因为我们是take(1) 所以limit = 1，上游的RangeProducer 生产一个数据之后就没了，没了！导致2不会被发射出来！</p>\n<p>做一整个问题就出在take操作符这里，因为take认为自己只要一个数据，所以只向上游请求了一个数据，这其实非常符合take的逻辑，然而它的上游，可以认为此时take的上游是我们的EvenFilter，EvenFilter自身数据来自range，而不是对range发来的数据做缓存，然后根据下游的请求来发射偶数2。所以这里与其说是take的错误，不如说是我们的Operator实现不够完美。那么我们这里其实有三种解决办法，一种是简单的修改EvenFilter</p>\n<ul>\n<li><p>request(1)</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span>Integer t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                      child<span class=\"token punctuation\">.</span><span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                  <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这样达到的效果是，如果符合要求，发往下游，不然请求下一个数据，这样所有的数据都会被发射出来</p>\n</li>\n<li><p>使用filter操作符<br>或者是使用rxjava提供的操作符，因为我们的EvenFilter实在有点多次一举，只是简单的过滤偶数，可以使用filter操作符：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">  Observable<span class=\"token punctuation\">.</span><span class=\"token function\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Func1</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Boolean<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                  <span class=\"token annotation punctuation\">@Override</span>\n                  <span class=\"token keyword\">public</span> Boolean <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>Integer integer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                      <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>integer <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n                  <span class=\"token punctuation\">}</span>\n              <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li>使用其余的构造方法返回Subscriber<br>由于我们的EvenFilter返回的Subscriber使用的是Subscriber(subscriber)构造方法，所以使得 会调用child.setProducer，这里我们使用空的构造方法：</li>\n</ul>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"> <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Subscriber</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token comment\" spellcheck=\"true\">/*child*/</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n                <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span>Integer t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"inner: \"</span> <span class=\"token operator\">+</span> t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">&amp;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        child<span class=\"token punctuation\">.</span><span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n\n\n                <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>Throwable e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    child<span class=\"token punctuation\">.</span><span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n\n\n                <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onCompleted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    child<span class=\"token punctuation\">.</span><span class=\"token function\">onCompleted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>为什么这样可以呢，因为这样就不会调用child的setProducer,而是返回的这个Subscriber的setProducer，根据前面总结的，由于这个Subscriber没有内置的Subscriber,最后会导致调用RangeProducer的 request(Long.MAX_VALUE),一口气生产全部的数据</p>\n<p>其实这个例子暗含一个教训，我们在实现自己的操作符的时候尽量不要去使用Subscriber(subscriber)这个构造方法返回Subscriber给上游，因为导致的问题是我们操作符自己被跨越了，下游和上游单独在联系，跨越了操作符自己，导致有些问题不能按照上游到下游一条连贯的线去思考，容易出现一些反常识的bug。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文基于 rxjava 1.3.8</p>\n<h3 id=\"背压\"><a href=\"#背压\" class=\"headerlink\" title=\"背压\"></a>背压</h3><p>Producer本身是作为沟通上下游的一个接口，只有一个方法：</p>\n<pre><code class=\"java\">void request(long n);\n</code></pre>\n<p>如果传入的n是Long.MAX_VALUE，表明是放弃背压，上游会有多少就生产多少。比如range()操作符内部的RangeProducer，如果遇到n = Long.MAX_VALUE,直接用fastPath方法，一口气把事件全部发射出去，反之是请求多少生产多少。</p>\n<p>但是平时我们调用range操作符，好像都没有考虑过什么背压，都是这样：</p>\n<pre><code class=\"java\">            Observable.range(1, 2)\n                .subscribe(new Subscriber&lt;Integer&gt;() {\n                    @Override\n                    public void onCompleted() {\n\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n\n                    }\n\n                    @Override\n                    public void onNext(Integer integer) {\n                            System.out.println(integer)\n                    }\n                });\n</code></pre>\n<p>也同样是一口气把数据全部给我了，似乎也没有调用request(Long.MAX_VALUE)</p>\n<h3 id=\"Range操作符内部\"><a href=\"#Range操作符内部\" class=\"headerlink\" title=\"Range操作符内部\"></a>Range操作符内部</h3><p>进入到range操作符，实际内部只有这么一句：</p>\n<pre><code class=\"java\">    public void call(final Subscriber&lt;? super Integer&gt; childSubscriber) {\n        childSubscriber.setProducer(new RangeProducer(childSubscriber, startIndex, endIndex));\n    }\n</code></pre>\n<p>RangeProducer这个Producer实际上就是一个fastPath和slowPath，分别对应没有背压和有背压的情况</p>\n<p>那么实际childSubscriber是下游的subscriber，也就是我们调用subscriber的时候new 出来的那个,那么问题来了，到这里都没有什么问题，为何range操作符还是会一口气把数据全部发射出去呢？这里setProducer我们漏掉了。<br>看一下setProducer做了什么。setProducer方法是subscriber的方法，这里很好理解，下游的subscriber需要数据属于消费者，消费者需要通知生产者，所以给消费者一个方法设置合适（不同场景下有不同的生产者）的生产者。</p>\n<pre><code class=\"java\">        public void setProducer(Producer p) {\n        long toRequest;\n        boolean passToSubscriber = false;\n        synchronized (this) {\n            toRequest = requested;\n            producer = p;\n            if (subscriber != null) {\n                // middle operator ... we pass through unless a request has been made\n                if (toRequest == NOT_SET) {\n                    // we pass through to the next producer as nothing has been requested\n                    passToSubscriber = true;\n                }\n            }\n        }\n        // do after releasing lock\n        if (passToSubscriber) {\n            subscriber.setProducer(producer);\n        } else {\n            // we execute the request with whatever has been requested (or Long.MAX_VALUE)\n            if (toRequest == NOT_SET) {\n                producer.request(Long.MAX_VALUE);\n            } else {\n                producer.request(toRequest);\n            }\n        }\n    }\n</code></pre>\n<p>官方的注释其实已经是对这段代码的最简洁的解释了：如果Subscriber是通过Subscriber(Subscriber)或者Subscriber(Subscriber, boolean)方法设置了subscriber，那么就会对这个subscriber调用setProducer，反之如果没有设置subscriber并且已经有请求到来，那么就会直接调用producer.request(n)，其中n是已经累积的请求。</p>\n<p>当然官方解释遗漏一个情况，那就是当没有设置subscriber，而且也没有请求到来的时候，那么就会调用producer.request(Long.MAX_VALUE),也就是让上游有多少就生产多少。</p>\n<p>当然为了更容易明白这个方法的作用，总结一下：如果Subscriber自身设置了内部Subcriber那么会把这个producer设置给这个内部Subscriber;不然就请求上游（request(n))开始生产积累的数据,没有累积请求那就一口气全部生产完。有些时候我们要深刻理解前面半句，因为setProducer可能会形成很长的调用链:)。</p>\n<p>回到最开始的具体的例子range(1,2).subscribe(subscriber),实际range操作内部那个childSubscriber 是我们new的那个subscriber（准确说是包装了之后的SafeSubscriber） 调用setProducer设置了RangeProducer。<br>由于我们new 的Subscriber是没有设置内置的subscriber的，那么最后实际会走到 “producer.request(Long.MAX_VALUE);”那句来，导致的结果就是RangeProducer 调用fastPath不考虑背压一口气全部生产完数据。</p>\n<h3 id=\"多个操作符的情况\"><a href=\"#多个操作符的情况\" class=\"headerlink\" title=\"多个操作符的情况\"></a>多个操作符的情况</h3><p>这里我们有一个自定义的操作符，目的是过滤掉奇数，只要偶数：</p>\n<pre><code class=\"java\">EvenFilter implements Observable.Operator&lt;Integer, Integer&gt; {\n        public Subscriber&lt;? super Integer&gt; call(final Subscriber&lt;? super Integer&gt; child) {\n\n            return new Subscriber&lt;Integer&gt;(child) {\n\n                public void onNext(Integer t) {\n                    if ((t &amp; 1) == 0) {\n                        child.onNext(t);\n                    }\n                }\n\n\n                public void onError(Throwable e) {\n                    child.onError(e);\n                }\n\n\n                public void onCompleted() {\n                    child.onCompleted();\n                }\n            };\n        }\n    }\n</code></pre>\n<p>操作符本身很简单，在onNext那里简单过滤了一下，看上去很完美。我们再写个例子：</p>\n<pre><code class=\"java\">     Observable.range(1, 2)\n                .lift(new EvenFilter())\n                .subscribe(new Subscriber&lt;Integer&gt;() {\n                    @Override\n                    public void onCompleted() {\n\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n\n                    }\n\n                    @Override\n                    public void onNext(Integer integer) {\n                        System.out.println(integer);\n                    }\n                });\n</code></pre>\n<p>逻辑也很简单，最后打印出了 2，符合预期。我们再加上一个操作符take()</p>\n<pre><code class=\"java\">     Observable.range(1, 2)\n                .lift(new EvenFilter())\n                .take(1).subscribe(new Action1&lt;Integer&gt;() {\n                    @Override\n                    public void call(Integer integer) {\n                        System.out.println(integer);\n                    }\n                })\n</code></pre>\n<p>然后就出问题了，什么都没有打印。有点反常，因为加上了take(1),逻辑上是没有改变的，应该会输出一样的结果。 一直到lift(new EvenFilter())操作都是可以正常往下游发射数据的，那么为什么只是加入了take会变得奇怪导致没有数据打印。很明显问题出在take操作符上。</p>\n<p>分析，必须给他分析————range操作符 childSubscriber.setProducer那句实际上childSubscriber是我们下游EventFilter call方法返回的Subscriber，由于EvenFilter 返回的这个Subscriber设置了child这个Subscriber，所以实际上还会调用这个child的setProducer<br>把RangeProuducer设置给这个child。而这个child实际又是下游take操作符内部返回的Subscriber ，take操作符返回的这个Subscriber的setProducer方法是这样的：</p>\n<pre><code class=\"java\">     public void setProducer(final Producer producer) {\n                child.setProducer(new Producer() {\n\n                    // keeps track of requests up to maximum of `limit`\n                    final AtomicLong requested = new AtomicLong(0);\n\n                    @Override\n                    public void request(long n) {\n                        if (n &gt; 0 &amp;&amp; !completed) {\n                            // because requests may happen concurrently use a CAS loop to\n                            // ensure we only request as much as needed, no more no less\n                            while (true) {\n                                long r = requested.get();\n                                long c = Math.min(n, limit - r);\n                                if (c == 0) {\n                                    break;\n                                } else if (requested.compareAndSet(r, r + c)) {\n                                    producer.request(c);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n</code></pre>\n<p>这里实际上是调用了下游的child Subscriber(就是我们最后new的Subscriber)setProducer，根据前面的总结，最后会调用这里这个匿名Producer的request方法，并且n = Long.MAX_VALUE,最后会走到producer.request(c)这句，而且c = limit,啊哈！！！！，因为我们是take(1) 所以limit = 1，上游的RangeProducer 生产一个数据之后就没了，没了！导致2不会被发射出来！</p>\n<p>做一整个问题就出在take操作符这里，因为take认为自己只要一个数据，所以只向上游请求了一个数据，这其实非常符合take的逻辑，然而它的上游，可以认为此时take的上游是我们的EvenFilter，EvenFilter自身数据来自range，而不是对range发来的数据做缓存，然后根据下游的请求来发射偶数2。所以这里与其说是take的错误，不如说是我们的Operator实现不够完美。那么我们这里其实有三种解决办法，一种是简单的修改EvenFilter</p>\n<ul>\n<li><p>request(1)</p>\n<pre><code class=\"java\">  public void onNext(Integer t) {\n                  if ((t &amp; 1) == 0) {\n                      child.onNext(t);\n                  }else request(1)\n              }\n</code></pre>\n<p>这样达到的效果是，如果符合要求，发往下游，不然请求下一个数据，这样所有的数据都会被发射出来</p>\n</li>\n<li><p>使用filter操作符<br>或者是使用rxjava提供的操作符，因为我们的EvenFilter实在有点多次一举，只是简单的过滤偶数，可以使用filter操作符：</p>\n<pre><code class=\"java\">  Observable.range(1, 2)\n              .filter(new Func1&lt;Integer, Boolean&gt;() {\n                  @Override\n                  public Boolean call(Integer integer) {\n                      return (integer &amp; 1) == 0;\n                  }\n              })\n              .take(1)\n</code></pre>\n</li>\n<li>使用其余的构造方法返回Subscriber<br>由于我们的EvenFilter返回的Subscriber使用的是Subscriber(subscriber)构造方法，所以使得 会调用child.setProducer，这里我们使用空的构造方法：</li>\n</ul>\n<pre><code class=\"java\"> return new Subscriber&lt;Integer&gt;(/*child*/) {\n\n                public void onNext(Integer t) {\n                    System.out.println(&quot;inner: &quot; + t);\n                    if ((t &amp; 1) == 0) {\n                        child.onNext(t);\n                    }\n                }\n\n\n                public void onError(Throwable e) {\n                    child.onError(e);\n                }\n\n\n                public void onCompleted() {\n                    child.onCompleted();\n                }\n            };\n</code></pre>\n<p>为什么这样可以呢，因为这样就不会调用child的setProducer,而是返回的这个Subscriber的setProducer，根据前面总结的，由于这个Subscriber没有内置的Subscriber,最后会导致调用RangeProducer的 request(Long.MAX_VALUE),一口气生产全部的数据</p>\n<p>其实这个例子暗含一个教训，我们在实现自己的操作符的时候尽量不要去使用Subscriber(subscriber)这个构造方法返回Subscriber给上游，因为导致的问题是我们操作符自己被跨越了，下游和上游单独在联系，跨越了操作符自己，导致有些问题不能按照上游到下游一条连贯的线去思考，容易出现一些反常识的bug。</p>\n"},{"title":"利用模板写Span","date":"2017-09-05T02:45:56.000Z","_content":"在之前的项目中，PM特别喜欢把一些文字做颜色或者大小上的区分，所以经常会用到Span，没有什么好的封装想法，只能老老实实的用原始的api，显得非常的笨，但是又没有什么办法，没想到什么好的封装策略，只是觉得这样写真的好难看啊。但是一般需要做特殊处理的文字其实都是后台返回的某些字段，是有特别含义的，比如“距离审核还有6天结束”中的‘6’其实就是后台会单独返回给你的。我们App这边拼接好整句话然后显示出来。当时在做这样的项目的时候也找过类似的开源库，但是觉得总觉得哪里不对，也懒得用，还是用的原始的套路，先数一数‘6’在字符串中的起始结束下标，然后设置Span。直到最近为了深入了解gradle，去看了下groovy，看到“Template engines”的时候突然想起之前的Span，于是有了一个大胆的想法。\n\n### 关于 Groovy的Template\nGroovy可以动态生成字符串，比如模板是这样的'${name} is ${age} years old! '\n绑定关系是这样的：[name:\"Alice\",age:\"18\"],那么生成的文字就是\"Alice is 18 years old!\"。你可能要问了，这和你说的Span有什么关系？？？当然有，前面我们说了，我们的需要设置Span的文字其实都是有含义的，我们用原始的api那样数出下标然后设置Span非常的无脑，根本没有体现出这个字段的含义，但是现在如果我们用groovy的方式，定义自己的模板那么\"距离审核还有6天结束\"的模板是不是就是\"距离审核还有${day}天结束\"，这样表达起来是不是更有内涵些，然后你又要问我，确实有内涵了，但这和Span又有什么关系呢？？好吧，也没什么关系，就是要有内涵一点，所以借用Groovy的思想重新封装对Span的处理。你可能还要问，不是已经有类似的库了吗，干嘛还要封装一个，比如Spanny。那好，我们看看Spanny怎么做的，\n```java\n    Spanny spanny = new Spanny(\"距离审核还有\")\n                .append(\"6\", new ForegroundColorSpan(Color.RED))\n                .append(\"天结束！\");\n    textView.setText(spanny);\n```\n\n\n对比我们定义好一个模板 \"距离审核还有${day}天结束\"，比较一下就看出不同了。Spanny的做法是希望需要什么样的Span就自己拼一个，虽然配合链式调用挺舒服的，其实给人的感觉就是很分离，并不像一句完整的句子那么看起来实在，个人觉得还是Groovy这样的模板很合适，毕竟当需要处理Span的时候，结构都是死的，所以用模板定义好结构是没有问题的，特别是当要处理的文字比较多的时候，这样拼接我觉得不太好，用定义的模板一眼看过去就非常的清晰明了。\n\n\n\n### 需要解决的问题\n虽然引入了template的思想来动态生成字符串，同时又需要对key替换后的文字做对应的处理，那么要解决的问题有以下三个：\n1 如何解析模板字符串\n2 如何替换key并生成结果字符串\n3 如何解决以上两个问题\n\n关于第一个问题，看了下groovy解析模板的代码，自己做了一下修改差不多就是抄过来的，只是加入了一些额外的逻辑)\n最后解析模板的代码是这样的：\n```java\nList<MarkInfo> parseAndMark(Reader reader, Map<String, String> binding) {\n        if (!reader.markSupported())\n            reader = new BufferedReader(reader);\n        List<MarkInfo> markers = new ArrayList<>();\n        MarkInfo mark;\n        StringWriter writer = new StringWriter(50);\n        while (true) {\n            int c;\n            try {\n                if ((c = reader.read()) != -1) {\n                    if (c == '$') {\n                        reader.mark(1);\n                        c = reader.read();\n                        if (c == '{') {\n                            String key = findKey(reader);\n                            //only true for text\n                            if (!key.isEmpty()) {\n                                String value = binding.get(key);\n                                //for text\n                                if (value != null) {\n                                    int start = writer.getBuffer().length();\n                                    int end = start + value.length();\n                                    markers.add(new MarkInfo(key, value, start, end));\n                                    writer.write(value);\n                                } else {//for image\n\n                                    int start = writer.getBuffer().length();\n                                    int end = start + key.length();\n                                    markers.add(new MarkInfo(key, value, start, end));\n                                    writer.write(key);\n                                }\n                            } else {\n                                writer.write(\"${\");\n                                //key not found\n                                writer.write(key);\n                            }\n\n                        } else {\n                            writer.write('$');\n                            reader.reset();\n                        }\n                    } else {\n                        writer.write(c);\n                    }\n                } else break;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        return markers;\n    }\n\n\n    String findKey(Reader reader) {\n        StringWriter stringBuilder = new StringWriter(10);\n        int c;\n        try {\n            while ((c = reader.read()) != -1) {\n                if (c == '}')\n                    break;\n                else stringBuilder.write(c);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n```\n这个方法的作用就是记录模板中所有key的起始结束位置。比如原始模板是：\"${name} is ${age} years old! \"数据映射是[name:\"Alice\",age:\"18\"],解析之后就变成\"Alice is 18 years old! \"。并且'Alice' '18'两个数据在字符串中的位置被记录在了MarkrInfo中\n\n我们来简单分析一下代码，一个简单的while循环，每次读取一个字符，每当读到'$'字符时认为可能是key要出现了，所以先在此处标记一下紧接着读取下一个字符，如果读到下一个字符是'{'则认为key出现了，调用findKey方法读取'{'和'}'之间的key值，如果为空则认为没有key，仅仅是读到了一个普通的\"${}\"，并且写入writer保存起来，如果key不为空认为读取到有效的key，记录key对应的value在字符串中的位置等信息，并且将value写入writer保存起来；如果'$'后面读到的不是'}'则认为只是读到了一个单独的'$'字符，虚惊一场，写入writer保存起来，并且把reader 重置，回到刚才标记的地方，也就是'$'的位置；如果读取的是普通的字符，直接写入writer.另外要说的就是ImageSpan的处理，由于有些字符最后是要替换成图片的，所以在binding中是没有其对应value的，所以当读取的key在binding中如果没有value，就认为这个key是要被替换成图片的，所以直接用key代替value，直接把key写入writer保存起来。\n\n解析这一步完成以后我们其实得到了一个List<MarkerInfo>，记录了key被替换成value后的value在结果字符串中的位置信息，以及原始的key等信息。有了这些重要信息，就可以根据下标施加对应的Span了，以及一些点击事件的监听了。\n\n施加Span的时候需要考虑文字和ImageSpan的差别，绝大多数时候是对文字的处理，不过有一种是把文字替换成图像，所以这个key在bingding中对应的就是个null,所以在施加span的时候都会判断一下是否为空，为空则说明是个ImageSpan,就不会做除了ImageSpan之外的任何处理","source":"_posts/SpanTextView.md","raw":"---\ntitle: 利用模板写Span\ndate: 2017-09-05 10:45:56\ntags: \n    - SpannableString\n    - TextView\n\n---\n在之前的项目中，PM特别喜欢把一些文字做颜色或者大小上的区分，所以经常会用到Span，没有什么好的封装想法，只能老老实实的用原始的api，显得非常的笨，但是又没有什么办法，没想到什么好的封装策略，只是觉得这样写真的好难看啊。但是一般需要做特殊处理的文字其实都是后台返回的某些字段，是有特别含义的，比如“距离审核还有6天结束”中的‘6’其实就是后台会单独返回给你的。我们App这边拼接好整句话然后显示出来。当时在做这样的项目的时候也找过类似的开源库，但是觉得总觉得哪里不对，也懒得用，还是用的原始的套路，先数一数‘6’在字符串中的起始结束下标，然后设置Span。直到最近为了深入了解gradle，去看了下groovy，看到“Template engines”的时候突然想起之前的Span，于是有了一个大胆的想法。\n\n### 关于 Groovy的Template\nGroovy可以动态生成字符串，比如模板是这样的'${name} is ${age} years old! '\n绑定关系是这样的：[name:\"Alice\",age:\"18\"],那么生成的文字就是\"Alice is 18 years old!\"。你可能要问了，这和你说的Span有什么关系？？？当然有，前面我们说了，我们的需要设置Span的文字其实都是有含义的，我们用原始的api那样数出下标然后设置Span非常的无脑，根本没有体现出这个字段的含义，但是现在如果我们用groovy的方式，定义自己的模板那么\"距离审核还有6天结束\"的模板是不是就是\"距离审核还有${day}天结束\"，这样表达起来是不是更有内涵些，然后你又要问我，确实有内涵了，但这和Span又有什么关系呢？？好吧，也没什么关系，就是要有内涵一点，所以借用Groovy的思想重新封装对Span的处理。你可能还要问，不是已经有类似的库了吗，干嘛还要封装一个，比如Spanny。那好，我们看看Spanny怎么做的，\n```java\n    Spanny spanny = new Spanny(\"距离审核还有\")\n                .append(\"6\", new ForegroundColorSpan(Color.RED))\n                .append(\"天结束！\");\n    textView.setText(spanny);\n```\n\n\n对比我们定义好一个模板 \"距离审核还有${day}天结束\"，比较一下就看出不同了。Spanny的做法是希望需要什么样的Span就自己拼一个，虽然配合链式调用挺舒服的，其实给人的感觉就是很分离，并不像一句完整的句子那么看起来实在，个人觉得还是Groovy这样的模板很合适，毕竟当需要处理Span的时候，结构都是死的，所以用模板定义好结构是没有问题的，特别是当要处理的文字比较多的时候，这样拼接我觉得不太好，用定义的模板一眼看过去就非常的清晰明了。\n\n\n\n### 需要解决的问题\n虽然引入了template的思想来动态生成字符串，同时又需要对key替换后的文字做对应的处理，那么要解决的问题有以下三个：\n1 如何解析模板字符串\n2 如何替换key并生成结果字符串\n3 如何解决以上两个问题\n\n关于第一个问题，看了下groovy解析模板的代码，自己做了一下修改差不多就是抄过来的，只是加入了一些额外的逻辑)\n最后解析模板的代码是这样的：\n```java\nList<MarkInfo> parseAndMark(Reader reader, Map<String, String> binding) {\n        if (!reader.markSupported())\n            reader = new BufferedReader(reader);\n        List<MarkInfo> markers = new ArrayList<>();\n        MarkInfo mark;\n        StringWriter writer = new StringWriter(50);\n        while (true) {\n            int c;\n            try {\n                if ((c = reader.read()) != -1) {\n                    if (c == '$') {\n                        reader.mark(1);\n                        c = reader.read();\n                        if (c == '{') {\n                            String key = findKey(reader);\n                            //only true for text\n                            if (!key.isEmpty()) {\n                                String value = binding.get(key);\n                                //for text\n                                if (value != null) {\n                                    int start = writer.getBuffer().length();\n                                    int end = start + value.length();\n                                    markers.add(new MarkInfo(key, value, start, end));\n                                    writer.write(value);\n                                } else {//for image\n\n                                    int start = writer.getBuffer().length();\n                                    int end = start + key.length();\n                                    markers.add(new MarkInfo(key, value, start, end));\n                                    writer.write(key);\n                                }\n                            } else {\n                                writer.write(\"${\");\n                                //key not found\n                                writer.write(key);\n                            }\n\n                        } else {\n                            writer.write('$');\n                            reader.reset();\n                        }\n                    } else {\n                        writer.write(c);\n                    }\n                } else break;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        return markers;\n    }\n\n\n    String findKey(Reader reader) {\n        StringWriter stringBuilder = new StringWriter(10);\n        int c;\n        try {\n            while ((c = reader.read()) != -1) {\n                if (c == '}')\n                    break;\n                else stringBuilder.write(c);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n```\n这个方法的作用就是记录模板中所有key的起始结束位置。比如原始模板是：\"${name} is ${age} years old! \"数据映射是[name:\"Alice\",age:\"18\"],解析之后就变成\"Alice is 18 years old! \"。并且'Alice' '18'两个数据在字符串中的位置被记录在了MarkrInfo中\n\n我们来简单分析一下代码，一个简单的while循环，每次读取一个字符，每当读到'$'字符时认为可能是key要出现了，所以先在此处标记一下紧接着读取下一个字符，如果读到下一个字符是'{'则认为key出现了，调用findKey方法读取'{'和'}'之间的key值，如果为空则认为没有key，仅仅是读到了一个普通的\"${}\"，并且写入writer保存起来，如果key不为空认为读取到有效的key，记录key对应的value在字符串中的位置等信息，并且将value写入writer保存起来；如果'$'后面读到的不是'}'则认为只是读到了一个单独的'$'字符，虚惊一场，写入writer保存起来，并且把reader 重置，回到刚才标记的地方，也就是'$'的位置；如果读取的是普通的字符，直接写入writer.另外要说的就是ImageSpan的处理，由于有些字符最后是要替换成图片的，所以在binding中是没有其对应value的，所以当读取的key在binding中如果没有value，就认为这个key是要被替换成图片的，所以直接用key代替value，直接把key写入writer保存起来。\n\n解析这一步完成以后我们其实得到了一个List<MarkerInfo>，记录了key被替换成value后的value在结果字符串中的位置信息，以及原始的key等信息。有了这些重要信息，就可以根据下标施加对应的Span了，以及一些点击事件的监听了。\n\n施加Span的时候需要考虑文字和ImageSpan的差别，绝大多数时候是对文字的处理，不过有一种是把文字替换成图像，所以这个key在bingding中对应的就是个null,所以在施加span的时候都会判断一下是否为空，为空则说明是个ImageSpan,就不会做除了ImageSpan之外的任何处理","slug":"SpanTextView","published":1,"updated":"2017-09-25T09:13:41.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl1qvapk000dy472kc2su925","content":"<p>在之前的项目中，PM特别喜欢把一些文字做颜色或者大小上的区分，所以经常会用到Span，没有什么好的封装想法，只能老老实实的用原始的api，显得非常的笨，但是又没有什么办法，没想到什么好的封装策略，只是觉得这样写真的好难看啊。但是一般需要做特殊处理的文字其实都是后台返回的某些字段，是有特别含义的，比如“距离审核还有6天结束”中的‘6’其实就是后台会单独返回给你的。我们App这边拼接好整句话然后显示出来。当时在做这样的项目的时候也找过类似的开源库，但是觉得总觉得哪里不对，也懒得用，还是用的原始的套路，先数一数‘6’在字符串中的起始结束下标，然后设置Span。直到最近为了深入了解gradle，去看了下groovy，看到“Template engines”的时候突然想起之前的Span，于是有了一个大胆的想法。</p>\n<h3 id=\"关于-Groovy的Template\"><a href=\"#关于-Groovy的Template\" class=\"headerlink\" title=\"关于 Groovy的Template\"></a>关于 Groovy的Template</h3><p>Groovy可以动态生成字符串，比如模板是这样的’${name} is ${age} years old! ‘<br>绑定关系是这样的：[name:”Alice”,age:”18”],那么生成的文字就是”Alice is 18 years old!”。你可能要问了，这和你说的Span有什么关系？？？当然有，前面我们说了，我们的需要设置Span的文字其实都是有含义的，我们用原始的api那样数出下标然后设置Span非常的无脑，根本没有体现出这个字段的含义，但是现在如果我们用groovy的方式，定义自己的模板那么”距离审核还有6天结束”的模板是不是就是”距离审核还有${day}天结束”，这样表达起来是不是更有内涵些，然后你又要问我，确实有内涵了，但这和Span又有什么关系呢？？好吧，也没什么关系，就是要有内涵一点，所以借用Groovy的思想重新封装对Span的处理。你可能还要问，不是已经有类似的库了吗，干嘛还要封装一个，比如Spanny。那好，我们看看Spanny怎么做的，</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">    Spanny spanny <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Spanny</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"距离审核还有\"</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"6\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ForegroundColorSpan</span><span class=\"token punctuation\">(</span>Color<span class=\"token punctuation\">.</span>RED<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"天结束！\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    textView<span class=\"token punctuation\">.</span><span class=\"token function\">setText</span><span class=\"token punctuation\">(</span>spanny<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>对比我们定义好一个模板 “距离审核还有${day}天结束”，比较一下就看出不同了。Spanny的做法是希望需要什么样的Span就自己拼一个，虽然配合链式调用挺舒服的，其实给人的感觉就是很分离，并不像一句完整的句子那么看起来实在，个人觉得还是Groovy这样的模板很合适，毕竟当需要处理Span的时候，结构都是死的，所以用模板定义好结构是没有问题的，特别是当要处理的文字比较多的时候，这样拼接我觉得不太好，用定义的模板一眼看过去就非常的清晰明了。</p>\n<h3 id=\"需要解决的问题\"><a href=\"#需要解决的问题\" class=\"headerlink\" title=\"需要解决的问题\"></a>需要解决的问题</h3><p>虽然引入了template的思想来动态生成字符串，同时又需要对key替换后的文字做对应的处理，那么要解决的问题有以下三个：<br>1 如何解析模板字符串<br>2 如何替换key并生成结果字符串<br>3 如何解决以上两个问题</p>\n<p>关于第一个问题，看了下groovy解析模板的代码，自己做了一下修改差不多就是抄过来的，只是加入了一些额外的逻辑)<br>最后解析模板的代码是这样的：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">List<span class=\"token operator\">&lt;</span>MarkInfo<span class=\"token operator\">></span> <span class=\"token function\">parseAndMark</span><span class=\"token punctuation\">(</span>Reader reader<span class=\"token punctuation\">,</span> Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> binding<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>reader<span class=\"token punctuation\">.</span><span class=\"token function\">markSupported</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            reader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BufferedReader</span><span class=\"token punctuation\">(</span>reader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        List<span class=\"token operator\">&lt;</span>MarkInfo<span class=\"token operator\">></span> markers <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        MarkInfo mark<span class=\"token punctuation\">;</span>\n        StringWriter writer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringWriter</span><span class=\"token punctuation\">(</span><span class=\"token number\">50</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">=</span> reader<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token string\">'$'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        reader<span class=\"token punctuation\">.</span><span class=\"token function\">mark</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        c <span class=\"token operator\">=</span> reader<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token string\">'{'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                            String key <span class=\"token operator\">=</span> <span class=\"token function\">findKey</span><span class=\"token punctuation\">(</span>reader<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token comment\" spellcheck=\"true\">//only true for text</span>\n                            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                String value <span class=\"token operator\">=</span> binding<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token comment\" spellcheck=\"true\">//for text</span>\n                                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                    <span class=\"token keyword\">int</span> start <span class=\"token operator\">=</span> writer<span class=\"token punctuation\">.</span><span class=\"token function\">getBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                    <span class=\"token keyword\">int</span> end <span class=\"token operator\">=</span> start <span class=\"token operator\">+</span> value<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                    markers<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">MarkInfo</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                    writer<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span><span class=\"token comment\" spellcheck=\"true\">//for image</span>\n\n                                    <span class=\"token keyword\">int</span> start <span class=\"token operator\">=</span> writer<span class=\"token punctuation\">.</span><span class=\"token function\">getBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                    <span class=\"token keyword\">int</span> end <span class=\"token operator\">=</span> start <span class=\"token operator\">+</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                    markers<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">MarkInfo</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> start<span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                    writer<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token punctuation\">}</span>\n                            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                                writer<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"${\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token comment\" spellcheck=\"true\">//key not found</span>\n                                writer<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token punctuation\">}</span>\n\n                        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                            writer<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token string\">'$'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            reader<span class=\"token punctuation\">.</span><span class=\"token function\">reset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token punctuation\">}</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                        writer<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">return</span> markers<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    String <span class=\"token function\">findKey</span><span class=\"token punctuation\">(</span>Reader reader<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        StringWriter stringBuilder <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringWriter</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> c<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">=</span> reader<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token string\">'}'</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">else</span> stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> stringBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这个方法的作用就是记录模板中所有key的起始结束位置。比如原始模板是：”${name} is ${age} years old! “数据映射是[name:”Alice”,age:”18”],解析之后就变成”Alice is 18 years old! “。并且’Alice’ ‘18’两个数据在字符串中的位置被记录在了MarkrInfo中</p>\n<p>我们来简单分析一下代码，一个简单的while循环，每次读取一个字符，每当读到’$’字符时认为可能是key要出现了，所以先在此处标记一下紧接着读取下一个字符，如果读到下一个字符是’{‘则认为key出现了，调用findKey方法读取’{‘和’}’之间的key值，如果为空则认为没有key，仅仅是读到了一个普通的”${}”，并且写入writer保存起来，如果key不为空认为读取到有效的key，记录key对应的value在字符串中的位置等信息，并且将value写入writer保存起来；如果’$’后面读到的不是’}’则认为只是读到了一个单独的’$’字符，虚惊一场，写入writer保存起来，并且把reader 重置，回到刚才标记的地方，也就是’$’的位置；如果读取的是普通的字符，直接写入writer.另外要说的就是ImageSpan的处理，由于有些字符最后是要替换成图片的，所以在binding中是没有其对应value的，所以当读取的key在binding中如果没有value，就认为这个key是要被替换成图片的，所以直接用key代替value，直接把key写入writer保存起来。</p>\n<p>解析这一步完成以后我们其实得到了一个List<markerinfo>，记录了key被替换成value后的value在结果字符串中的位置信息，以及原始的key等信息。有了这些重要信息，就可以根据下标施加对应的Span了，以及一些点击事件的监听了。</markerinfo></p>\n<p>施加Span的时候需要考虑文字和ImageSpan的差别，绝大多数时候是对文字的处理，不过有一种是把文字替换成图像，所以这个key在bingding中对应的就是个null,所以在施加span的时候都会判断一下是否为空，为空则说明是个ImageSpan,就不会做除了ImageSpan之外的任何处理</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在之前的项目中，PM特别喜欢把一些文字做颜色或者大小上的区分，所以经常会用到Span，没有什么好的封装想法，只能老老实实的用原始的api，显得非常的笨，但是又没有什么办法，没想到什么好的封装策略，只是觉得这样写真的好难看啊。但是一般需要做特殊处理的文字其实都是后台返回的某些字段，是有特别含义的，比如“距离审核还有6天结束”中的‘6’其实就是后台会单独返回给你的。我们App这边拼接好整句话然后显示出来。当时在做这样的项目的时候也找过类似的开源库，但是觉得总觉得哪里不对，也懒得用，还是用的原始的套路，先数一数‘6’在字符串中的起始结束下标，然后设置Span。直到最近为了深入了解gradle，去看了下groovy，看到“Template engines”的时候突然想起之前的Span，于是有了一个大胆的想法。</p>\n<h3 id=\"关于-Groovy的Template\"><a href=\"#关于-Groovy的Template\" class=\"headerlink\" title=\"关于 Groovy的Template\"></a>关于 Groovy的Template</h3><p>Groovy可以动态生成字符串，比如模板是这样的’${name} is ${age} years old! ‘<br>绑定关系是这样的：[name:”Alice”,age:”18”],那么生成的文字就是”Alice is 18 years old!”。你可能要问了，这和你说的Span有什么关系？？？当然有，前面我们说了，我们的需要设置Span的文字其实都是有含义的，我们用原始的api那样数出下标然后设置Span非常的无脑，根本没有体现出这个字段的含义，但是现在如果我们用groovy的方式，定义自己的模板那么”距离审核还有6天结束”的模板是不是就是”距离审核还有${day}天结束”，这样表达起来是不是更有内涵些，然后你又要问我，确实有内涵了，但这和Span又有什么关系呢？？好吧，也没什么关系，就是要有内涵一点，所以借用Groovy的思想重新封装对Span的处理。你可能还要问，不是已经有类似的库了吗，干嘛还要封装一个，比如Spanny。那好，我们看看Spanny怎么做的，</p>\n<pre><code class=\"java\">    Spanny spanny = new Spanny(&quot;距离审核还有&quot;)\n                .append(&quot;6&quot;, new ForegroundColorSpan(Color.RED))\n                .append(&quot;天结束！&quot;);\n    textView.setText(spanny);\n</code></pre>\n<p>对比我们定义好一个模板 “距离审核还有${day}天结束”，比较一下就看出不同了。Spanny的做法是希望需要什么样的Span就自己拼一个，虽然配合链式调用挺舒服的，其实给人的感觉就是很分离，并不像一句完整的句子那么看起来实在，个人觉得还是Groovy这样的模板很合适，毕竟当需要处理Span的时候，结构都是死的，所以用模板定义好结构是没有问题的，特别是当要处理的文字比较多的时候，这样拼接我觉得不太好，用定义的模板一眼看过去就非常的清晰明了。</p>\n<h3 id=\"需要解决的问题\"><a href=\"#需要解决的问题\" class=\"headerlink\" title=\"需要解决的问题\"></a>需要解决的问题</h3><p>虽然引入了template的思想来动态生成字符串，同时又需要对key替换后的文字做对应的处理，那么要解决的问题有以下三个：<br>1 如何解析模板字符串<br>2 如何替换key并生成结果字符串<br>3 如何解决以上两个问题</p>\n<p>关于第一个问题，看了下groovy解析模板的代码，自己做了一下修改差不多就是抄过来的，只是加入了一些额外的逻辑)<br>最后解析模板的代码是这样的：</p>\n<pre><code class=\"java\">List&lt;MarkInfo&gt; parseAndMark(Reader reader, Map&lt;String, String&gt; binding) {\n        if (!reader.markSupported())\n            reader = new BufferedReader(reader);\n        List&lt;MarkInfo&gt; markers = new ArrayList&lt;&gt;();\n        MarkInfo mark;\n        StringWriter writer = new StringWriter(50);\n        while (true) {\n            int c;\n            try {\n                if ((c = reader.read()) != -1) {\n                    if (c == &#39;$&#39;) {\n                        reader.mark(1);\n                        c = reader.read();\n                        if (c == &#39;{&#39;) {\n                            String key = findKey(reader);\n                            //only true for text\n                            if (!key.isEmpty()) {\n                                String value = binding.get(key);\n                                //for text\n                                if (value != null) {\n                                    int start = writer.getBuffer().length();\n                                    int end = start + value.length();\n                                    markers.add(new MarkInfo(key, value, start, end));\n                                    writer.write(value);\n                                } else {//for image\n\n                                    int start = writer.getBuffer().length();\n                                    int end = start + key.length();\n                                    markers.add(new MarkInfo(key, value, start, end));\n                                    writer.write(key);\n                                }\n                            } else {\n                                writer.write(&quot;${&quot;);\n                                //key not found\n                                writer.write(key);\n                            }\n\n                        } else {\n                            writer.write(&#39;$&#39;);\n                            reader.reset();\n                        }\n                    } else {\n                        writer.write(c);\n                    }\n                } else break;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        return markers;\n    }\n\n\n    String findKey(Reader reader) {\n        StringWriter stringBuilder = new StringWriter(10);\n        int c;\n        try {\n            while ((c = reader.read()) != -1) {\n                if (c == &#39;}&#39;)\n                    break;\n                else stringBuilder.write(c);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n</code></pre>\n<p>这个方法的作用就是记录模板中所有key的起始结束位置。比如原始模板是：”${name} is ${age} years old! “数据映射是[name:”Alice”,age:”18”],解析之后就变成”Alice is 18 years old! “。并且’Alice’ ‘18’两个数据在字符串中的位置被记录在了MarkrInfo中</p>\n<p>我们来简单分析一下代码，一个简单的while循环，每次读取一个字符，每当读到’$’字符时认为可能是key要出现了，所以先在此处标记一下紧接着读取下一个字符，如果读到下一个字符是’{‘则认为key出现了，调用findKey方法读取’{‘和’}’之间的key值，如果为空则认为没有key，仅仅是读到了一个普通的”${}”，并且写入writer保存起来，如果key不为空认为读取到有效的key，记录key对应的value在字符串中的位置等信息，并且将value写入writer保存起来；如果’$’后面读到的不是’}’则认为只是读到了一个单独的’$’字符，虚惊一场，写入writer保存起来，并且把reader 重置，回到刚才标记的地方，也就是’$’的位置；如果读取的是普通的字符，直接写入writer.另外要说的就是ImageSpan的处理，由于有些字符最后是要替换成图片的，所以在binding中是没有其对应value的，所以当读取的key在binding中如果没有value，就认为这个key是要被替换成图片的，所以直接用key代替value，直接把key写入writer保存起来。</p>\n<p>解析这一步完成以后我们其实得到了一个List<markerinfo>，记录了key被替换成value后的value在结果字符串中的位置信息，以及原始的key等信息。有了这些重要信息，就可以根据下标施加对应的Span了，以及一些点击事件的监听了。</markerinfo></p>\n<p>施加Span的时候需要考虑文字和ImageSpan的差别，绝大多数时候是对文字的处理，不过有一种是把文字替换成图像，所以这个key在bingding中对应的就是个null,所以在施加span的时候都会判断一下是否为空，为空则说明是个ImageSpan,就不会做除了ImageSpan之外的任何处理</p>\n"},{"title":"Rxjava retryWhen和repeatWhen操作符原理","date":"2018-08-08T08:29:42.000Z","_content":"### 契机\n因为最近使用了mvvm，不再用mvp,并且大量使用RxJava 简化一些场景下的操作。以至发现了一个操作符retryWhen，搜了一些资料，几乎都是 一位叫DanLew的外国人写的一篇文章或者其译文。原文在这[ >> ](https://blog.danlew.net/2016/01/25/rxjavas-repeatwhen-and-retrywhen-explained/),思路清晰，知道了怎么用，一些关键的注意点，但就是没有分析具体原理和流程是怎样(但是看他提到的一些词，应该是搞明白了内部原理的)。痛定思痛————当然也是觉得这个操作符非常有意思，所以仔细研究一番。（说实话，我也是最近才觉得RxJava有些源码真的值得好好翻一翻）。本文基于rxjava 1.3.8。\n\n### retryWhen和repeatWhen真的不一样吗\n先看下retryWhen的方法：\n```java\n      public final Observable<T> retryWhen(final Func1<Observable<Throwable>,Observable> notificationHandler) {\n        return OnSubscribeRedo.<T>retry(this, InternalObservableUtils.createRetryDematerializer(notificationHandler));\n    }\n```\n再看repeatWhen:\n```java\n     public final Observable<T> repeatWhen(final Func1<Observable< Void>, Observable> notificationHandler) {\n        return OnSubscribeRedo.repeat(this, \n        InternalObservableUtils.createRepeatDematerializer(notificationHandler));\n    }\n```\n 几乎可以认为是一样的，除了对传入的handler处理稍微不同以外。另外参数上有点小不一样，retryWhen的参数内的泛型是Observable<Throwable>,\n repeatWhen的参数泛型则是Observable<Void>。这和两者响应的事件不一样，retry是对错误响应，发生错误了该选择是否重试；repeat则是对完成事件响应，数据发射完之后是否重试，完成事件是没有数据的所以是Void。\n\n不过我看到这个方法最大的两个疑惑是：为什么不是Func1<Throwable,Boolean>类型的参数，根据给的异常返回true false决定是否重试不是很合理吗？？然后马上反应过来，返回Observable会更灵活，如果重试的逻辑很复杂，单纯根据一个bool 的true or false来决定是否重试，是满足不了一些场景下的需要的。\n\n retryWhen方法上有一段注释：\n ```html\n    Returns an Observable that emits the same values as the source observable with the exception of an {@code onError}. An {@code onError} notification from the source will result in the emission of a{@link Throwable} item to the Observable provided as an argument to the {@code notificationHandler}\n    function. If that Observable calls {@code onComplete} or {@code onError} then {@code retry} will call {@code onCompleted} or {@code onError} on the child subscription. Otherwise, this Observable will resubscribe to the source Observable.\n ```\n 具体含义就是，这个操作符会返回一个Observable(记作o1),o1会发射和源observable一样的数据（源observable可能会抛出异常）。当源Observable 发射错误事件时，会将这个错误传递给一个Observable(记作o2),而这个o2会作为参数传给notificationHandler。因为notificationHandler 返回的也是一个Observable(o3),如果o3 后续发射了complete或者error事件（其实就是调用了onComplete或者onError），那么会导致child subscription 也调用onComplete或者onError,结束整个流程，不然的话（也就是调用了onNext），那么将会重新订阅源Observable——————也就是再次激活源Oservable。\n\n 翻译的有点啰嗦。简而言之就是，我用一个代理Subscriber去订阅源Obsevable，从源Observable获取数据，没有发生错误的情况下，就和一个普通正常的Observable的一样，数据发射完了就结束了。不同的是，头可能发生错误，抛出异常，针对这种情况，我们选择怎么处理。给我们的处理方式就是，我给你一个Observable<Throwable>,当源Observable发射错误事件的时候，下游想从源Observable重新尝试订阅（也就是retry的含义）。而repeatWhen则只是稍微不同，repeatWhen响应的是源Observable的complete事件，就是当数据发射完了，是否重新订阅，重复的从源Observable获取数据。\n\n###  使用\n```java\n           \n           retryCount = 0\n            Observable.create(new Observable.OnSubscribe<Integer>() {\n            public void call(Subscriber<? super Integer> subscriber) {\n                subscriber.onNext(1 / 0);\n                subscriber.onCompleted();\n            }\n        }).retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {\n            public Observable<?> call(Observable<? extends Throwable> err) {\n                return err\n                        .flatMap(new Func1<Throwable, Observable<?>>() {\n                            public Observable<?> call(Throwable throwable) {\n                                System.out.println(throwable);\n                                if (throwable instanceof ArithmeticException && retryCount < 3) {\n                                    System.out.println(\"retry ++\");\n                                    retryCount++;\n                                    return Observable.just(\"\");\n                                } else {\n                                    System.out.println(\"no retry\");\n                                    return Observable.empty();\n                                }\n                            }\n                        });\n\n            }\n        })\n```\n创建了一个必然抛出算术异常的Observable。重试的逻辑是超过三次就放弃重试。这里是直接Observable.just(\"\")触发的重试，以及Observable.empty()结束整个流程\n\n这样写是没问题的，但是既然是返回Observable，那么我直接 这样：\n```java\n    retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {\n\n            public Observable<?> call(Observable<? extends Throwable> err) {\n\n                                if (throwable instanceof ArithmeticException && retryCount < 3) {\n                                    System.out.println(\"retry ++\");\n                                    retryCount++;\n                                    return Observable.just(\"\");\n                                } else {\n                                    System.out.println(\"no retry\");\n                                    return Observable.empty();\n                                }\n            }\n\n        })\n```\n\n当然是不可以的，这样的话是返回一个和err无关的Observable，Observable.just(\"\") 和Observable.empty()把事件发射完毕后，整个流程也就结束了，我们的订阅者也会取消订阅，不再接收消息。所以根本就是没有发挥这个操作符的效果。那么为什么我不使用参数err 这个Observable就会无效？\n\n\n### 源码分析\n为了搞清楚为什么我们不使用传入的err这个Observable，就会导致retryWhen操作符失效，还是从方法本身入手\n\nretryWhen方法实际返回的是这个\n```java\n  OnSubscribeRedo.<T>retry(this, InternalObservableUtils.createRetryDematerializer(notificationHandler));\n```\n InternalObservableUtils.createRetryDematerializer(notificationHandler) 这句代码的实际返回的是\n 一个 RetryNotificationDematerializer 作用是把Observable<Notification>转换成Observable<Throwable> ，然后传给我们自己定义的notificationHandler作为参数 然后返回一个新的Observable\n\n==========go on 2108.8.10(今天又看了下，又有新的发现，之前的分析漏了点东西，不过也更加发觉 1.x版本的一些东西确实写的复杂了，结构不清晰)\n\n继续看内部逻辑（省略一些过于细节的细节[不然语言又是罗哩罗嗦]，需要对源码比较熟悉，最好先看一遍）：\n    \n    ```java\n   final Subject<Notification<?>, Notification<?>> terminals = BehaviorSubject.<Notification<?>>create().toSerialized();\n   final Subscriber<Notification<?>> dummySubscriber = Subscribers.empty();\n        // subscribe immediately so the last emission will be replayed to the next\n        // subscriber (which is the one we care about)\n   terminals.subscribe(dummySubscriber);\n    ```\n被 这三句话坑了很久，还让我看了BehaviorSubject的源码很久，发现这几句就是废话，有没有都行。看他的注释，意思是为了后面我们关心的subscriber能够获取到最近的那个事件，先订阅再说。（实际上最近的那个事件根本不存在）\n\n\n```java\nfinal Action0 subscribeToSource = new Action0() {\n            @Override\n            public void call() {\n                Subscriber<T> terminalDelegatingSubscriber = new Subscriber<T>() {\n                    boolean done;\n\n                    @Override\n                    public void onCompleted() {\n                        if (!done) {\n                            done = true;\n                            unsubscribe();\n                            terminals.onNext(Notification.createOnCompleted());\n                        }\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        if (!done) {\n                            done = true;\n                            unsubscribe();\n                            terminals.onNext(Notification.createOnError(e));\n                        }\n                    }\n\n                    @Override\n                    public void onNext(T v) {\n                        if (!done) {\n                            child.onNext(v);\n                            decrementConsumerCapacity();\n                            arbiter.produced(1);\n                        }\n                    }\n                };\n            }\n        };\n```\n精简了n多代码。这个subscribeToSource Action0的意思就是 新建了一个terminalDelegatingSubscriber订阅源Observable，就是一个代理订阅者，主要的目的是关注源Observable发出的complet 和error事件。为什么是关注complete和error呢，因为这前面说过retryWhen和repeatWhen本质上的逻辑是一样的，只不过retryWhen关注的是\nerror,repeatWhen关注是complete。complete 和error都被包装成了Notification，然后发射出去。\n\n继续：\n```java\nfinal Observable<?> restarts = controlHandlerFunction.call(\n                terminals.lift(new Operator<Notification<?>, Notification<?>>() {\n                    @Override\n                    public Subscriber<? super Notification<?>> call(final Subscriber<? super Notification<?>> filteredTerminals) {\n                        return new Subscriber<Notification<?>>(filteredTerminals) {\n                            @Override\n                            public void onCompleted() {\n                                filteredTerminals.onCompleted();\n                            }\n\n                            @Override\n                            public void onError(Throwable e) {\n                                filteredTerminals.onError(e);\n                            }\n\n                            @Override\n                            public void onNext(Notification<?> t) {\n                                if (t.isOnCompleted() && stopOnComplete) {\n                                    filteredTerminals.onCompleted();\n                                } else if (t.isOnError() && stopOnError) {\n                                    filteredTerminals.onError(t.getThrowable());\n                                } else {\n                                    filteredTerminals.onNext(t);\n                                }\n                            }\n\n                            @Override\n                            public void setProducer(Producer producer) {\n                                producer.request(Long.MAX_VALUE);\n                            }\n                        };\n                    }\n                }));\n```\n\n这里稍微复杂一点，从里往外看，里面是terminals.lift操作了一下，主要逻辑在返回的新的Subscribeder的onNext这里，也就是对前面发过来的\nNotificaiton拦截判断处理一下。一共有三种情况（其实就是决定retry和repeat的地方）：\n\n 1) t.isOnCompleted() && stopOnComplete 条件如果满足 对应的是retryWhen 结束不会重试\n 2）t.isOnError() && stopOnError 条件满足 对应的是repeatWhen 结束，不会重复\n 3）这种情况下我们针对retryWhen看，如果收到的是一个error事件，很明显前面两个条件都不会满足，直接来到这里，调用onNext,传递给下游\n\n我们把这个terminal.lift之后得到的Observable记作 o1。之后这个o1会作为参数传递给我们的controlHandler\n 。前面说过这个controlHandler不是我们自己定义的那个notificationHandler，而是经过包装之后的RetryNotificationDematerializer。所以controlHandler.call(o1)这句代码展开就是：\n\n ```java\n    notificationHandler.call(o1.map(ERROR_EXTRACTOR))\n ```\n 进一步展开：\n\n ```java\n    notificationHanlder.call(o1.map(new Func1<Notification<?>, Throwable> {\n        @Override\n        public Throwable call(Notification<?> t) {\n            return t.getThrowable();\n        }\n    }))\n ```\n\n所以我们定义的notificationHandler里的Observable<Throwable>是这么来的。加上我们自己添加的逻辑之后返回一个名为restarts的Observable\n\n最后，schedule了一个匿名的任务Action0:\n```java\n     worker.schedule(new Action0() {\n            @Override\n            public void call() {\n                restarts.unsafeSubscribe(new Subscriber<Object>(child) {\n\n                    @Override\n                    public void onNext(Object t) {\n                        if (!child.isUnsubscribed()) {\n                           \n                            if (consumerCapacity.get() > 0) {\n                                worker.schedule(subscribeToSource);\n                            } else {\n                                resumeBoundary.compareAndSet(false, true);\n                            }\n                        }\n                    }\n                });\n            }\n        });\n```\n注意这个任务让restarts进行订阅（为了方便起见，我们把这个匿名的Subscriber记为s1），然后在收到next事件的时候，执行前面的subscribeToSource任务，也就是向源Observable发起订阅的任务。\n\n那么这里的bug出现了，该怎么触发subscribeToSource这个任务呢？？？？？？？ 我们可以从后往前推，要触发这个subscribeToSource必须上游\n调用onNext吐出事件来，而这里的上游就是restarts,也就是terminals terminals要吐出事件来，必须依赖源Observable吐出事件, 这里就形成了一个互相依赖的困境！！<!-- restarts是什么？是我们自己对传入的err那个Observable做变换以后返回的，所以如果我们做的变换逻辑里面如果发出了事件，那么才会导致这里 s1的onNext进行调用 -->\ntermials本身既是Observable也是一个Observer,所以terminals.lift 的目的是对自己发出的事件进行拦截 ，但是自己一开始并没有发出事件，然后把这个lift之后的ob传给我们定义的notificationHandler，所以——————最开始的事件还是必须由我们发出来！！\n\n其实是child.setProducer那一行，会导致调用request(Long.MAX_VALUE)，导致subscribeToSource被调用了\n所以入口就是这句话，然后发生错误，会回调到我们自定义的错误处理逻辑那里，我们前面提到过，为什么不使用传入的err会导致无效，\n因为整个链式调用断开了，返回的restarts是我们自己的Observable，那么导致的结果就是，我们用自己的Observable订阅了那个匿名Subscriber，\n可能调用一次onNext，然后就结束了。虽然后面确实会调用work.schedule(subscribeToSource)那一行代码，但是由于child已经结束了，订阅关系没了，这个subscribeToSource是不会执行的。但是如果换成是对err进行变换返回的Observable就不一样了，在接收到源Observable 发来的error的时候，会往下传递，一直走到我们的对error处理的逻辑，如果我们的处理是返回了一个Observable.just(\"\")之类的，那么下游必然会接收到，也就是在匿名Subscriber那里的onNext调用，导致重新订阅源Observable，不然的话调用onComplete或者onError结束整个流程。\n\n\n最后我也看了 2.0.0的retryWhen的代码，做了很多修改，整体上来看，结构更加的清晰更容易看明白。所以建议直接看2.0.0的，没有这么绕。\n\n===写的太乱了（Rx确实有些绕，绕明白了，还是很好理解的）==不定期修改此博文\n","source":"_posts/Rxjava-retryWhen和repeatWhen操作符原理.md","raw":"---\ntitle: Rxjava retryWhen和repeatWhen操作符原理\ndate: 2018-08-08 16:29:42\ntags: \n    - Rxjava\n    - Operator\n---\n### 契机\n因为最近使用了mvvm，不再用mvp,并且大量使用RxJava 简化一些场景下的操作。以至发现了一个操作符retryWhen，搜了一些资料，几乎都是 一位叫DanLew的外国人写的一篇文章或者其译文。原文在这[ >> ](https://blog.danlew.net/2016/01/25/rxjavas-repeatwhen-and-retrywhen-explained/),思路清晰，知道了怎么用，一些关键的注意点，但就是没有分析具体原理和流程是怎样(但是看他提到的一些词，应该是搞明白了内部原理的)。痛定思痛————当然也是觉得这个操作符非常有意思，所以仔细研究一番。（说实话，我也是最近才觉得RxJava有些源码真的值得好好翻一翻）。本文基于rxjava 1.3.8。\n\n### retryWhen和repeatWhen真的不一样吗\n先看下retryWhen的方法：\n```java\n      public final Observable<T> retryWhen(final Func1<Observable<Throwable>,Observable> notificationHandler) {\n        return OnSubscribeRedo.<T>retry(this, InternalObservableUtils.createRetryDematerializer(notificationHandler));\n    }\n```\n再看repeatWhen:\n```java\n     public final Observable<T> repeatWhen(final Func1<Observable< Void>, Observable> notificationHandler) {\n        return OnSubscribeRedo.repeat(this, \n        InternalObservableUtils.createRepeatDematerializer(notificationHandler));\n    }\n```\n 几乎可以认为是一样的，除了对传入的handler处理稍微不同以外。另外参数上有点小不一样，retryWhen的参数内的泛型是Observable<Throwable>,\n repeatWhen的参数泛型则是Observable<Void>。这和两者响应的事件不一样，retry是对错误响应，发生错误了该选择是否重试；repeat则是对完成事件响应，数据发射完之后是否重试，完成事件是没有数据的所以是Void。\n\n不过我看到这个方法最大的两个疑惑是：为什么不是Func1<Throwable,Boolean>类型的参数，根据给的异常返回true false决定是否重试不是很合理吗？？然后马上反应过来，返回Observable会更灵活，如果重试的逻辑很复杂，单纯根据一个bool 的true or false来决定是否重试，是满足不了一些场景下的需要的。\n\n retryWhen方法上有一段注释：\n ```html\n    Returns an Observable that emits the same values as the source observable with the exception of an {@code onError}. An {@code onError} notification from the source will result in the emission of a{@link Throwable} item to the Observable provided as an argument to the {@code notificationHandler}\n    function. If that Observable calls {@code onComplete} or {@code onError} then {@code retry} will call {@code onCompleted} or {@code onError} on the child subscription. Otherwise, this Observable will resubscribe to the source Observable.\n ```\n 具体含义就是，这个操作符会返回一个Observable(记作o1),o1会发射和源observable一样的数据（源observable可能会抛出异常）。当源Observable 发射错误事件时，会将这个错误传递给一个Observable(记作o2),而这个o2会作为参数传给notificationHandler。因为notificationHandler 返回的也是一个Observable(o3),如果o3 后续发射了complete或者error事件（其实就是调用了onComplete或者onError），那么会导致child subscription 也调用onComplete或者onError,结束整个流程，不然的话（也就是调用了onNext），那么将会重新订阅源Observable——————也就是再次激活源Oservable。\n\n 翻译的有点啰嗦。简而言之就是，我用一个代理Subscriber去订阅源Obsevable，从源Observable获取数据，没有发生错误的情况下，就和一个普通正常的Observable的一样，数据发射完了就结束了。不同的是，头可能发生错误，抛出异常，针对这种情况，我们选择怎么处理。给我们的处理方式就是，我给你一个Observable<Throwable>,当源Observable发射错误事件的时候，下游想从源Observable重新尝试订阅（也就是retry的含义）。而repeatWhen则只是稍微不同，repeatWhen响应的是源Observable的complete事件，就是当数据发射完了，是否重新订阅，重复的从源Observable获取数据。\n\n###  使用\n```java\n           \n           retryCount = 0\n            Observable.create(new Observable.OnSubscribe<Integer>() {\n            public void call(Subscriber<? super Integer> subscriber) {\n                subscriber.onNext(1 / 0);\n                subscriber.onCompleted();\n            }\n        }).retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {\n            public Observable<?> call(Observable<? extends Throwable> err) {\n                return err\n                        .flatMap(new Func1<Throwable, Observable<?>>() {\n                            public Observable<?> call(Throwable throwable) {\n                                System.out.println(throwable);\n                                if (throwable instanceof ArithmeticException && retryCount < 3) {\n                                    System.out.println(\"retry ++\");\n                                    retryCount++;\n                                    return Observable.just(\"\");\n                                } else {\n                                    System.out.println(\"no retry\");\n                                    return Observable.empty();\n                                }\n                            }\n                        });\n\n            }\n        })\n```\n创建了一个必然抛出算术异常的Observable。重试的逻辑是超过三次就放弃重试。这里是直接Observable.just(\"\")触发的重试，以及Observable.empty()结束整个流程\n\n这样写是没问题的，但是既然是返回Observable，那么我直接 这样：\n```java\n    retryWhen(new Func1<Observable<? extends Throwable>, Observable<?>>() {\n\n            public Observable<?> call(Observable<? extends Throwable> err) {\n\n                                if (throwable instanceof ArithmeticException && retryCount < 3) {\n                                    System.out.println(\"retry ++\");\n                                    retryCount++;\n                                    return Observable.just(\"\");\n                                } else {\n                                    System.out.println(\"no retry\");\n                                    return Observable.empty();\n                                }\n            }\n\n        })\n```\n\n当然是不可以的，这样的话是返回一个和err无关的Observable，Observable.just(\"\") 和Observable.empty()把事件发射完毕后，整个流程也就结束了，我们的订阅者也会取消订阅，不再接收消息。所以根本就是没有发挥这个操作符的效果。那么为什么我不使用参数err 这个Observable就会无效？\n\n\n### 源码分析\n为了搞清楚为什么我们不使用传入的err这个Observable，就会导致retryWhen操作符失效，还是从方法本身入手\n\nretryWhen方法实际返回的是这个\n```java\n  OnSubscribeRedo.<T>retry(this, InternalObservableUtils.createRetryDematerializer(notificationHandler));\n```\n InternalObservableUtils.createRetryDematerializer(notificationHandler) 这句代码的实际返回的是\n 一个 RetryNotificationDematerializer 作用是把Observable<Notification>转换成Observable<Throwable> ，然后传给我们自己定义的notificationHandler作为参数 然后返回一个新的Observable\n\n==========go on 2108.8.10(今天又看了下，又有新的发现，之前的分析漏了点东西，不过也更加发觉 1.x版本的一些东西确实写的复杂了，结构不清晰)\n\n继续看内部逻辑（省略一些过于细节的细节[不然语言又是罗哩罗嗦]，需要对源码比较熟悉，最好先看一遍）：\n    \n    ```java\n   final Subject<Notification<?>, Notification<?>> terminals = BehaviorSubject.<Notification<?>>create().toSerialized();\n   final Subscriber<Notification<?>> dummySubscriber = Subscribers.empty();\n        // subscribe immediately so the last emission will be replayed to the next\n        // subscriber (which is the one we care about)\n   terminals.subscribe(dummySubscriber);\n    ```\n被 这三句话坑了很久，还让我看了BehaviorSubject的源码很久，发现这几句就是废话，有没有都行。看他的注释，意思是为了后面我们关心的subscriber能够获取到最近的那个事件，先订阅再说。（实际上最近的那个事件根本不存在）\n\n\n```java\nfinal Action0 subscribeToSource = new Action0() {\n            @Override\n            public void call() {\n                Subscriber<T> terminalDelegatingSubscriber = new Subscriber<T>() {\n                    boolean done;\n\n                    @Override\n                    public void onCompleted() {\n                        if (!done) {\n                            done = true;\n                            unsubscribe();\n                            terminals.onNext(Notification.createOnCompleted());\n                        }\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        if (!done) {\n                            done = true;\n                            unsubscribe();\n                            terminals.onNext(Notification.createOnError(e));\n                        }\n                    }\n\n                    @Override\n                    public void onNext(T v) {\n                        if (!done) {\n                            child.onNext(v);\n                            decrementConsumerCapacity();\n                            arbiter.produced(1);\n                        }\n                    }\n                };\n            }\n        };\n```\n精简了n多代码。这个subscribeToSource Action0的意思就是 新建了一个terminalDelegatingSubscriber订阅源Observable，就是一个代理订阅者，主要的目的是关注源Observable发出的complet 和error事件。为什么是关注complete和error呢，因为这前面说过retryWhen和repeatWhen本质上的逻辑是一样的，只不过retryWhen关注的是\nerror,repeatWhen关注是complete。complete 和error都被包装成了Notification，然后发射出去。\n\n继续：\n```java\nfinal Observable<?> restarts = controlHandlerFunction.call(\n                terminals.lift(new Operator<Notification<?>, Notification<?>>() {\n                    @Override\n                    public Subscriber<? super Notification<?>> call(final Subscriber<? super Notification<?>> filteredTerminals) {\n                        return new Subscriber<Notification<?>>(filteredTerminals) {\n                            @Override\n                            public void onCompleted() {\n                                filteredTerminals.onCompleted();\n                            }\n\n                            @Override\n                            public void onError(Throwable e) {\n                                filteredTerminals.onError(e);\n                            }\n\n                            @Override\n                            public void onNext(Notification<?> t) {\n                                if (t.isOnCompleted() && stopOnComplete) {\n                                    filteredTerminals.onCompleted();\n                                } else if (t.isOnError() && stopOnError) {\n                                    filteredTerminals.onError(t.getThrowable());\n                                } else {\n                                    filteredTerminals.onNext(t);\n                                }\n                            }\n\n                            @Override\n                            public void setProducer(Producer producer) {\n                                producer.request(Long.MAX_VALUE);\n                            }\n                        };\n                    }\n                }));\n```\n\n这里稍微复杂一点，从里往外看，里面是terminals.lift操作了一下，主要逻辑在返回的新的Subscribeder的onNext这里，也就是对前面发过来的\nNotificaiton拦截判断处理一下。一共有三种情况（其实就是决定retry和repeat的地方）：\n\n 1) t.isOnCompleted() && stopOnComplete 条件如果满足 对应的是retryWhen 结束不会重试\n 2）t.isOnError() && stopOnError 条件满足 对应的是repeatWhen 结束，不会重复\n 3）这种情况下我们针对retryWhen看，如果收到的是一个error事件，很明显前面两个条件都不会满足，直接来到这里，调用onNext,传递给下游\n\n我们把这个terminal.lift之后得到的Observable记作 o1。之后这个o1会作为参数传递给我们的controlHandler\n 。前面说过这个controlHandler不是我们自己定义的那个notificationHandler，而是经过包装之后的RetryNotificationDematerializer。所以controlHandler.call(o1)这句代码展开就是：\n\n ```java\n    notificationHandler.call(o1.map(ERROR_EXTRACTOR))\n ```\n 进一步展开：\n\n ```java\n    notificationHanlder.call(o1.map(new Func1<Notification<?>, Throwable> {\n        @Override\n        public Throwable call(Notification<?> t) {\n            return t.getThrowable();\n        }\n    }))\n ```\n\n所以我们定义的notificationHandler里的Observable<Throwable>是这么来的。加上我们自己添加的逻辑之后返回一个名为restarts的Observable\n\n最后，schedule了一个匿名的任务Action0:\n```java\n     worker.schedule(new Action0() {\n            @Override\n            public void call() {\n                restarts.unsafeSubscribe(new Subscriber<Object>(child) {\n\n                    @Override\n                    public void onNext(Object t) {\n                        if (!child.isUnsubscribed()) {\n                           \n                            if (consumerCapacity.get() > 0) {\n                                worker.schedule(subscribeToSource);\n                            } else {\n                                resumeBoundary.compareAndSet(false, true);\n                            }\n                        }\n                    }\n                });\n            }\n        });\n```\n注意这个任务让restarts进行订阅（为了方便起见，我们把这个匿名的Subscriber记为s1），然后在收到next事件的时候，执行前面的subscribeToSource任务，也就是向源Observable发起订阅的任务。\n\n那么这里的bug出现了，该怎么触发subscribeToSource这个任务呢？？？？？？？ 我们可以从后往前推，要触发这个subscribeToSource必须上游\n调用onNext吐出事件来，而这里的上游就是restarts,也就是terminals terminals要吐出事件来，必须依赖源Observable吐出事件, 这里就形成了一个互相依赖的困境！！<!-- restarts是什么？是我们自己对传入的err那个Observable做变换以后返回的，所以如果我们做的变换逻辑里面如果发出了事件，那么才会导致这里 s1的onNext进行调用 -->\ntermials本身既是Observable也是一个Observer,所以terminals.lift 的目的是对自己发出的事件进行拦截 ，但是自己一开始并没有发出事件，然后把这个lift之后的ob传给我们定义的notificationHandler，所以——————最开始的事件还是必须由我们发出来！！\n\n其实是child.setProducer那一行，会导致调用request(Long.MAX_VALUE)，导致subscribeToSource被调用了\n所以入口就是这句话，然后发生错误，会回调到我们自定义的错误处理逻辑那里，我们前面提到过，为什么不使用传入的err会导致无效，\n因为整个链式调用断开了，返回的restarts是我们自己的Observable，那么导致的结果就是，我们用自己的Observable订阅了那个匿名Subscriber，\n可能调用一次onNext，然后就结束了。虽然后面确实会调用work.schedule(subscribeToSource)那一行代码，但是由于child已经结束了，订阅关系没了，这个subscribeToSource是不会执行的。但是如果换成是对err进行变换返回的Observable就不一样了，在接收到源Observable 发来的error的时候，会往下传递，一直走到我们的对error处理的逻辑，如果我们的处理是返回了一个Observable.just(\"\")之类的，那么下游必然会接收到，也就是在匿名Subscriber那里的onNext调用，导致重新订阅源Observable，不然的话调用onComplete或者onError结束整个流程。\n\n\n最后我也看了 2.0.0的retryWhen的代码，做了很多修改，整体上来看，结构更加的清晰更容易看明白。所以建议直接看2.0.0的，没有这么绕。\n\n===写的太乱了（Rx确实有些绕，绕明白了，还是很好理解的）==不定期修改此博文\n","slug":"Rxjava-retryWhen和repeatWhen操作符原理","published":1,"updated":"2018-08-16T01:26:41.674Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl1qvapp000gy472ctenmgvp","content":"<h3 id=\"契机\"><a href=\"#契机\" class=\"headerlink\" title=\"契机\"></a>契机</h3><p>因为最近使用了mvvm，不再用mvp,并且大量使用RxJava 简化一些场景下的操作。以至发现了一个操作符retryWhen，搜了一些资料，几乎都是 一位叫DanLew的外国人写的一篇文章或者其译文。原文在这<a href=\"https://blog.danlew.net/2016/01/25/rxjavas-repeatwhen-and-retrywhen-explained/\" target=\"_blank\" rel=\"external\"> &gt;&gt; </a>,思路清晰，知道了怎么用，一些关键的注意点，但就是没有分析具体原理和流程是怎样(但是看他提到的一些词，应该是搞明白了内部原理的)。痛定思痛————当然也是觉得这个操作符非常有意思，所以仔细研究一番。（说实话，我也是最近才觉得RxJava有些源码真的值得好好翻一翻）。本文基于rxjava 1.3.8。</p>\n<h3 id=\"retryWhen和repeatWhen真的不一样吗\"><a href=\"#retryWhen和repeatWhen真的不一样吗\" class=\"headerlink\" title=\"retryWhen和repeatWhen真的不一样吗\"></a>retryWhen和repeatWhen真的不一样吗</h3><p>先看下retryWhen的方法：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">      <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> Observable<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">retryWhen</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> Func1<span class=\"token operator\">&lt;</span>Observable<span class=\"token operator\">&lt;</span>Throwable<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>Observable<span class=\"token operator\">></span> notificationHandler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> OnSubscribeRedo<span class=\"token punctuation\">.</span>&lt;T<span class=\"token operator\">></span><span class=\"token function\">retry</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> InternalObservableUtils<span class=\"token punctuation\">.</span><span class=\"token function\">createRetryDematerializer</span><span class=\"token punctuation\">(</span>notificationHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>再看repeatWhen:</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">     <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> Observable<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">repeatWhen</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> Func1<span class=\"token operator\">&lt;</span>Observable<span class=\"token operator\">&lt;</span> Void<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> Observable<span class=\"token operator\">></span> notificationHandler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> OnSubscribeRedo<span class=\"token punctuation\">.</span><span class=\"token function\">repeat</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> \n        InternalObservableUtils<span class=\"token punctuation\">.</span><span class=\"token function\">createRepeatDematerializer</span><span class=\"token punctuation\">(</span>notificationHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p> 几乎可以认为是一样的，除了对传入的handler处理稍微不同以外。另外参数上有点小不一样，retryWhen的参数内的泛型是Observable<throwable>,<br> repeatWhen的参数泛型则是Observable<void>。这和两者响应的事件不一样，retry是对错误响应，发生错误了该选择是否重试；repeat则是对完成事件响应，数据发射完之后是否重试，完成事件是没有数据的所以是Void。</void></throwable></p>\n<p>不过我看到这个方法最大的两个疑惑是：为什么不是Func1<throwable,boolean>类型的参数，根据给的异常返回true false决定是否重试不是很合理吗？？然后马上反应过来，返回Observable会更灵活，如果重试的逻辑很复杂，单纯根据一个bool 的true or false来决定是否重试，是满足不了一些场景下的需要的。</throwable,boolean></p>\n<p> retryWhen方法上有一段注释：</p>\n<pre class=\"line-numbers language-html\"><code class=\"language-html\">    Returns an Observable that emits the same values as the source observable with the exception of an {@code onError}. An {@code onError} notification from the source will result in the emission of a{@link Throwable} item to the Observable provided as an argument to the {@code notificationHandler}\n    function. If that Observable calls {@code onComplete} or {@code onError} then {@code retry} will call {@code onCompleted} or {@code onError} on the child subscription. Otherwise, this Observable will resubscribe to the source Observable.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<p> 具体含义就是，这个操作符会返回一个Observable(记作o1),o1会发射和源observable一样的数据（源observable可能会抛出异常）。当源Observable 发射错误事件时，会将这个错误传递给一个Observable(记作o2),而这个o2会作为参数传给notificationHandler。因为notificationHandler 返回的也是一个Observable(o3),如果o3 后续发射了complete或者error事件（其实就是调用了onComplete或者onError），那么会导致child subscription 也调用onComplete或者onError,结束整个流程，不然的话（也就是调用了onNext），那么将会重新订阅源Observable——————也就是再次激活源Oservable。</p>\n<p> 翻译的有点啰嗦。简而言之就是，我用一个代理Subscriber去订阅源Obsevable，从源Observable获取数据，没有发生错误的情况下，就和一个普通正常的Observable的一样，数据发射完了就结束了。不同的是，头可能发生错误，抛出异常，针对这种情况，我们选择怎么处理。给我们的处理方式就是，我给你一个Observable<throwable>,当源Observable发射错误事件的时候，下游想从源Observable重新尝试订阅（也就是retry的含义）。而repeatWhen则只是稍微不同，repeatWhen响应的是源Observable的complete事件，就是当数据发射完了，是否重新订阅，重复的从源Observable获取数据。</throwable></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><pre class=\"line-numbers language-java\"><code class=\"language-java\">\n           retryCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n            Observable<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Observable<span class=\"token punctuation\">.</span>OnSubscribe</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>Subscriber<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> Integer<span class=\"token operator\">></span> subscriber<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                subscriber<span class=\"token punctuation\">.</span><span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">/</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                subscriber<span class=\"token punctuation\">.</span><span class=\"token function\">onCompleted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">retryWhen</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Func1</span><span class=\"token operator\">&lt;</span>Observable<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Throwable</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> Observable<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">public</span> Observable<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>Observable<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Throwable</span><span class=\"token operator\">></span> err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> err\n                        <span class=\"token punctuation\">.</span><span class=\"token function\">flatMap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Func1</span><span class=\"token operator\">&lt;</span>Throwable<span class=\"token punctuation\">,</span> Observable<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                            <span class=\"token keyword\">public</span> Observable<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>Throwable throwable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>throwable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>throwable <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">ArithmeticException</span> <span class=\"token operator\">&amp;&amp;</span> retryCount <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"retry ++\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                    retryCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                                    <span class=\"token keyword\">return</span> Observable<span class=\"token punctuation\">.</span><span class=\"token function\">just</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"no retry\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                    <span class=\"token keyword\">return</span> Observable<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token punctuation\">}</span>\n                            <span class=\"token punctuation\">}</span>\n                        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>创建了一个必然抛出算术异常的Observable。重试的逻辑是超过三次就放弃重试。这里是直接Observable.just(“”)触发的重试，以及Observable.empty()结束整个流程</p>\n<p>这样写是没问题的，但是既然是返回Observable，那么我直接 这样：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">    <span class=\"token function\">retryWhen</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Func1</span><span class=\"token operator\">&lt;</span>Observable<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Throwable</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> Observable<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n            <span class=\"token keyword\">public</span> Observable<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>Observable<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Throwable</span><span class=\"token operator\">></span> err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n                                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>throwable <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">ArithmeticException</span> <span class=\"token operator\">&amp;&amp;</span> retryCount <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"retry ++\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                    retryCount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                                    <span class=\"token keyword\">return</span> Observable<span class=\"token punctuation\">.</span><span class=\"token function\">just</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"no retry\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                    <span class=\"token keyword\">return</span> Observable<span class=\"token punctuation\">.</span><span class=\"token function\">empty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>当然是不可以的，这样的话是返回一个和err无关的Observable，Observable.just(“”) 和Observable.empty()把事件发射完毕后，整个流程也就结束了，我们的订阅者也会取消订阅，不再接收消息。所以根本就是没有发挥这个操作符的效果。那么为什么我不使用参数err 这个Observable就会无效？</p>\n<h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>为了搞清楚为什么我们不使用传入的err这个Observable，就会导致retryWhen操作符失效，还是从方法本身入手</p>\n<p>retryWhen方法实际返回的是这个</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">  OnSubscribeRedo<span class=\"token punctuation\">.</span>&lt;T<span class=\"token operator\">></span><span class=\"token function\">retry</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> InternalObservableUtils<span class=\"token punctuation\">.</span><span class=\"token function\">createRetryDematerializer</span><span class=\"token punctuation\">(</span>notificationHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p> InternalObservableUtils.createRetryDematerializer(notificationHandler) 这句代码的实际返回的是<br> 一个 RetryNotificationDematerializer 作用是把Observable<notification>转换成Observable<throwable> ，然后传给我们自己定义的notificationHandler作为参数 然后返回一个新的Observable</throwable></notification></p>\n<p>==========go on 2108.8.10(今天又看了下，又有新的发现，之前的分析漏了点东西，不过也更加发觉 1.x版本的一些东西确实写的复杂了，结构不清晰)</p>\n<p>继续看内部逻辑（省略一些过于细节的细节[不然语言又是罗哩罗嗦]，需要对源码比较熟悉，最好先看一遍）：</p>\n<pre><code>```java\n</code></pre><p>   final Subject<notification<?>, Notification&lt;?&gt;&gt; terminals = BehaviorSubject.<notification<?>&gt;create().toSerialized();<br>   final Subscriber<notification<?>&gt; dummySubscriber = Subscribers.empty();<br>        // subscribe immediately so the last emission will be replayed to the next<br>        // subscriber (which is the one we care about)<br>   terminals.subscribe(dummySubscriber);</notification<?></notification<?></notification<?></p>\n<pre><code>```\n</code></pre><p>被 这三句话坑了很久，还让我看了BehaviorSubject的源码很久，发现这几句就是废话，有没有都行。看他的注释，意思是为了后面我们关心的subscriber能够获取到最近的那个事件，先订阅再说。（实际上最近的那个事件根本不存在）</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">final</span> Action0 subscribeToSource <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Action0</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                Subscriber<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> terminalDelegatingSubscriber <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Subscriber</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">boolean</span> done<span class=\"token punctuation\">;</span>\n\n                    <span class=\"token annotation punctuation\">@Override</span>\n                    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onCompleted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>done<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                            done <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token function\">unsubscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            terminals<span class=\"token punctuation\">.</span><span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span>Notification<span class=\"token punctuation\">.</span><span class=\"token function\">createOnCompleted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token punctuation\">}</span>\n                    <span class=\"token punctuation\">}</span>\n\n                    <span class=\"token annotation punctuation\">@Override</span>\n                    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>Throwable e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>done<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                            done <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token function\">unsubscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            terminals<span class=\"token punctuation\">.</span><span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span>Notification<span class=\"token punctuation\">.</span><span class=\"token function\">createOnError</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token punctuation\">}</span>\n                    <span class=\"token punctuation\">}</span>\n\n                    <span class=\"token annotation punctuation\">@Override</span>\n                    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span>T v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>done<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                            child<span class=\"token punctuation\">.</span><span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token function\">decrementConsumerCapacity</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            arbiter<span class=\"token punctuation\">.</span><span class=\"token function\">produced</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token punctuation\">}</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>精简了n多代码。这个subscribeToSource Action0的意思就是 新建了一个terminalDelegatingSubscriber订阅源Observable，就是一个代理订阅者，主要的目的是关注源Observable发出的complet 和error事件。为什么是关注complete和error呢，因为这前面说过retryWhen和repeatWhen本质上的逻辑是一样的，只不过retryWhen关注的是<br>error,repeatWhen关注是complete。complete 和error都被包装成了Notification，然后发射出去。</p>\n<p>继续：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token keyword\">final</span> Observable<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> restarts <span class=\"token operator\">=</span> controlHandlerFunction<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>\n                terminals<span class=\"token punctuation\">.</span><span class=\"token function\">lift</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Operator</span><span class=\"token operator\">&lt;</span>Notification<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> Notification<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token annotation punctuation\">@Override</span>\n                    <span class=\"token keyword\">public</span> Subscriber<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> Notification<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">>></span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> Subscriber<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> Notification<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">>></span> filteredTerminals<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Subscriber</span><span class=\"token operator\">&lt;</span>Notification<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">>></span><span class=\"token punctuation\">(</span>filteredTerminals<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                            <span class=\"token annotation punctuation\">@Override</span>\n                            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onCompleted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                filteredTerminals<span class=\"token punctuation\">.</span><span class=\"token function\">onCompleted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token punctuation\">}</span>\n\n                            <span class=\"token annotation punctuation\">@Override</span>\n                            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>Throwable e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                filteredTerminals<span class=\"token punctuation\">.</span><span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token punctuation\">}</span>\n\n                            <span class=\"token annotation punctuation\">@Override</span>\n                            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span>Notification<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span><span class=\"token function\">isOnCompleted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> stopOnComplete<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                    filteredTerminals<span class=\"token punctuation\">.</span><span class=\"token function\">onCompleted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span><span class=\"token function\">isOnError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> stopOnError<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                    filteredTerminals<span class=\"token punctuation\">.</span><span class=\"token function\">onError</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span><span class=\"token function\">getThrowable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                                    filteredTerminals<span class=\"token punctuation\">.</span><span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                <span class=\"token punctuation\">}</span>\n                            <span class=\"token punctuation\">}</span>\n\n                            <span class=\"token annotation punctuation\">@Override</span>\n                            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setProducer</span><span class=\"token punctuation\">(</span>Producer producer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                producer<span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span>Long<span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token punctuation\">}</span>\n                        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里稍微复杂一点，从里往外看，里面是terminals.lift操作了一下，主要逻辑在返回的新的Subscribeder的onNext这里，也就是对前面发过来的<br>Notificaiton拦截判断处理一下。一共有三种情况（其实就是决定retry和repeat的地方）：</p>\n<p> 1) t.isOnCompleted() &amp;&amp; stopOnComplete 条件如果满足 对应的是retryWhen 结束不会重试<br> 2）t.isOnError() &amp;&amp; stopOnError 条件满足 对应的是repeatWhen 结束，不会重复<br> 3）这种情况下我们针对retryWhen看，如果收到的是一个error事件，很明显前面两个条件都不会满足，直接来到这里，调用onNext,传递给下游</p>\n<p>我们把这个terminal.lift之后得到的Observable记作 o1。之后这个o1会作为参数传递给我们的controlHandler<br> 。前面说过这个controlHandler不是我们自己定义的那个notificationHandler，而是经过包装之后的RetryNotificationDematerializer。所以controlHandler.call(o1)这句代码展开就是：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">    notificationHandler<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>o1<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span>ERROR_EXTRACTOR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p> 进一步展开：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">    notificationHanlder<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>o1<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Func1</span><span class=\"token operator\">&lt;</span>Notification<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> Throwable<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> Throwable <span class=\"token function\">call</span><span class=\"token punctuation\">(</span>Notification<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> t<span class=\"token punctuation\">.</span><span class=\"token function\">getThrowable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>所以我们定义的notificationHandler里的Observable<throwable>是这么来的。加上我们自己添加的逻辑之后返回一个名为restarts的Observable</throwable></p>\n<p>最后，schedule了一个匿名的任务Action0:</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">     worker<span class=\"token punctuation\">.</span><span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Action0</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                restarts<span class=\"token punctuation\">.</span><span class=\"token function\">unsafeSubscribe</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Subscriber</span><span class=\"token operator\">&lt;</span>Object<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>child<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n                    <span class=\"token annotation punctuation\">@Override</span>\n                    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onNext</span><span class=\"token punctuation\">(</span>Object t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>child<span class=\"token punctuation\">.</span><span class=\"token function\">isUnsubscribed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n                            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>consumerCapacity<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                worker<span class=\"token punctuation\">.</span><span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span>subscribeToSource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                                resumeBoundary<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token punctuation\">}</span>\n                        <span class=\"token punctuation\">}</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>注意这个任务让restarts进行订阅（为了方便起见，我们把这个匿名的Subscriber记为s1），然后在收到next事件的时候，执行前面的subscribeToSource任务，也就是向源Observable发起订阅的任务。</p>\n<p>那么这里的bug出现了，该怎么触发subscribeToSource这个任务呢？？？？？？？ 我们可以从后往前推，要触发这个subscribeToSource必须上游<br>调用onNext吐出事件来，而这里的上游就是restarts,也就是terminals terminals要吐出事件来，必须依赖源Observable吐出事件, 这里就形成了一个互相依赖的困境！！<!-- restarts是什么？是我们自己对传入的err那个Observable做变换以后返回的，所以如果我们做的变换逻辑里面如果发出了事件，那么才会导致这里 s1的onNext进行调用 --><br>termials本身既是Observable也是一个Observer,所以terminals.lift 的目的是对自己发出的事件进行拦截 ，但是自己一开始并没有发出事件，然后把这个lift之后的ob传给我们定义的notificationHandler，所以——————最开始的事件还是必须由我们发出来！！</p>\n<p>其实是child.setProducer那一行，会导致调用request(Long.MAX_VALUE)，导致subscribeToSource被调用了<br>所以入口就是这句话，然后发生错误，会回调到我们自定义的错误处理逻辑那里，我们前面提到过，为什么不使用传入的err会导致无效，<br>因为整个链式调用断开了，返回的restarts是我们自己的Observable，那么导致的结果就是，我们用自己的Observable订阅了那个匿名Subscriber，<br>可能调用一次onNext，然后就结束了。虽然后面确实会调用work.schedule(subscribeToSource)那一行代码，但是由于child已经结束了，订阅关系没了，这个subscribeToSource是不会执行的。但是如果换成是对err进行变换返回的Observable就不一样了，在接收到源Observable 发来的error的时候，会往下传递，一直走到我们的对error处理的逻辑，如果我们的处理是返回了一个Observable.just(“”)之类的，那么下游必然会接收到，也就是在匿名Subscriber那里的onNext调用，导致重新订阅源Observable，不然的话调用onComplete或者onError结束整个流程。</p>\n<p>最后我也看了 2.0.0的retryWhen的代码，做了很多修改，整体上来看，结构更加的清晰更容易看明白。所以建议直接看2.0.0的，没有这么绕。</p>\n<p>===写的太乱了（Rx确实有些绕，绕明白了，还是很好理解的）==不定期修改此博文</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"契机\"><a href=\"#契机\" class=\"headerlink\" title=\"契机\"></a>契机</h3><p>因为最近使用了mvvm，不再用mvp,并且大量使用RxJava 简化一些场景下的操作。以至发现了一个操作符retryWhen，搜了一些资料，几乎都是 一位叫DanLew的外国人写的一篇文章或者其译文。原文在这<a href=\"https://blog.danlew.net/2016/01/25/rxjavas-repeatwhen-and-retrywhen-explained/\" target=\"_blank\" rel=\"external\"> &gt;&gt; </a>,思路清晰，知道了怎么用，一些关键的注意点，但就是没有分析具体原理和流程是怎样(但是看他提到的一些词，应该是搞明白了内部原理的)。痛定思痛————当然也是觉得这个操作符非常有意思，所以仔细研究一番。（说实话，我也是最近才觉得RxJava有些源码真的值得好好翻一翻）。本文基于rxjava 1.3.8。</p>\n<h3 id=\"retryWhen和repeatWhen真的不一样吗\"><a href=\"#retryWhen和repeatWhen真的不一样吗\" class=\"headerlink\" title=\"retryWhen和repeatWhen真的不一样吗\"></a>retryWhen和repeatWhen真的不一样吗</h3><p>先看下retryWhen的方法：</p>\n<pre><code class=\"java\">      public final Observable&lt;T&gt; retryWhen(final Func1&lt;Observable&lt;Throwable&gt;,Observable&gt; notificationHandler) {\n        return OnSubscribeRedo.&lt;T&gt;retry(this, InternalObservableUtils.createRetryDematerializer(notificationHandler));\n    }\n</code></pre>\n<p>再看repeatWhen:</p>\n<pre><code class=\"java\">     public final Observable&lt;T&gt; repeatWhen(final Func1&lt;Observable&lt; Void&gt;, Observable&gt; notificationHandler) {\n        return OnSubscribeRedo.repeat(this, \n        InternalObservableUtils.createRepeatDematerializer(notificationHandler));\n    }\n</code></pre>\n<p> 几乎可以认为是一样的，除了对传入的handler处理稍微不同以外。另外参数上有点小不一样，retryWhen的参数内的泛型是Observable<throwable>,<br> repeatWhen的参数泛型则是Observable<void>。这和两者响应的事件不一样，retry是对错误响应，发生错误了该选择是否重试；repeat则是对完成事件响应，数据发射完之后是否重试，完成事件是没有数据的所以是Void。</void></throwable></p>\n<p>不过我看到这个方法最大的两个疑惑是：为什么不是Func1<throwable,boolean>类型的参数，根据给的异常返回true false决定是否重试不是很合理吗？？然后马上反应过来，返回Observable会更灵活，如果重试的逻辑很复杂，单纯根据一个bool 的true or false来决定是否重试，是满足不了一些场景下的需要的。</throwable,boolean></p>\n<p> retryWhen方法上有一段注释：</p>\n<pre><code class=\"html\">    Returns an Observable that emits the same values as the source observable with the exception of an {@code onError}. An {@code onError} notification from the source will result in the emission of a{@link Throwable} item to the Observable provided as an argument to the {@code notificationHandler}\n    function. If that Observable calls {@code onComplete} or {@code onError} then {@code retry} will call {@code onCompleted} or {@code onError} on the child subscription. Otherwise, this Observable will resubscribe to the source Observable.\n</code></pre>\n<p> 具体含义就是，这个操作符会返回一个Observable(记作o1),o1会发射和源observable一样的数据（源observable可能会抛出异常）。当源Observable 发射错误事件时，会将这个错误传递给一个Observable(记作o2),而这个o2会作为参数传给notificationHandler。因为notificationHandler 返回的也是一个Observable(o3),如果o3 后续发射了complete或者error事件（其实就是调用了onComplete或者onError），那么会导致child subscription 也调用onComplete或者onError,结束整个流程，不然的话（也就是调用了onNext），那么将会重新订阅源Observable——————也就是再次激活源Oservable。</p>\n<p> 翻译的有点啰嗦。简而言之就是，我用一个代理Subscriber去订阅源Obsevable，从源Observable获取数据，没有发生错误的情况下，就和一个普通正常的Observable的一样，数据发射完了就结束了。不同的是，头可能发生错误，抛出异常，针对这种情况，我们选择怎么处理。给我们的处理方式就是，我给你一个Observable<throwable>,当源Observable发射错误事件的时候，下游想从源Observable重新尝试订阅（也就是retry的含义）。而repeatWhen则只是稍微不同，repeatWhen响应的是源Observable的complete事件，就是当数据发射完了，是否重新订阅，重复的从源Observable获取数据。</throwable></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><pre><code class=\"java\">\n           retryCount = 0\n            Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() {\n            public void call(Subscriber&lt;? super Integer&gt; subscriber) {\n                subscriber.onNext(1 / 0);\n                subscriber.onCompleted();\n            }\n        }).retryWhen(new Func1&lt;Observable&lt;? extends Throwable&gt;, Observable&lt;?&gt;&gt;() {\n            public Observable&lt;?&gt; call(Observable&lt;? extends Throwable&gt; err) {\n                return err\n                        .flatMap(new Func1&lt;Throwable, Observable&lt;?&gt;&gt;() {\n                            public Observable&lt;?&gt; call(Throwable throwable) {\n                                System.out.println(throwable);\n                                if (throwable instanceof ArithmeticException &amp;&amp; retryCount &lt; 3) {\n                                    System.out.println(&quot;retry ++&quot;);\n                                    retryCount++;\n                                    return Observable.just(&quot;&quot;);\n                                } else {\n                                    System.out.println(&quot;no retry&quot;);\n                                    return Observable.empty();\n                                }\n                            }\n                        });\n\n            }\n        })\n</code></pre>\n<p>创建了一个必然抛出算术异常的Observable。重试的逻辑是超过三次就放弃重试。这里是直接Observable.just(“”)触发的重试，以及Observable.empty()结束整个流程</p>\n<p>这样写是没问题的，但是既然是返回Observable，那么我直接 这样：</p>\n<pre><code class=\"java\">    retryWhen(new Func1&lt;Observable&lt;? extends Throwable&gt;, Observable&lt;?&gt;&gt;() {\n\n            public Observable&lt;?&gt; call(Observable&lt;? extends Throwable&gt; err) {\n\n                                if (throwable instanceof ArithmeticException &amp;&amp; retryCount &lt; 3) {\n                                    System.out.println(&quot;retry ++&quot;);\n                                    retryCount++;\n                                    return Observable.just(&quot;&quot;);\n                                } else {\n                                    System.out.println(&quot;no retry&quot;);\n                                    return Observable.empty();\n                                }\n            }\n\n        })\n</code></pre>\n<p>当然是不可以的，这样的话是返回一个和err无关的Observable，Observable.just(“”) 和Observable.empty()把事件发射完毕后，整个流程也就结束了，我们的订阅者也会取消订阅，不再接收消息。所以根本就是没有发挥这个操作符的效果。那么为什么我不使用参数err 这个Observable就会无效？</p>\n<h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><p>为了搞清楚为什么我们不使用传入的err这个Observable，就会导致retryWhen操作符失效，还是从方法本身入手</p>\n<p>retryWhen方法实际返回的是这个</p>\n<pre><code class=\"java\">  OnSubscribeRedo.&lt;T&gt;retry(this, InternalObservableUtils.createRetryDematerializer(notificationHandler));\n</code></pre>\n<p> InternalObservableUtils.createRetryDematerializer(notificationHandler) 这句代码的实际返回的是<br> 一个 RetryNotificationDematerializer 作用是把Observable<notification>转换成Observable<throwable> ，然后传给我们自己定义的notificationHandler作为参数 然后返回一个新的Observable</throwable></notification></p>\n<p>==========go on 2108.8.10(今天又看了下，又有新的发现，之前的分析漏了点东西，不过也更加发觉 1.x版本的一些东西确实写的复杂了，结构不清晰)</p>\n<p>继续看内部逻辑（省略一些过于细节的细节[不然语言又是罗哩罗嗦]，需要对源码比较熟悉，最好先看一遍）：</p>\n<pre><code>```java\n</code></pre><p>   final Subject<notification<?>, Notification&lt;?&gt;&gt; terminals = BehaviorSubject.<notification<?>&gt;create().toSerialized();<br>   final Subscriber<notification<?>&gt; dummySubscriber = Subscribers.empty();<br>        // subscribe immediately so the last emission will be replayed to the next<br>        // subscriber (which is the one we care about)<br>   terminals.subscribe(dummySubscriber);</notification<?></notification<?></notification<?></p>\n<pre><code>```\n</code></pre><p>被 这三句话坑了很久，还让我看了BehaviorSubject的源码很久，发现这几句就是废话，有没有都行。看他的注释，意思是为了后面我们关心的subscriber能够获取到最近的那个事件，先订阅再说。（实际上最近的那个事件根本不存在）</p>\n<pre><code class=\"java\">final Action0 subscribeToSource = new Action0() {\n            @Override\n            public void call() {\n                Subscriber&lt;T&gt; terminalDelegatingSubscriber = new Subscriber&lt;T&gt;() {\n                    boolean done;\n\n                    @Override\n                    public void onCompleted() {\n                        if (!done) {\n                            done = true;\n                            unsubscribe();\n                            terminals.onNext(Notification.createOnCompleted());\n                        }\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        if (!done) {\n                            done = true;\n                            unsubscribe();\n                            terminals.onNext(Notification.createOnError(e));\n                        }\n                    }\n\n                    @Override\n                    public void onNext(T v) {\n                        if (!done) {\n                            child.onNext(v);\n                            decrementConsumerCapacity();\n                            arbiter.produced(1);\n                        }\n                    }\n                };\n            }\n        };\n</code></pre>\n<p>精简了n多代码。这个subscribeToSource Action0的意思就是 新建了一个terminalDelegatingSubscriber订阅源Observable，就是一个代理订阅者，主要的目的是关注源Observable发出的complet 和error事件。为什么是关注complete和error呢，因为这前面说过retryWhen和repeatWhen本质上的逻辑是一样的，只不过retryWhen关注的是<br>error,repeatWhen关注是complete。complete 和error都被包装成了Notification，然后发射出去。</p>\n<p>继续：</p>\n<pre><code class=\"java\">final Observable&lt;?&gt; restarts = controlHandlerFunction.call(\n                terminals.lift(new Operator&lt;Notification&lt;?&gt;, Notification&lt;?&gt;&gt;() {\n                    @Override\n                    public Subscriber&lt;? super Notification&lt;?&gt;&gt; call(final Subscriber&lt;? super Notification&lt;?&gt;&gt; filteredTerminals) {\n                        return new Subscriber&lt;Notification&lt;?&gt;&gt;(filteredTerminals) {\n                            @Override\n                            public void onCompleted() {\n                                filteredTerminals.onCompleted();\n                            }\n\n                            @Override\n                            public void onError(Throwable e) {\n                                filteredTerminals.onError(e);\n                            }\n\n                            @Override\n                            public void onNext(Notification&lt;?&gt; t) {\n                                if (t.isOnCompleted() &amp;&amp; stopOnComplete) {\n                                    filteredTerminals.onCompleted();\n                                } else if (t.isOnError() &amp;&amp; stopOnError) {\n                                    filteredTerminals.onError(t.getThrowable());\n                                } else {\n                                    filteredTerminals.onNext(t);\n                                }\n                            }\n\n                            @Override\n                            public void setProducer(Producer producer) {\n                                producer.request(Long.MAX_VALUE);\n                            }\n                        };\n                    }\n                }));\n</code></pre>\n<p>这里稍微复杂一点，从里往外看，里面是terminals.lift操作了一下，主要逻辑在返回的新的Subscribeder的onNext这里，也就是对前面发过来的<br>Notificaiton拦截判断处理一下。一共有三种情况（其实就是决定retry和repeat的地方）：</p>\n<p> 1) t.isOnCompleted() &amp;&amp; stopOnComplete 条件如果满足 对应的是retryWhen 结束不会重试<br> 2）t.isOnError() &amp;&amp; stopOnError 条件满足 对应的是repeatWhen 结束，不会重复<br> 3）这种情况下我们针对retryWhen看，如果收到的是一个error事件，很明显前面两个条件都不会满足，直接来到这里，调用onNext,传递给下游</p>\n<p>我们把这个terminal.lift之后得到的Observable记作 o1。之后这个o1会作为参数传递给我们的controlHandler<br> 。前面说过这个controlHandler不是我们自己定义的那个notificationHandler，而是经过包装之后的RetryNotificationDematerializer。所以controlHandler.call(o1)这句代码展开就是：</p>\n<pre><code class=\"java\">    notificationHandler.call(o1.map(ERROR_EXTRACTOR))\n</code></pre>\n<p> 进一步展开：</p>\n<pre><code class=\"java\">    notificationHanlder.call(o1.map(new Func1&lt;Notification&lt;?&gt;, Throwable&gt; {\n        @Override\n        public Throwable call(Notification&lt;?&gt; t) {\n            return t.getThrowable();\n        }\n    }))\n</code></pre>\n<p>所以我们定义的notificationHandler里的Observable<throwable>是这么来的。加上我们自己添加的逻辑之后返回一个名为restarts的Observable</throwable></p>\n<p>最后，schedule了一个匿名的任务Action0:</p>\n<pre><code class=\"java\">     worker.schedule(new Action0() {\n            @Override\n            public void call() {\n                restarts.unsafeSubscribe(new Subscriber&lt;Object&gt;(child) {\n\n                    @Override\n                    public void onNext(Object t) {\n                        if (!child.isUnsubscribed()) {\n\n                            if (consumerCapacity.get() &gt; 0) {\n                                worker.schedule(subscribeToSource);\n                            } else {\n                                resumeBoundary.compareAndSet(false, true);\n                            }\n                        }\n                    }\n                });\n            }\n        });\n</code></pre>\n<p>注意这个任务让restarts进行订阅（为了方便起见，我们把这个匿名的Subscriber记为s1），然后在收到next事件的时候，执行前面的subscribeToSource任务，也就是向源Observable发起订阅的任务。</p>\n<p>那么这里的bug出现了，该怎么触发subscribeToSource这个任务呢？？？？？？？ 我们可以从后往前推，要触发这个subscribeToSource必须上游<br>调用onNext吐出事件来，而这里的上游就是restarts,也就是terminals terminals要吐出事件来，必须依赖源Observable吐出事件, 这里就形成了一个互相依赖的困境！！<!-- restarts是什么？是我们自己对传入的err那个Observable做变换以后返回的，所以如果我们做的变换逻辑里面如果发出了事件，那么才会导致这里 s1的onNext进行调用 --><br>termials本身既是Observable也是一个Observer,所以terminals.lift 的目的是对自己发出的事件进行拦截 ，但是自己一开始并没有发出事件，然后把这个lift之后的ob传给我们定义的notificationHandler，所以——————最开始的事件还是必须由我们发出来！！</p>\n<p>其实是child.setProducer那一行，会导致调用request(Long.MAX_VALUE)，导致subscribeToSource被调用了<br>所以入口就是这句话，然后发生错误，会回调到我们自定义的错误处理逻辑那里，我们前面提到过，为什么不使用传入的err会导致无效，<br>因为整个链式调用断开了，返回的restarts是我们自己的Observable，那么导致的结果就是，我们用自己的Observable订阅了那个匿名Subscriber，<br>可能调用一次onNext，然后就结束了。虽然后面确实会调用work.schedule(subscribeToSource)那一行代码，但是由于child已经结束了，订阅关系没了，这个subscribeToSource是不会执行的。但是如果换成是对err进行变换返回的Observable就不一样了，在接收到源Observable 发来的error的时候，会往下传递，一直走到我们的对error处理的逻辑，如果我们的处理是返回了一个Observable.just(“”)之类的，那么下游必然会接收到，也就是在匿名Subscriber那里的onNext调用，导致重新订阅源Observable，不然的话调用onComplete或者onError结束整个流程。</p>\n<p>最后我也看了 2.0.0的retryWhen的代码，做了很多修改，整体上来看，结构更加的清晰更容易看明白。所以建议直接看2.0.0的，没有这么绕。</p>\n<p>===写的太乱了（Rx确实有些绕，绕明白了，还是很好理解的）==不定期修改此博文</p>\n"},{"title":"关于AndroidStudio下的idea目录","date":"2018-01-24T08:38:30.000Z","_content":"这个目录一开始看名字只知道和我们工程的工作区间有关，到底是啥我没仔细看过。直到有一天，我不小心把这个文件的内容给删除了（可能是午睡趴在键盘上了），然后会导致工程一直报这个文件的错，于是乎我干脆把这个文件都删了。导致的结果是每次重新打开工程，之前打开过的文件全都不会自动打开，得一个个的点开，瞬间我就有点知道这个文件干嘛的了。其实就是记录我们最近的文件操作，比如你上次退出前打开过的文件，鼠标在哪个位置等等，比如：\n![](https://github.com/HirayClay/draft/blob/master/as-workspace.png?raw=true)\n我最后鼠标停在红色标记处，也就是整个文件的第1行，第25个文字处\n\n那么在workspace.xml文件中会产生这么一条记录：\n![](https://github.com/HirayClay/draft/blob/master/as-workspace-record-shot.png?raw=true)\n应该是下标从0开始的原因，记录的line = 0,column =24\n可能没有这条记录，ctrl+s强制保存一次就有了\n\n当然workspace文件里面保存的还有其他信息，比如当然使用的gradle版本等信息\n\n所以最后我自然就去其他工程拷贝了一份直接放到idea目录下就ok了\n","source":"_posts/关于AndroidStudio下的idea目录.md","raw":"---\ntitle: 关于AndroidStudio下的idea目录\ndate: 2018-01-24 16:38:30\ntags: \n    - AndroidStudio\n---\n这个目录一开始看名字只知道和我们工程的工作区间有关，到底是啥我没仔细看过。直到有一天，我不小心把这个文件的内容给删除了（可能是午睡趴在键盘上了），然后会导致工程一直报这个文件的错，于是乎我干脆把这个文件都删了。导致的结果是每次重新打开工程，之前打开过的文件全都不会自动打开，得一个个的点开，瞬间我就有点知道这个文件干嘛的了。其实就是记录我们最近的文件操作，比如你上次退出前打开过的文件，鼠标在哪个位置等等，比如：\n![](https://github.com/HirayClay/draft/blob/master/as-workspace.png?raw=true)\n我最后鼠标停在红色标记处，也就是整个文件的第1行，第25个文字处\n\n那么在workspace.xml文件中会产生这么一条记录：\n![](https://github.com/HirayClay/draft/blob/master/as-workspace-record-shot.png?raw=true)\n应该是下标从0开始的原因，记录的line = 0,column =24\n可能没有这条记录，ctrl+s强制保存一次就有了\n\n当然workspace文件里面保存的还有其他信息，比如当然使用的gradle版本等信息\n\n所以最后我自然就去其他工程拷贝了一份直接放到idea目录下就ok了\n","slug":"关于AndroidStudio下的idea目录","published":1,"updated":"2018-01-24T09:10:52.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl1qvapq000hy472432ganp2","content":"<p>这个目录一开始看名字只知道和我们工程的工作区间有关，到底是啥我没仔细看过。直到有一天，我不小心把这个文件的内容给删除了（可能是午睡趴在键盘上了），然后会导致工程一直报这个文件的错，于是乎我干脆把这个文件都删了。导致的结果是每次重新打开工程，之前打开过的文件全都不会自动打开，得一个个的点开，瞬间我就有点知道这个文件干嘛的了。其实就是记录我们最近的文件操作，比如你上次退出前打开过的文件，鼠标在哪个位置等等，比如：<br><img src=\"https://github.com/HirayClay/draft/blob/master/as-workspace.png?raw=true\" alt=\"\"><br>我最后鼠标停在红色标记处，也就是整个文件的第1行，第25个文字处</p>\n<p>那么在workspace.xml文件中会产生这么一条记录：<br><img src=\"https://github.com/HirayClay/draft/blob/master/as-workspace-record-shot.png?raw=true\" alt=\"\"><br>应该是下标从0开始的原因，记录的line = 0,column =24<br>可能没有这条记录，ctrl+s强制保存一次就有了</p>\n<p>当然workspace文件里面保存的还有其他信息，比如当然使用的gradle版本等信息</p>\n<p>所以最后我自然就去其他工程拷贝了一份直接放到idea目录下就ok了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这个目录一开始看名字只知道和我们工程的工作区间有关，到底是啥我没仔细看过。直到有一天，我不小心把这个文件的内容给删除了（可能是午睡趴在键盘上了），然后会导致工程一直报这个文件的错，于是乎我干脆把这个文件都删了。导致的结果是每次重新打开工程，之前打开过的文件全都不会自动打开，得一个个的点开，瞬间我就有点知道这个文件干嘛的了。其实就是记录我们最近的文件操作，比如你上次退出前打开过的文件，鼠标在哪个位置等等，比如：<br><img src=\"https://github.com/HirayClay/draft/blob/master/as-workspace.png?raw=true\" alt=\"\"><br>我最后鼠标停在红色标记处，也就是整个文件的第1行，第25个文字处</p>\n<p>那么在workspace.xml文件中会产生这么一条记录：<br><img src=\"https://github.com/HirayClay/draft/blob/master/as-workspace-record-shot.png?raw=true\" alt=\"\"><br>应该是下标从0开始的原因，记录的line = 0,column =24<br>可能没有这条记录，ctrl+s强制保存一次就有了</p>\n<p>当然workspace文件里面保存的还有其他信息，比如当然使用的gradle版本等信息</p>\n<p>所以最后我自然就去其他工程拷贝了一份直接放到idea目录下就ok了</p>\n"},{"title":"关于DataBinding的一些知识","date":"2018-04-11T02:29:01.000Z","_content":"Android的DataBinding出来很久了，但是因为我一直用的mvp，出来的时候就简单的 开启了enable =true这句代码弄了下搞了个简单的layout布局就没管了（好吧，貌似只能算单向绑定=_=）。然后最近想深入的看下DataBinding，比如自定义的控件怎么实现双向绑定,一步一步来吧，其实东西真的不多，不过很强大,基本都是注解。\n\n###简单的绑定\n先建立一个Worker类：\n```java\n    public class Worker {\n\n    public int workerId;\n    public String name;\n    public int wage;\n    public String photoUrl;\n    public int photoId;\n\n    public Worker() {\n    }\n\n\n    public Worker(int workerId, String name, int wage, int photoId) {\n        this.workerId = workerId;\n        this.name = name;\n        this.wage = wage;\n        this.photoId = photoId;\n    }\n}\n```\n这是一个简单的布局文件(data_binding_layout.xml)，在TextView上显示Worker的名字：\n```xml\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n\n    <data>\n\n        <variable\n            name=\"worker\"\n            type=\"com.hiray.mvvm.mvvm.model.Worker\" />\n\n    </data>\n\n    <TextView\n        android:layout_width=\"120dp\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"@{worker.name}\" />  \n</layout>\n```\n会根据布局文件名字生成一个ViewDataBinding对象————DataBindingLayoutBinding,在代码中设置一下：\n```java\n       public class DataBindingActivity extends AppCompatActivity {\n            @Override\n            protected void onCreate(Bundle savedInstanceState) {\n                super.onCreate(savedInstanceState);\n                DataBindingLayoutBinding binding = DataBindingUtil.setContentView(this, R.layout.data_binding_layout);\n                binding.setWorker(new Worker(1205, \"Mike\", 12000, R.mipmap.boy);\n            }\n        }\n```\n以上是非常简单的一种绑定，只是单向的数据绑定，数据映射到UI上\n关于这样的单向绑定有好几个注解\n\n### BindingMethods、BindingMethod\n比如我想给ImageView加上自定义的属性下载图片\n```xml\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n\n    <data>\n\n        <variable\n            name=\"worker\"\n            type=\"com.hiray.mvvm.mvvm.model.Worker\" />\n\n    </data>\n\n    <ImageView\n        app:imageDrawable=\"@{worker.photoId}\"\n        android:layout_width=\"50dp\"\n        android:layout_height=\"50dp\"/>  \n</layout>\n```\n这里\"app:imageDrawable\"这个属性是无法被识别的，会编译出错，我们要通过某种方式告诉系统该怎么做。我们建立一个类 ViewBindingAdapter，使用BindingMethods和BindingMethod注解：\n```java\n@BindingMethods(\n        @BindingMethod(\n                type = ImageView.class,\n                attribute = \"app:imageDrawable\",\n                method = \"setImageResource\"\n        )\n)\npublic class ImageAttr {\n\n     \n}\n```\n其中type是你要绑定的类，attribute是你自己定的,method是ImageView中的方法，也就是告诉ImageView，在xml中碰到app:imageDrawable属性的时候调用ImageView的setImageResource方法。\n但是如果我此时不想传入图片id，而是传入一个id的String字符，那怎么办呢，因为ImageView并没有接收String参数来设置图片的方法，那么我们要利用BindConversion转换一下\n\n### BindingConversion\n\n```java\n\npublic class ImageAttr {\n\n    @BindingConversion\n    public static int convertStringToResId(String idString){\n        return Integer.parseInt(idString);\n    }\n     \n}\n```\n\n但是有些时候即使转换了，也没有对应的setter方法可以使用，比如你设置drawableLeft这种属性的时候，是没有setDrawableLeft方法的，只有setCompoundDrawable,那么这时候就可以使用 BindingAdapter这个注解了\n\n### BindingAdapter \n顾名思义是绑定适配器，如果像设置的属性没有直接的方法，需要转换一下，那么就用到这个注解，比如设置drawableLeft,是没有setDrawableLeft方法的，必须调用view的setCompoundDrawables\n```java\n\npublic class ImageAttr {\n\n    @BindingAdapter(\"app:drawableLeft\")\n    public static void bindDrawableLeft(TextView view, Drawable leftDrawable) {\n        view.setCompoundDrawables(leftDrawable, null, null, null);\n    }\n     \n}\n```\n\n### InverseMethod\n在双向绑定中，需要对值进行转换\n比如我们有个checkbox，如果model中的一个String类型的值是“Alice”就让checkbox选上，反之不勾选，这里就要用到InverseMethod注解\n新建一个Converter类，写了两个静态方法：\n```java\n    public class Converter {\n\n    @InverseMethod(\"convertStringToBool\")\n    public static String convertBoolToString(boolean b) {\n        if (b)\n            return \"Alice\";\n        else return \"Unknown\";\n    }\n\n    public static boolean convertStringToBool(String name) {\n        return \"Alice\".equals(name);\n    }\n}\n```\n\n布局文件：\n```xml\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <data>\n        <variable\n            name=\"person\"\n            type=\"com.hiray.mvvm.mvvm.model.Person\"/>\n        <import type=\"com.hiray.mvvm.mvvm.attr.Converter\"/>\n    </data>\n\n        <android.support.v7.widget.AppCompatCheckBox\n            android:checked=\"@={Converter.convertStringToBool(person.personName)}\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\" />\n\n</layout>\n```\n### 给自定义控件支持双向绑定\n这里有个自定义的BlinkView，不停的闪烁，由一个bool 类型的值 blink控制是否闪烁，伪代码如下：\n```java\n    public class BlinkView extends View {\n\n    private Paint paint;\n    boolean blink = true;\n    ......\n\n    public void setBlink(boolean blink) {\n        this.blink = blink;\n        invalidate();\n    }\n\n    public boolean getBlink(){\n        return blink;\n    }\n    public void toggle() {\n        setBlink(!blink);\n        if (onBlinkChangeListener != null)\n            onBlinkChangeListener.onBlinkChange(blink);\n    }\n\n    public interface OnBlinkChangeListener {\n        void onBlinkChange(boolean blink);\n    }\n\n    private OnBlinkChangeListener onBlinkChangeListener;\n\n    public void setOnBlinkChangeListener(OnBlinkChangeListener onBlinkChangeListener) {\n        this.onBlinkChangeListener = onBlinkChangeListener;\n    }\n}\n```\nlayout文件中：\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n    <data>\n\n        <variable\n            name=\"data\"\n            type=\"com.hiray.mvvm.mvvm.model.DataHolder\" />\n\n\n    </data>\n        <com.hiray.mvvm.mvvm.widget.BlinkView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            app:blink=\"@={data.blink}\"\n            app:blinkColor=\"@color/colorAccent\" />\n\n</layout>\n```\n这样写显然不会有任何效果，建立一个名为BlinkViewAdapter的类，使用InverseBindingMethods注解告诉Android在遇到app:blink属性的时候怎么把数据映射到UI上，然后又要告诉AndroidUI怎么映射到数据上，代码如下：\n```java\n    @InverseBindingMethods(\n        @InverseBindingMethod(type = BlinkView.class,\n                attribute = \"blink\")\n)\npublic class BlinkViewAdapter {\n\n//    @InverseBindingAdapter(attribute = \"app:blink\")\n//    public static boolean isBlink(BlinkView view) {\n//        return view.getBlink();\n//    }\n\n    @BindingAdapter(value = {\"app:blinkChanged\", \"app:blinkAttrChanged\"}, requireAll = false)\n    public static void setListener(BlinkView view, BlinkView.OnBlinkChangeListener listener,\n                                   final InverseBindingListener attrChange) {\n\n        if (attrChange == null && listener != null)\n            view.setOnBlinkChangeListener(listener);\n        else view.setOnBlinkChangeListener(new BlinkView.OnBlinkChangeListener() {\n            @Override\n            public void onBlinkChange(boolean blink) {\n                attrChange.onChange();\n            }\n        });\n\n    }\n\n}\n```\n其中InverseBindingMethod注解有三个参数：type表示你要绑定的类，attribute就是你要进行绑定的属性（就是写在xml上的属性），method默认按照属性名字去找有没有 isXX 或者getXX方法，不然你就写上method名字，如果没有直接的method名字，可以使用InverseBindingAdapter注解（代码中注释的部分），这是告诉系统在UI发生变化的时候调用什么方法获取UI信息这里Android默认是按照属性名字去找有没有 xxAttrChanged的（如果你自己没有定义的话），当然这个event可以自己定义，比如你定义成\"abcdefg&%##$\",那么上面setListener方法的BindingAdapter注解的\"app:blinkAttrChanged\"也得改成这个。\n另外setListener有三个参数，第一个是控件BlinkView自己，第二个是BlinkView.OnBlinkChangeListener 和\"app:blinkChanged\"对应；第三个是InverseBindingListener是必须的，这个参数的实现在编译期就生成了，就是通知系统UI变化了，要更新ui信息到数据上（更新的方法就是前面的第一部分），可以看下生成的attrChange:\n```java\n     private android.databinding.InverseBindingListener mboundView3blinkAttrChange = new android.databinding.InverseBindingListener() {\n        @Override\n        public void onChange() {\n            // Inverse of data.blink\n            //         is data.setBlink((boolean) callbackArg_0)\n            boolean callbackArg_0 = mboundView3.getBlink();\n            // localize variables for thread safety\n            // data.blink\n            boolean dataBlink = false;\n            // data != null\n            boolean dataJavaLangObjectNull = false;\n            // data\n            com.hiray.mvvm.mvvm.model.DataHolder data = mData;\n\n\n\n            dataJavaLangObjectNull = (data) != (null);\n            if (dataJavaLangObjectNull) {\n\n\n\n\n                data.setBlink(((boolean) (callbackArg_0)));\n            }\n        }\n    };\n```\n看到这里其实就明白了，这里生成的东西都是根据前面的注解来的，收到刷新提示就会调用方法获取UI信息，并且更新数据模型中的值，由此完成了整个的双向的绑定","source":"_posts/关于DataBinding的一些知识.md","raw":"---\ntitle: 关于DataBinding的一些知识\ndate: 2018-04-11 10:29:01\ntags:\n    - DataBinding\n    - Android\n---\nAndroid的DataBinding出来很久了，但是因为我一直用的mvp，出来的时候就简单的 开启了enable =true这句代码弄了下搞了个简单的layout布局就没管了（好吧，貌似只能算单向绑定=_=）。然后最近想深入的看下DataBinding，比如自定义的控件怎么实现双向绑定,一步一步来吧，其实东西真的不多，不过很强大,基本都是注解。\n\n###简单的绑定\n先建立一个Worker类：\n```java\n    public class Worker {\n\n    public int workerId;\n    public String name;\n    public int wage;\n    public String photoUrl;\n    public int photoId;\n\n    public Worker() {\n    }\n\n\n    public Worker(int workerId, String name, int wage, int photoId) {\n        this.workerId = workerId;\n        this.name = name;\n        this.wage = wage;\n        this.photoId = photoId;\n    }\n}\n```\n这是一个简单的布局文件(data_binding_layout.xml)，在TextView上显示Worker的名字：\n```xml\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n\n    <data>\n\n        <variable\n            name=\"worker\"\n            type=\"com.hiray.mvvm.mvvm.model.Worker\" />\n\n    </data>\n\n    <TextView\n        android:layout_width=\"120dp\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"@{worker.name}\" />  \n</layout>\n```\n会根据布局文件名字生成一个ViewDataBinding对象————DataBindingLayoutBinding,在代码中设置一下：\n```java\n       public class DataBindingActivity extends AppCompatActivity {\n            @Override\n            protected void onCreate(Bundle savedInstanceState) {\n                super.onCreate(savedInstanceState);\n                DataBindingLayoutBinding binding = DataBindingUtil.setContentView(this, R.layout.data_binding_layout);\n                binding.setWorker(new Worker(1205, \"Mike\", 12000, R.mipmap.boy);\n            }\n        }\n```\n以上是非常简单的一种绑定，只是单向的数据绑定，数据映射到UI上\n关于这样的单向绑定有好几个注解\n\n### BindingMethods、BindingMethod\n比如我想给ImageView加上自定义的属性下载图片\n```xml\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n\n    <data>\n\n        <variable\n            name=\"worker\"\n            type=\"com.hiray.mvvm.mvvm.model.Worker\" />\n\n    </data>\n\n    <ImageView\n        app:imageDrawable=\"@{worker.photoId}\"\n        android:layout_width=\"50dp\"\n        android:layout_height=\"50dp\"/>  \n</layout>\n```\n这里\"app:imageDrawable\"这个属性是无法被识别的，会编译出错，我们要通过某种方式告诉系统该怎么做。我们建立一个类 ViewBindingAdapter，使用BindingMethods和BindingMethod注解：\n```java\n@BindingMethods(\n        @BindingMethod(\n                type = ImageView.class,\n                attribute = \"app:imageDrawable\",\n                method = \"setImageResource\"\n        )\n)\npublic class ImageAttr {\n\n     \n}\n```\n其中type是你要绑定的类，attribute是你自己定的,method是ImageView中的方法，也就是告诉ImageView，在xml中碰到app:imageDrawable属性的时候调用ImageView的setImageResource方法。\n但是如果我此时不想传入图片id，而是传入一个id的String字符，那怎么办呢，因为ImageView并没有接收String参数来设置图片的方法，那么我们要利用BindConversion转换一下\n\n### BindingConversion\n\n```java\n\npublic class ImageAttr {\n\n    @BindingConversion\n    public static int convertStringToResId(String idString){\n        return Integer.parseInt(idString);\n    }\n     \n}\n```\n\n但是有些时候即使转换了，也没有对应的setter方法可以使用，比如你设置drawableLeft这种属性的时候，是没有setDrawableLeft方法的，只有setCompoundDrawable,那么这时候就可以使用 BindingAdapter这个注解了\n\n### BindingAdapter \n顾名思义是绑定适配器，如果像设置的属性没有直接的方法，需要转换一下，那么就用到这个注解，比如设置drawableLeft,是没有setDrawableLeft方法的，必须调用view的setCompoundDrawables\n```java\n\npublic class ImageAttr {\n\n    @BindingAdapter(\"app:drawableLeft\")\n    public static void bindDrawableLeft(TextView view, Drawable leftDrawable) {\n        view.setCompoundDrawables(leftDrawable, null, null, null);\n    }\n     \n}\n```\n\n### InverseMethod\n在双向绑定中，需要对值进行转换\n比如我们有个checkbox，如果model中的一个String类型的值是“Alice”就让checkbox选上，反之不勾选，这里就要用到InverseMethod注解\n新建一个Converter类，写了两个静态方法：\n```java\n    public class Converter {\n\n    @InverseMethod(\"convertStringToBool\")\n    public static String convertBoolToString(boolean b) {\n        if (b)\n            return \"Alice\";\n        else return \"Unknown\";\n    }\n\n    public static boolean convertStringToBool(String name) {\n        return \"Alice\".equals(name);\n    }\n}\n```\n\n布局文件：\n```xml\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\">\n\n    <data>\n        <variable\n            name=\"person\"\n            type=\"com.hiray.mvvm.mvvm.model.Person\"/>\n        <import type=\"com.hiray.mvvm.mvvm.attr.Converter\"/>\n    </data>\n\n        <android.support.v7.widget.AppCompatCheckBox\n            android:checked=\"@={Converter.convertStringToBool(person.personName)}\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\" />\n\n</layout>\n```\n### 给自定义控件支持双向绑定\n这里有个自定义的BlinkView，不停的闪烁，由一个bool 类型的值 blink控制是否闪烁，伪代码如下：\n```java\n    public class BlinkView extends View {\n\n    private Paint paint;\n    boolean blink = true;\n    ......\n\n    public void setBlink(boolean blink) {\n        this.blink = blink;\n        invalidate();\n    }\n\n    public boolean getBlink(){\n        return blink;\n    }\n    public void toggle() {\n        setBlink(!blink);\n        if (onBlinkChangeListener != null)\n            onBlinkChangeListener.onBlinkChange(blink);\n    }\n\n    public interface OnBlinkChangeListener {\n        void onBlinkChange(boolean blink);\n    }\n\n    private OnBlinkChangeListener onBlinkChangeListener;\n\n    public void setOnBlinkChangeListener(OnBlinkChangeListener onBlinkChangeListener) {\n        this.onBlinkChangeListener = onBlinkChangeListener;\n    }\n}\n```\nlayout文件中：\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n    <data>\n\n        <variable\n            name=\"data\"\n            type=\"com.hiray.mvvm.mvvm.model.DataHolder\" />\n\n\n    </data>\n        <com.hiray.mvvm.mvvm.widget.BlinkView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            app:blink=\"@={data.blink}\"\n            app:blinkColor=\"@color/colorAccent\" />\n\n</layout>\n```\n这样写显然不会有任何效果，建立一个名为BlinkViewAdapter的类，使用InverseBindingMethods注解告诉Android在遇到app:blink属性的时候怎么把数据映射到UI上，然后又要告诉AndroidUI怎么映射到数据上，代码如下：\n```java\n    @InverseBindingMethods(\n        @InverseBindingMethod(type = BlinkView.class,\n                attribute = \"blink\")\n)\npublic class BlinkViewAdapter {\n\n//    @InverseBindingAdapter(attribute = \"app:blink\")\n//    public static boolean isBlink(BlinkView view) {\n//        return view.getBlink();\n//    }\n\n    @BindingAdapter(value = {\"app:blinkChanged\", \"app:blinkAttrChanged\"}, requireAll = false)\n    public static void setListener(BlinkView view, BlinkView.OnBlinkChangeListener listener,\n                                   final InverseBindingListener attrChange) {\n\n        if (attrChange == null && listener != null)\n            view.setOnBlinkChangeListener(listener);\n        else view.setOnBlinkChangeListener(new BlinkView.OnBlinkChangeListener() {\n            @Override\n            public void onBlinkChange(boolean blink) {\n                attrChange.onChange();\n            }\n        });\n\n    }\n\n}\n```\n其中InverseBindingMethod注解有三个参数：type表示你要绑定的类，attribute就是你要进行绑定的属性（就是写在xml上的属性），method默认按照属性名字去找有没有 isXX 或者getXX方法，不然你就写上method名字，如果没有直接的method名字，可以使用InverseBindingAdapter注解（代码中注释的部分），这是告诉系统在UI发生变化的时候调用什么方法获取UI信息这里Android默认是按照属性名字去找有没有 xxAttrChanged的（如果你自己没有定义的话），当然这个event可以自己定义，比如你定义成\"abcdefg&%##$\",那么上面setListener方法的BindingAdapter注解的\"app:blinkAttrChanged\"也得改成这个。\n另外setListener有三个参数，第一个是控件BlinkView自己，第二个是BlinkView.OnBlinkChangeListener 和\"app:blinkChanged\"对应；第三个是InverseBindingListener是必须的，这个参数的实现在编译期就生成了，就是通知系统UI变化了，要更新ui信息到数据上（更新的方法就是前面的第一部分），可以看下生成的attrChange:\n```java\n     private android.databinding.InverseBindingListener mboundView3blinkAttrChange = new android.databinding.InverseBindingListener() {\n        @Override\n        public void onChange() {\n            // Inverse of data.blink\n            //         is data.setBlink((boolean) callbackArg_0)\n            boolean callbackArg_0 = mboundView3.getBlink();\n            // localize variables for thread safety\n            // data.blink\n            boolean dataBlink = false;\n            // data != null\n            boolean dataJavaLangObjectNull = false;\n            // data\n            com.hiray.mvvm.mvvm.model.DataHolder data = mData;\n\n\n\n            dataJavaLangObjectNull = (data) != (null);\n            if (dataJavaLangObjectNull) {\n\n\n\n\n                data.setBlink(((boolean) (callbackArg_0)));\n            }\n        }\n    };\n```\n看到这里其实就明白了，这里生成的东西都是根据前面的注解来的，收到刷新提示就会调用方法获取UI信息，并且更新数据模型中的值，由此完成了整个的双向的绑定","slug":"关于DataBinding的一些知识","published":1,"updated":"2018-04-12T08:48:55.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl1qvapu000jy472ukmzhils","content":"<p>Android的DataBinding出来很久了，但是因为我一直用的mvp，出来的时候就简单的 开启了enable =true这句代码弄了下搞了个简单的layout布局就没管了（好吧，貌似只能算单向绑定=_=）。然后最近想深入的看下DataBinding，比如自定义的控件怎么实现双向绑定,一步一步来吧，其实东西真的不多，不过很强大,基本都是注解。</p>\n<p>###简单的绑定<br>先建立一个Worker类：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Worker</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> workerId<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> String name<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> wage<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> String photoUrl<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> photoId<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Worker</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">Worker</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> workerId<span class=\"token punctuation\">,</span> String name<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> wage<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> photoId<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>workerId <span class=\"token operator\">=</span> workerId<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>wage <span class=\"token operator\">=</span> wage<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>photoId <span class=\"token operator\">=</span> photoId<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这是一个简单的布局文件(data_binding_layout.xml)，在TextView上显示Worker的名字：</p>\n<pre class=\"line-numbers language-xml\"><code class=\"language-xml\">    <span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>layout</span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>android</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://schemas.android.com/apk/res/android<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>data</span><span class=\"token punctuation\">></span></span>\n\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span>\n            <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>worker<span class=\"token punctuation\">\"</span></span>\n            <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.hiray.mvvm.mvvm.model.Worker<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>data</span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>TextView</span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>120dp<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>text</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@{worker.name}<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>  \n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>layout</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>会根据布局文件名字生成一个ViewDataBinding对象————DataBindingLayoutBinding,在代码中设置一下：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">       <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DataBindingActivity</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AppCompatActivity</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onCreate</span><span class=\"token punctuation\">(</span>Bundle savedInstanceState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">super</span><span class=\"token punctuation\">.</span><span class=\"token function\">onCreate</span><span class=\"token punctuation\">(</span>savedInstanceState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                DataBindingLayoutBinding binding <span class=\"token operator\">=</span> DataBindingUtil<span class=\"token punctuation\">.</span><span class=\"token function\">setContentView</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> R<span class=\"token punctuation\">.</span>layout<span class=\"token punctuation\">.</span>data_binding_layout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                binding<span class=\"token punctuation\">.</span><span class=\"token function\">setWorker</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Worker</span><span class=\"token punctuation\">(</span><span class=\"token number\">1205</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Mike\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">12000</span><span class=\"token punctuation\">,</span> R<span class=\"token punctuation\">.</span>mipmap<span class=\"token punctuation\">.</span>boy<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>以上是非常简单的一种绑定，只是单向的数据绑定，数据映射到UI上<br>关于这样的单向绑定有好几个注解</p>\n<h3 id=\"BindingMethods、BindingMethod\"><a href=\"#BindingMethods、BindingMethod\" class=\"headerlink\" title=\"BindingMethods、BindingMethod\"></a>BindingMethods、BindingMethod</h3><p>比如我想给ImageView加上自定义的属性下载图片</p>\n<pre class=\"line-numbers language-xml\"><code class=\"language-xml\">        <span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>layout</span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>android</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://schemas.android.com/apk/res/android<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>data</span><span class=\"token punctuation\">></span></span>\n\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span>\n            <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>worker<span class=\"token punctuation\">\"</span></span>\n            <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.hiray.mvvm.mvvm.model.Worker<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>data</span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ImageView</span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">app:</span>imageDrawable</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@{worker.photoId}<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>50dp<span class=\"token punctuation\">\"</span></span>\n        <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>50dp<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>  \n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>layout</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这里”app:imageDrawable”这个属性是无法被识别的，会编译出错，我们要通过某种方式告诉系统该怎么做。我们建立一个类 ViewBindingAdapter，使用BindingMethods和BindingMethod注解：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@BindingMethods</span><span class=\"token punctuation\">(</span>\n        <span class=\"token annotation punctuation\">@BindingMethod</span><span class=\"token punctuation\">(</span>\n                type <span class=\"token operator\">=</span> ImageView<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span>\n                attribute <span class=\"token operator\">=</span> <span class=\"token string\">\"app:imageDrawable\"</span><span class=\"token punctuation\">,</span>\n                method <span class=\"token operator\">=</span> <span class=\"token string\">\"setImageResource\"</span>\n        <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ImageAttr</span> <span class=\"token punctuation\">{</span>\n\n\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>其中type是你要绑定的类，attribute是你自己定的,method是ImageView中的方法，也就是告诉ImageView，在xml中碰到app:imageDrawable属性的时候调用ImageView的setImageResource方法。<br>但是如果我此时不想传入图片id，而是传入一个id的String字符，那怎么办呢，因为ImageView并没有接收String参数来设置图片的方法，那么我们要利用BindConversion转换一下</p>\n<h3 id=\"BindingConversion\"><a href=\"#BindingConversion\" class=\"headerlink\" title=\"BindingConversion\"></a>BindingConversion</h3><pre class=\"line-numbers language-java\"><code class=\"language-java\">\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ImageAttr</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@BindingConversion</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">convertStringToResId</span><span class=\"token punctuation\">(</span>String idString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> Integer<span class=\"token punctuation\">.</span><span class=\"token function\">parseInt</span><span class=\"token punctuation\">(</span>idString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>但是有些时候即使转换了，也没有对应的setter方法可以使用，比如你设置drawableLeft这种属性的时候，是没有setDrawableLeft方法的，只有setCompoundDrawable,那么这时候就可以使用 BindingAdapter这个注解了</p>\n<h3 id=\"BindingAdapter\"><a href=\"#BindingAdapter\" class=\"headerlink\" title=\"BindingAdapter\"></a>BindingAdapter</h3><p>顾名思义是绑定适配器，如果像设置的属性没有直接的方法，需要转换一下，那么就用到这个注解，比如设置drawableLeft,是没有setDrawableLeft方法的，必须调用view的setCompoundDrawables</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ImageAttr</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@BindingAdapter</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"app:drawableLeft\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">bindDrawableLeft</span><span class=\"token punctuation\">(</span>TextView view<span class=\"token punctuation\">,</span> Drawable leftDrawable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        view<span class=\"token punctuation\">.</span><span class=\"token function\">setCompoundDrawables</span><span class=\"token punctuation\">(</span>leftDrawable<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"InverseMethod\"><a href=\"#InverseMethod\" class=\"headerlink\" title=\"InverseMethod\"></a>InverseMethod</h3><p>在双向绑定中，需要对值进行转换<br>比如我们有个checkbox，如果model中的一个String类型的值是“Alice”就让checkbox选上，反之不勾选，这里就要用到InverseMethod注解<br>新建一个Converter类，写了两个静态方法：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Converter</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@InverseMethod</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"convertStringToBool\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> String <span class=\"token function\">convertBoolToString</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token string\">\"Alice\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span> <span class=\"token string\">\"Unknown\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">convertStringToBool</span><span class=\"token punctuation\">(</span>String name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"Alice\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>布局文件：</p>\n<pre class=\"line-numbers language-xml\"><code class=\"language-xml\">    <span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>layout</span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>android</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://schemas.android.com/apk/res/android<span class=\"token punctuation\">\"</span></span>\n    <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>app</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://schemas.android.com/apk/res-auto<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>data</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span>\n            <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>person<span class=\"token punctuation\">\"</span></span>\n            <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.hiray.mvvm.mvvm.model.Person<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>import</span> <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.hiray.mvvm.mvvm.attr.Converter<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>data</span><span class=\"token punctuation\">></span></span>\n\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>android.support.v7.widget.AppCompatCheckBox</span>\n            <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>checked</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@<span class=\"token punctuation\">=</span>{Converter.convertStringToBool(person.personName)}<span class=\"token punctuation\">\"</span></span>\n            <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n            <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>layout</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"给自定义控件支持双向绑定\"><a href=\"#给自定义控件支持双向绑定\" class=\"headerlink\" title=\"给自定义控件支持双向绑定\"></a>给自定义控件支持双向绑定</h3><p>这里有个自定义的BlinkView，不停的闪烁，由一个bool 类型的值 blink控制是否闪烁，伪代码如下：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BlinkView</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">View</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> Paint paint<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">boolean</span> blink <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setBlink</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> blink<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>blink <span class=\"token operator\">=</span> blink<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">invalidate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">getBlink</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> blink<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">toggle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setBlink</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>blink<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>onBlinkChangeListener <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n            onBlinkChangeListener<span class=\"token punctuation\">.</span><span class=\"token function\">onBlinkChange</span><span class=\"token punctuation\">(</span>blink<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">OnBlinkChangeListener</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">void</span> <span class=\"token function\">onBlinkChange</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> blink<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> OnBlinkChangeListener onBlinkChangeListener<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setOnBlinkChangeListener</span><span class=\"token punctuation\">(</span>OnBlinkChangeListener onBlinkChangeListener<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>onBlinkChangeListener <span class=\"token operator\">=</span> onBlinkChangeListener<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>layout文件中：</p>\n<pre class=\"line-numbers language-xml\"><code class=\"language-xml\"><span class=\"token prolog\">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>layout</span> <span class=\"token attr-name\"><span class=\"token namespace\">xmlns:</span>android</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>http://schemas.android.com/apk/res/android<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>data</span><span class=\"token punctuation\">></span></span>\n\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>variable</span>\n            <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>data<span class=\"token punctuation\">\"</span></span>\n            <span class=\"token attr-name\">type</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.hiray.mvvm.mvvm.model.DataHolder<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>data</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>com.hiray.mvvm.mvvm.widget.BlinkView</span>\n            <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_width</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n            <span class=\"token attr-name\"><span class=\"token namespace\">android:</span>layout_height</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>wrap_content<span class=\"token punctuation\">\"</span></span>\n            <span class=\"token attr-name\"><span class=\"token namespace\">app:</span>blink</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@<span class=\"token punctuation\">=</span>{data.blink}<span class=\"token punctuation\">\"</span></span>\n            <span class=\"token attr-name\"><span class=\"token namespace\">app:</span>blinkColor</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>@color/colorAccent<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>layout</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这样写显然不会有任何效果，建立一个名为BlinkViewAdapter的类，使用InverseBindingMethods注解告诉Android在遇到app:blink属性的时候怎么把数据映射到UI上，然后又要告诉AndroidUI怎么映射到数据上，代码如下：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">    <span class=\"token annotation punctuation\">@InverseBindingMethods</span><span class=\"token punctuation\">(</span>\n        <span class=\"token annotation punctuation\">@InverseBindingMethod</span><span class=\"token punctuation\">(</span>type <span class=\"token operator\">=</span> BlinkView<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span>\n                attribute <span class=\"token operator\">=</span> <span class=\"token string\">\"blink\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">BlinkViewAdapter</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//    @InverseBindingAdapter(attribute = \"app:blink\")</span>\n<span class=\"token comment\" spellcheck=\"true\">//    public static boolean isBlink(BlinkView view) {</span>\n<span class=\"token comment\" spellcheck=\"true\">//        return view.getBlink();</span>\n<span class=\"token comment\" spellcheck=\"true\">//    }</span>\n\n    <span class=\"token annotation punctuation\">@BindingAdapter</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"app:blinkChanged\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"app:blinkAttrChanged\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> requireAll <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setListener</span><span class=\"token punctuation\">(</span>BlinkView view<span class=\"token punctuation\">,</span> BlinkView<span class=\"token punctuation\">.</span>OnBlinkChangeListener listener<span class=\"token punctuation\">,</span>\n                                   <span class=\"token keyword\">final</span> InverseBindingListener attrChange<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>attrChange <span class=\"token operator\">==</span> null <span class=\"token operator\">&amp;&amp;</span> listener <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n            view<span class=\"token punctuation\">.</span><span class=\"token function\">setOnBlinkChangeListener</span><span class=\"token punctuation\">(</span>listener<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> view<span class=\"token punctuation\">.</span><span class=\"token function\">setOnBlinkChangeListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BlinkView<span class=\"token punctuation\">.</span>OnBlinkChangeListener</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onBlinkChange</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> blink<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                attrChange<span class=\"token punctuation\">.</span><span class=\"token function\">onChange</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>其中InverseBindingMethod注解有三个参数：type表示你要绑定的类，attribute就是你要进行绑定的属性（就是写在xml上的属性），method默认按照属性名字去找有没有 isXX 或者getXX方法，不然你就写上method名字，如果没有直接的method名字，可以使用InverseBindingAdapter注解（代码中注释的部分），这是告诉系统在UI发生变化的时候调用什么方法获取UI信息这里Android默认是按照属性名字去找有没有 xxAttrChanged的（如果你自己没有定义的话），当然这个event可以自己定义，比如你定义成”abcdefg&amp;%##$”,那么上面setListener方法的BindingAdapter注解的”app:blinkAttrChanged”也得改成这个。<br>另外setListener有三个参数，第一个是控件BlinkView自己，第二个是BlinkView.OnBlinkChangeListener 和”app:blinkChanged”对应；第三个是InverseBindingListener是必须的，这个参数的实现在编译期就生成了，就是通知系统UI变化了，要更新ui信息到数据上（更新的方法就是前面的第一部分），可以看下生成的attrChange:</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">     <span class=\"token keyword\">private</span> android<span class=\"token punctuation\">.</span>databinding<span class=\"token punctuation\">.</span>InverseBindingListener mboundView3blinkAttrChange <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">android<span class=\"token punctuation\">.</span>databinding<span class=\"token punctuation\">.</span>InverseBindingListener</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onChange</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// Inverse of data.blink</span>\n            <span class=\"token comment\" spellcheck=\"true\">//         is data.setBlink((boolean) callbackArg_0)</span>\n            <span class=\"token keyword\">boolean</span> callbackArg_0 <span class=\"token operator\">=</span> mboundView3<span class=\"token punctuation\">.</span><span class=\"token function\">getBlink</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// localize variables for thread safety</span>\n            <span class=\"token comment\" spellcheck=\"true\">// data.blink</span>\n            <span class=\"token keyword\">boolean</span> dataBlink <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// data != null</span>\n            <span class=\"token keyword\">boolean</span> dataJavaLangObjectNull <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// data</span>\n            com<span class=\"token punctuation\">.</span>hiray<span class=\"token punctuation\">.</span>mvvm<span class=\"token punctuation\">.</span>mvvm<span class=\"token punctuation\">.</span>model<span class=\"token punctuation\">.</span>DataHolder data <span class=\"token operator\">=</span> mData<span class=\"token punctuation\">;</span>\n\n\n\n            dataJavaLangObjectNull <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token punctuation\">(</span>null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>dataJavaLangObjectNull<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\n\n\n                data<span class=\"token punctuation\">.</span><span class=\"token function\">setBlink</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span>callbackArg_0<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>看到这里其实就明白了，这里生成的东西都是根据前面的注解来的，收到刷新提示就会调用方法获取UI信息，并且更新数据模型中的值，由此完成了整个的双向的绑定</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Android的DataBinding出来很久了，但是因为我一直用的mvp，出来的时候就简单的 开启了enable =true这句代码弄了下搞了个简单的layout布局就没管了（好吧，貌似只能算单向绑定=_=）。然后最近想深入的看下DataBinding，比如自定义的控件怎么实现双向绑定,一步一步来吧，其实东西真的不多，不过很强大,基本都是注解。</p>\n<p>###简单的绑定<br>先建立一个Worker类：</p>\n<pre><code class=\"java\">    public class Worker {\n\n    public int workerId;\n    public String name;\n    public int wage;\n    public String photoUrl;\n    public int photoId;\n\n    public Worker() {\n    }\n\n\n    public Worker(int workerId, String name, int wage, int photoId) {\n        this.workerId = workerId;\n        this.name = name;\n        this.wage = wage;\n        this.photoId = photoId;\n    }\n}\n</code></pre>\n<p>这是一个简单的布局文件(data_binding_layout.xml)，在TextView上显示Worker的名字：</p>\n<pre><code class=\"xml\">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n\n\n    &lt;data&gt;\n\n        &lt;variable\n            name=&quot;worker&quot;\n            type=&quot;com.hiray.mvvm.mvvm.model.Worker&quot; /&gt;\n\n    &lt;/data&gt;\n\n    &lt;TextView\n        android:layout_width=&quot;120dp&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:text=&quot;@{worker.name}&quot; /&gt;  \n&lt;/layout&gt;\n</code></pre>\n<p>会根据布局文件名字生成一个ViewDataBinding对象————DataBindingLayoutBinding,在代码中设置一下：</p>\n<pre><code class=\"java\">       public class DataBindingActivity extends AppCompatActivity {\n            @Override\n            protected void onCreate(Bundle savedInstanceState) {\n                super.onCreate(savedInstanceState);\n                DataBindingLayoutBinding binding = DataBindingUtil.setContentView(this, R.layout.data_binding_layout);\n                binding.setWorker(new Worker(1205, &quot;Mike&quot;, 12000, R.mipmap.boy);\n            }\n        }\n</code></pre>\n<p>以上是非常简单的一种绑定，只是单向的数据绑定，数据映射到UI上<br>关于这样的单向绑定有好几个注解</p>\n<h3 id=\"BindingMethods、BindingMethod\"><a href=\"#BindingMethods、BindingMethod\" class=\"headerlink\" title=\"BindingMethods、BindingMethod\"></a>BindingMethods、BindingMethod</h3><p>比如我想给ImageView加上自定义的属性下载图片</p>\n<pre><code class=\"xml\">        &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n\n\n    &lt;data&gt;\n\n        &lt;variable\n            name=&quot;worker&quot;\n            type=&quot;com.hiray.mvvm.mvvm.model.Worker&quot; /&gt;\n\n    &lt;/data&gt;\n\n    &lt;ImageView\n        app:imageDrawable=&quot;@{worker.photoId}&quot;\n        android:layout_width=&quot;50dp&quot;\n        android:layout_height=&quot;50dp&quot;/&gt;  \n&lt;/layout&gt;\n</code></pre>\n<p>这里”app:imageDrawable”这个属性是无法被识别的，会编译出错，我们要通过某种方式告诉系统该怎么做。我们建立一个类 ViewBindingAdapter，使用BindingMethods和BindingMethod注解：</p>\n<pre><code class=\"java\">@BindingMethods(\n        @BindingMethod(\n                type = ImageView.class,\n                attribute = &quot;app:imageDrawable&quot;,\n                method = &quot;setImageResource&quot;\n        )\n)\npublic class ImageAttr {\n\n\n}\n</code></pre>\n<p>其中type是你要绑定的类，attribute是你自己定的,method是ImageView中的方法，也就是告诉ImageView，在xml中碰到app:imageDrawable属性的时候调用ImageView的setImageResource方法。<br>但是如果我此时不想传入图片id，而是传入一个id的String字符，那怎么办呢，因为ImageView并没有接收String参数来设置图片的方法，那么我们要利用BindConversion转换一下</p>\n<h3 id=\"BindingConversion\"><a href=\"#BindingConversion\" class=\"headerlink\" title=\"BindingConversion\"></a>BindingConversion</h3><pre><code class=\"java\">\npublic class ImageAttr {\n\n    @BindingConversion\n    public static int convertStringToResId(String idString){\n        return Integer.parseInt(idString);\n    }\n\n}\n</code></pre>\n<p>但是有些时候即使转换了，也没有对应的setter方法可以使用，比如你设置drawableLeft这种属性的时候，是没有setDrawableLeft方法的，只有setCompoundDrawable,那么这时候就可以使用 BindingAdapter这个注解了</p>\n<h3 id=\"BindingAdapter\"><a href=\"#BindingAdapter\" class=\"headerlink\" title=\"BindingAdapter\"></a>BindingAdapter</h3><p>顾名思义是绑定适配器，如果像设置的属性没有直接的方法，需要转换一下，那么就用到这个注解，比如设置drawableLeft,是没有setDrawableLeft方法的，必须调用view的setCompoundDrawables</p>\n<pre><code class=\"java\">\npublic class ImageAttr {\n\n    @BindingAdapter(&quot;app:drawableLeft&quot;)\n    public static void bindDrawableLeft(TextView view, Drawable leftDrawable) {\n        view.setCompoundDrawables(leftDrawable, null, null, null);\n    }\n\n}\n</code></pre>\n<h3 id=\"InverseMethod\"><a href=\"#InverseMethod\" class=\"headerlink\" title=\"InverseMethod\"></a>InverseMethod</h3><p>在双向绑定中，需要对值进行转换<br>比如我们有个checkbox，如果model中的一个String类型的值是“Alice”就让checkbox选上，反之不勾选，这里就要用到InverseMethod注解<br>新建一个Converter类，写了两个静态方法：</p>\n<pre><code class=\"java\">    public class Converter {\n\n    @InverseMethod(&quot;convertStringToBool&quot;)\n    public static String convertBoolToString(boolean b) {\n        if (b)\n            return &quot;Alice&quot;;\n        else return &quot;Unknown&quot;;\n    }\n\n    public static boolean convertStringToBool(String name) {\n        return &quot;Alice&quot;.equals(name);\n    }\n}\n</code></pre>\n<p>布局文件：</p>\n<pre><code class=\"xml\">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;\n\n    &lt;data&gt;\n        &lt;variable\n            name=&quot;person&quot;\n            type=&quot;com.hiray.mvvm.mvvm.model.Person&quot;/&gt;\n        &lt;import type=&quot;com.hiray.mvvm.mvvm.attr.Converter&quot;/&gt;\n    &lt;/data&gt;\n\n        &lt;android.support.v7.widget.AppCompatCheckBox\n            android:checked=&quot;@={Converter.convertStringToBool(person.personName)}&quot;\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;wrap_content&quot; /&gt;\n\n&lt;/layout&gt;\n</code></pre>\n<h3 id=\"给自定义控件支持双向绑定\"><a href=\"#给自定义控件支持双向绑定\" class=\"headerlink\" title=\"给自定义控件支持双向绑定\"></a>给自定义控件支持双向绑定</h3><p>这里有个自定义的BlinkView，不停的闪烁，由一个bool 类型的值 blink控制是否闪烁，伪代码如下：</p>\n<pre><code class=\"java\">    public class BlinkView extends View {\n\n    private Paint paint;\n    boolean blink = true;\n    ......\n\n    public void setBlink(boolean blink) {\n        this.blink = blink;\n        invalidate();\n    }\n\n    public boolean getBlink(){\n        return blink;\n    }\n    public void toggle() {\n        setBlink(!blink);\n        if (onBlinkChangeListener != null)\n            onBlinkChangeListener.onBlinkChange(blink);\n    }\n\n    public interface OnBlinkChangeListener {\n        void onBlinkChange(boolean blink);\n    }\n\n    private OnBlinkChangeListener onBlinkChangeListener;\n\n    public void setOnBlinkChangeListener(OnBlinkChangeListener onBlinkChangeListener) {\n        this.onBlinkChangeListener = onBlinkChangeListener;\n    }\n}\n</code></pre>\n<p>layout文件中：</p>\n<pre><code class=\"xml\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n\n    &lt;data&gt;\n\n        &lt;variable\n            name=&quot;data&quot;\n            type=&quot;com.hiray.mvvm.mvvm.model.DataHolder&quot; /&gt;\n\n\n    &lt;/data&gt;\n        &lt;com.hiray.mvvm.mvvm.widget.BlinkView\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            app:blink=&quot;@={data.blink}&quot;\n            app:blinkColor=&quot;@color/colorAccent&quot; /&gt;\n\n&lt;/layout&gt;\n</code></pre>\n<p>这样写显然不会有任何效果，建立一个名为BlinkViewAdapter的类，使用InverseBindingMethods注解告诉Android在遇到app:blink属性的时候怎么把数据映射到UI上，然后又要告诉AndroidUI怎么映射到数据上，代码如下：</p>\n<pre><code class=\"java\">    @InverseBindingMethods(\n        @InverseBindingMethod(type = BlinkView.class,\n                attribute = &quot;blink&quot;)\n)\npublic class BlinkViewAdapter {\n\n//    @InverseBindingAdapter(attribute = &quot;app:blink&quot;)\n//    public static boolean isBlink(BlinkView view) {\n//        return view.getBlink();\n//    }\n\n    @BindingAdapter(value = {&quot;app:blinkChanged&quot;, &quot;app:blinkAttrChanged&quot;}, requireAll = false)\n    public static void setListener(BlinkView view, BlinkView.OnBlinkChangeListener listener,\n                                   final InverseBindingListener attrChange) {\n\n        if (attrChange == null &amp;&amp; listener != null)\n            view.setOnBlinkChangeListener(listener);\n        else view.setOnBlinkChangeListener(new BlinkView.OnBlinkChangeListener() {\n            @Override\n            public void onBlinkChange(boolean blink) {\n                attrChange.onChange();\n            }\n        });\n\n    }\n\n}\n</code></pre>\n<p>其中InverseBindingMethod注解有三个参数：type表示你要绑定的类，attribute就是你要进行绑定的属性（就是写在xml上的属性），method默认按照属性名字去找有没有 isXX 或者getXX方法，不然你就写上method名字，如果没有直接的method名字，可以使用InverseBindingAdapter注解（代码中注释的部分），这是告诉系统在UI发生变化的时候调用什么方法获取UI信息这里Android默认是按照属性名字去找有没有 xxAttrChanged的（如果你自己没有定义的话），当然这个event可以自己定义，比如你定义成”abcdefg&amp;%##$”,那么上面setListener方法的BindingAdapter注解的”app:blinkAttrChanged”也得改成这个。<br>另外setListener有三个参数，第一个是控件BlinkView自己，第二个是BlinkView.OnBlinkChangeListener 和”app:blinkChanged”对应；第三个是InverseBindingListener是必须的，这个参数的实现在编译期就生成了，就是通知系统UI变化了，要更新ui信息到数据上（更新的方法就是前面的第一部分），可以看下生成的attrChange:</p>\n<pre><code class=\"java\">     private android.databinding.InverseBindingListener mboundView3blinkAttrChange = new android.databinding.InverseBindingListener() {\n        @Override\n        public void onChange() {\n            // Inverse of data.blink\n            //         is data.setBlink((boolean) callbackArg_0)\n            boolean callbackArg_0 = mboundView3.getBlink();\n            // localize variables for thread safety\n            // data.blink\n            boolean dataBlink = false;\n            // data != null\n            boolean dataJavaLangObjectNull = false;\n            // data\n            com.hiray.mvvm.mvvm.model.DataHolder data = mData;\n\n\n\n            dataJavaLangObjectNull = (data) != (null);\n            if (dataJavaLangObjectNull) {\n\n\n\n\n                data.setBlink(((boolean) (callbackArg_0)));\n            }\n        }\n    };\n</code></pre>\n<p>看到这里其实就明白了，这里生成的东西都是根据前面的注解来的，收到刷新提示就会调用方法获取UI信息，并且更新数据模型中的值，由此完成了整个的双向的绑定</p>\n"},{"title":"自行处理Fling导致RecyclerView 滑动点击事件无效","date":"2018-04-02T01:00:44.000Z","_content":"之前写过StackLayoutManager,一个自定义的LayoutManager，最近有同学说滑动之后item 点击无效，发现是滑动之后第一次点击无效，再次点击才能触发点击事件。第一反应觉得很诧异，要么就不触发，怎么还要点击两次才能触发的。带着疑问我调试了一下RecyclerView的onInterceptTouchEvent方法。结果是fling一次后点击item ，onInterceptTouchEvent方法返回了true，也就是事件被拦截了，就是导致Item无法点击的原因，拦截的条件是mScrollState == STATE_DRAGGING。但是明显现在应该处于STATE_IDLE状态，fling之后手指已经离开屏幕了。所以继续追踪，发现RecyclerView的fling事件内部自己有处理，而且fling完之后，会将mScrollState重置为STATE_IDLE，但是因为StackLayoutManager是使用的setOnFlingListener方式，导致没有重置状态，所以之后的第一次点击mScrollState仍然处于STATE_DRAGGING状态，所以被拦截了。但是我们是第二次点击又是可以的，所以肯定是第一次点击的某个地方将mScrollState重置为STATE_IDLE了，找了下，发现RecyclerView的onTouchEvent方法有这么一句\n```java\n                if (!((xvel != 0 || yvel != 0) && fling((int) xvel, (int) yvel))) {\n                    setScrollState(SCROLL_STATE_IDLE);\n                }\n```\n知道了前因后果之后，我们要做的就是自己处理fling之后应该将mScrollState重置为idle状态，但是RecylerView改变状态的方法并不对外暴露，所以最后我用了反射。","source":"_posts/自行处理Fling导致RecyclerView-滑动点击事件无效.md","raw":"---\ntitle: 自行处理Fling导致RecyclerView 滑动点击事件无效\ndate: 2018-04-02 09:00:44\ntags:\n    - RecyclerView \n    - Fling ItemClick\n---\n之前写过StackLayoutManager,一个自定义的LayoutManager，最近有同学说滑动之后item 点击无效，发现是滑动之后第一次点击无效，再次点击才能触发点击事件。第一反应觉得很诧异，要么就不触发，怎么还要点击两次才能触发的。带着疑问我调试了一下RecyclerView的onInterceptTouchEvent方法。结果是fling一次后点击item ，onInterceptTouchEvent方法返回了true，也就是事件被拦截了，就是导致Item无法点击的原因，拦截的条件是mScrollState == STATE_DRAGGING。但是明显现在应该处于STATE_IDLE状态，fling之后手指已经离开屏幕了。所以继续追踪，发现RecyclerView的fling事件内部自己有处理，而且fling完之后，会将mScrollState重置为STATE_IDLE，但是因为StackLayoutManager是使用的setOnFlingListener方式，导致没有重置状态，所以之后的第一次点击mScrollState仍然处于STATE_DRAGGING状态，所以被拦截了。但是我们是第二次点击又是可以的，所以肯定是第一次点击的某个地方将mScrollState重置为STATE_IDLE了，找了下，发现RecyclerView的onTouchEvent方法有这么一句\n```java\n                if (!((xvel != 0 || yvel != 0) && fling((int) xvel, (int) yvel))) {\n                    setScrollState(SCROLL_STATE_IDLE);\n                }\n```\n知道了前因后果之后，我们要做的就是自己处理fling之后应该将mScrollState重置为idle状态，但是RecylerView改变状态的方法并不对外暴露，所以最后我用了反射。","slug":"自行处理Fling导致RecyclerView-滑动点击事件无效","published":1,"updated":"2018-04-02T01:24:55.558Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl1qvapw000ly472cr00g6ec","content":"<p>之前写过StackLayoutManager,一个自定义的LayoutManager，最近有同学说滑动之后item 点击无效，发现是滑动之后第一次点击无效，再次点击才能触发点击事件。第一反应觉得很诧异，要么就不触发，怎么还要点击两次才能触发的。带着疑问我调试了一下RecyclerView的onInterceptTouchEvent方法。结果是fling一次后点击item ，onInterceptTouchEvent方法返回了true，也就是事件被拦截了，就是导致Item无法点击的原因，拦截的条件是mScrollState == STATE_DRAGGING。但是明显现在应该处于STATE_IDLE状态，fling之后手指已经离开屏幕了。所以继续追踪，发现RecyclerView的fling事件内部自己有处理，而且fling完之后，会将mScrollState重置为STATE_IDLE，但是因为StackLayoutManager是使用的setOnFlingListener方式，导致没有重置状态，所以之后的第一次点击mScrollState仍然处于STATE_DRAGGING状态，所以被拦截了。但是我们是第二次点击又是可以的，所以肯定是第一次点击的某个地方将mScrollState重置为STATE_IDLE了，找了下，发现RecyclerView的onTouchEvent方法有这么一句</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\">                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>xvel <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> yvel <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">fling</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> xvel<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> yvel<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">setScrollState</span><span class=\"token punctuation\">(</span>SCROLL_STATE_IDLE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>知道了前因后果之后，我们要做的就是自己处理fling之后应该将mScrollState重置为idle状态，但是RecylerView改变状态的方法并不对外暴露，所以最后我用了反射。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前写过StackLayoutManager,一个自定义的LayoutManager，最近有同学说滑动之后item 点击无效，发现是滑动之后第一次点击无效，再次点击才能触发点击事件。第一反应觉得很诧异，要么就不触发，怎么还要点击两次才能触发的。带着疑问我调试了一下RecyclerView的onInterceptTouchEvent方法。结果是fling一次后点击item ，onInterceptTouchEvent方法返回了true，也就是事件被拦截了，就是导致Item无法点击的原因，拦截的条件是mScrollState == STATE_DRAGGING。但是明显现在应该处于STATE_IDLE状态，fling之后手指已经离开屏幕了。所以继续追踪，发现RecyclerView的fling事件内部自己有处理，而且fling完之后，会将mScrollState重置为STATE_IDLE，但是因为StackLayoutManager是使用的setOnFlingListener方式，导致没有重置状态，所以之后的第一次点击mScrollState仍然处于STATE_DRAGGING状态，所以被拦截了。但是我们是第二次点击又是可以的，所以肯定是第一次点击的某个地方将mScrollState重置为STATE_IDLE了，找了下，发现RecyclerView的onTouchEvent方法有这么一句</p>\n<pre><code class=\"java\">                if (!((xvel != 0 || yvel != 0) &amp;&amp; fling((int) xvel, (int) yvel))) {\n                    setScrollState(SCROLL_STATE_IDLE);\n                }\n</code></pre>\n<p>知道了前因后果之后，我们要做的就是自己处理fling之后应该将mScrollState重置为idle状态，但是RecylerView改变状态的方法并不对外暴露，所以最后我用了反射。</p>\n"},{"title":"关于RecyclerView的一个有趣的事情","date":"2018-01-19T07:22:22.000Z","_content":"对于RecylcerView ，基本上第一印象就是View重用，但是真的明白怎么重用的吗，最近在写自定义LayoutManager,由此对RecylerView、LayoutManager、ItemAnimator整个之间的关系都比较的熟悉。不过回到标题上来，这个有趣的事情和RV的回收有关。\n\n比如页面上此时显示了前六条Item（第六个Item没有显示全），那么你肯定觉得不把第六条Item全部划进来，第七条就不会调用onCreateViewHolder进行创建；但事实是当我只要向上稍微滑出去一点就会创建第七个Item，这是不是和对RV的回收重用的印象有些矛盾？是的，按照常理，我根本都没有滑出第七个Item，你就创建了，好像不太对。\n\n最后我看了下源码，其实原因比较简单，得先贴一下滑动发生时候调用填充逻辑的方法代码（部分代码）：\n```java\n int fill(RecyclerView.Recycler recycler, LayoutState layoutState,\n            RecyclerView.State state, boolean stopOnFocusable) {\n        int remainingSpace = layoutState.mAvailable + layoutState.mExtra;\n        LayoutChunkResult layoutChunkResult = mLayoutChunkResult;\n        while ((layoutState.mInfinite || remainingSpace > 0) && layoutState.hasMore(state)) {\n            layoutChunkResult.resetInternal();\n            layoutChunk(recycler, state, layoutState, layoutChunkResult);\n            if (layoutChunkResult.mFinished) {\n                break;\n            }\n            layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;\n            if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {\n                layoutState.mScrollingOffset += layoutChunkResult.mConsumed;\n                if (layoutState.mAvailable < 0) {\n                    layoutState.mScrollingOffset += layoutState.mAvailable;\n                }\n                recycleByLayoutState(recycler, layoutState);\n            }\n        }\n\n        return start - layoutState.mAvailable;\n    }\n```\n\n因为当滑动发生的时候，填充的postion是从第七个Item开始的，所以第七个Item被创建了，但是呢，立马被 recycleByLayoutState(recycler, layoutState)这个方法给回收掉了，并且缓存了起来，毕竟第七个Item在屏幕外，所以被回收了，而且这个while跑了这一次就退出了，到了第七个Item真的出来的时候就直接从缓存里面取出来用了\n\nNote：\"scrap\" View指的是仍然有效可以直接拿来重用的VH，只是暂时脱离了RV。名字让人很误解。","source":"_posts/关于RecyclerView的一个有趣的事情.md","raw":"---\ntitle: 关于RecyclerView的一个有趣的事情\ndate: 2018-01-19 15:22:22\ntags: -RecyclerView \n      -Android\n---\n对于RecylcerView ，基本上第一印象就是View重用，但是真的明白怎么重用的吗，最近在写自定义LayoutManager,由此对RecylerView、LayoutManager、ItemAnimator整个之间的关系都比较的熟悉。不过回到标题上来，这个有趣的事情和RV的回收有关。\n\n比如页面上此时显示了前六条Item（第六个Item没有显示全），那么你肯定觉得不把第六条Item全部划进来，第七条就不会调用onCreateViewHolder进行创建；但事实是当我只要向上稍微滑出去一点就会创建第七个Item，这是不是和对RV的回收重用的印象有些矛盾？是的，按照常理，我根本都没有滑出第七个Item，你就创建了，好像不太对。\n\n最后我看了下源码，其实原因比较简单，得先贴一下滑动发生时候调用填充逻辑的方法代码（部分代码）：\n```java\n int fill(RecyclerView.Recycler recycler, LayoutState layoutState,\n            RecyclerView.State state, boolean stopOnFocusable) {\n        int remainingSpace = layoutState.mAvailable + layoutState.mExtra;\n        LayoutChunkResult layoutChunkResult = mLayoutChunkResult;\n        while ((layoutState.mInfinite || remainingSpace > 0) && layoutState.hasMore(state)) {\n            layoutChunkResult.resetInternal();\n            layoutChunk(recycler, state, layoutState, layoutChunkResult);\n            if (layoutChunkResult.mFinished) {\n                break;\n            }\n            layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;\n            if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {\n                layoutState.mScrollingOffset += layoutChunkResult.mConsumed;\n                if (layoutState.mAvailable < 0) {\n                    layoutState.mScrollingOffset += layoutState.mAvailable;\n                }\n                recycleByLayoutState(recycler, layoutState);\n            }\n        }\n\n        return start - layoutState.mAvailable;\n    }\n```\n\n因为当滑动发生的时候，填充的postion是从第七个Item开始的，所以第七个Item被创建了，但是呢，立马被 recycleByLayoutState(recycler, layoutState)这个方法给回收掉了，并且缓存了起来，毕竟第七个Item在屏幕外，所以被回收了，而且这个while跑了这一次就退出了，到了第七个Item真的出来的时候就直接从缓存里面取出来用了\n\nNote：\"scrap\" View指的是仍然有效可以直接拿来重用的VH，只是暂时脱离了RV。名字让人很误解。","slug":"关于RecyclerView的一个有趣的事情","published":1,"updated":"2018-01-20T08:06:53.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl1qvapx000ny472iindyrsa","content":"<p>对于RecylcerView ，基本上第一印象就是View重用，但是真的明白怎么重用的吗，最近在写自定义LayoutManager,由此对RecylerView、LayoutManager、ItemAnimator整个之间的关系都比较的熟悉。不过回到标题上来，这个有趣的事情和RV的回收有关。</p>\n<p>比如页面上此时显示了前六条Item（第六个Item没有显示全），那么你肯定觉得不把第六条Item全部划进来，第七条就不会调用onCreateViewHolder进行创建；但事实是当我只要向上稍微滑出去一点就会创建第七个Item，这是不是和对RV的回收重用的印象有些矛盾？是的，按照常理，我根本都没有滑出第七个Item，你就创建了，好像不太对。</p>\n<p>最后我看了下源码，其实原因比较简单，得先贴一下滑动发生时候调用填充逻辑的方法代码（部分代码）：</p>\n<pre class=\"line-numbers language-java\"><code class=\"language-java\"> <span class=\"token keyword\">int</span> <span class=\"token function\">fill</span><span class=\"token punctuation\">(</span>RecyclerView<span class=\"token punctuation\">.</span>Recycler recycler<span class=\"token punctuation\">,</span> LayoutState layoutState<span class=\"token punctuation\">,</span>\n            RecyclerView<span class=\"token punctuation\">.</span>State state<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> stopOnFocusable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> remainingSpace <span class=\"token operator\">=</span> layoutState<span class=\"token punctuation\">.</span>mAvailable <span class=\"token operator\">+</span> layoutState<span class=\"token punctuation\">.</span>mExtra<span class=\"token punctuation\">;</span>\n        LayoutChunkResult layoutChunkResult <span class=\"token operator\">=</span> mLayoutChunkResult<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mInfinite <span class=\"token operator\">||</span> remainingSpace <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> layoutState<span class=\"token punctuation\">.</span><span class=\"token function\">hasMore</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            layoutChunkResult<span class=\"token punctuation\">.</span><span class=\"token function\">resetInternal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">layoutChunk</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">,</span> layoutState<span class=\"token punctuation\">,</span> layoutChunkResult<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>layoutChunkResult<span class=\"token punctuation\">.</span>mFinished<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            layoutState<span class=\"token punctuation\">.</span>mOffset <span class=\"token operator\">+=</span> layoutChunkResult<span class=\"token punctuation\">.</span>mConsumed <span class=\"token operator\">*</span> layoutState<span class=\"token punctuation\">.</span>mLayoutDirection<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mScrollingOffset <span class=\"token operator\">!=</span> LayoutState<span class=\"token punctuation\">.</span>SCROLLING_OFFSET_NaN<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                layoutState<span class=\"token punctuation\">.</span>mScrollingOffset <span class=\"token operator\">+=</span> layoutChunkResult<span class=\"token punctuation\">.</span>mConsumed<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>layoutState<span class=\"token punctuation\">.</span>mAvailable <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    layoutState<span class=\"token punctuation\">.</span>mScrollingOffset <span class=\"token operator\">+=</span> layoutState<span class=\"token punctuation\">.</span>mAvailable<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token function\">recycleByLayoutState</span><span class=\"token punctuation\">(</span>recycler<span class=\"token punctuation\">,</span> layoutState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">return</span> start <span class=\"token operator\">-</span> layoutState<span class=\"token punctuation\">.</span>mAvailable<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>因为当滑动发生的时候，填充的postion是从第七个Item开始的，所以第七个Item被创建了，但是呢，立马被 recycleByLayoutState(recycler, layoutState)这个方法给回收掉了，并且缓存了起来，毕竟第七个Item在屏幕外，所以被回收了，而且这个while跑了这一次就退出了，到了第七个Item真的出来的时候就直接从缓存里面取出来用了</p>\n<p>Note：”scrap” View指的是仍然有效可以直接拿来重用的VH，只是暂时脱离了RV。名字让人很误解。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>对于RecylcerView ，基本上第一印象就是View重用，但是真的明白怎么重用的吗，最近在写自定义LayoutManager,由此对RecylerView、LayoutManager、ItemAnimator整个之间的关系都比较的熟悉。不过回到标题上来，这个有趣的事情和RV的回收有关。</p>\n<p>比如页面上此时显示了前六条Item（第六个Item没有显示全），那么你肯定觉得不把第六条Item全部划进来，第七条就不会调用onCreateViewHolder进行创建；但事实是当我只要向上稍微滑出去一点就会创建第七个Item，这是不是和对RV的回收重用的印象有些矛盾？是的，按照常理，我根本都没有滑出第七个Item，你就创建了，好像不太对。</p>\n<p>最后我看了下源码，其实原因比较简单，得先贴一下滑动发生时候调用填充逻辑的方法代码（部分代码）：</p>\n<pre><code class=\"java\"> int fill(RecyclerView.Recycler recycler, LayoutState layoutState,\n            RecyclerView.State state, boolean stopOnFocusable) {\n        int remainingSpace = layoutState.mAvailable + layoutState.mExtra;\n        LayoutChunkResult layoutChunkResult = mLayoutChunkResult;\n        while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) {\n            layoutChunkResult.resetInternal();\n            layoutChunk(recycler, state, layoutState, layoutChunkResult);\n            if (layoutChunkResult.mFinished) {\n                break;\n            }\n            layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;\n            if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {\n                layoutState.mScrollingOffset += layoutChunkResult.mConsumed;\n                if (layoutState.mAvailable &lt; 0) {\n                    layoutState.mScrollingOffset += layoutState.mAvailable;\n                }\n                recycleByLayoutState(recycler, layoutState);\n            }\n        }\n\n        return start - layoutState.mAvailable;\n    }\n</code></pre>\n<p>因为当滑动发生的时候，填充的postion是从第七个Item开始的，所以第七个Item被创建了，但是呢，立马被 recycleByLayoutState(recycler, layoutState)这个方法给回收掉了，并且缓存了起来，毕竟第七个Item在屏幕外，所以被回收了，而且这个while跑了这一次就退出了，到了第七个Item真的出来的时候就直接从缓存里面取出来用了</p>\n<p>Note：”scrap” View指的是仍然有效可以直接拿来重用的VH，只是暂时脱离了RV。名字让人很误解。</p>\n"},{"title":"关于事件机制的总结","date":"2018-04-19T08:24:05.000Z","_content":"事件分发影响到自定义控件以及处理一些特殊问题时候特别有用，一直没有总结一下，导致\n在碰到问题的时候思路不够清晰，其实对于单个View的事件分发其实很简单，稍微复杂点的其实\n是在有ViewGroup的情况下。也不用举什么例子，直接就总结吧：\n针对单个View\n所有的事件都从ACTION_DOWN开始，入口是dispatchTouchEvent,因为对于单个View没有拦截之说，所以在dispatchTouchEvent里面只是判断View有没有设置touch监听或者点击，如果有，那么事件就接管了，后续的事件都会直接发给这个View\n\n针对ViewGroup：\n一共有三个方法 dispatchTouchEvent onInterceptTouchEvent onTouchEvent,主要是说清楚这三个方法之间的关系\n\ndispatchTouch一样是入口，同样是从ACTION_DOWN开始，先是在dispatchTouchEvent里面调用了onInterceptTouchEvent，问ViewGroup自己需要拦截吗，如果拦截了，那么后续事件就交给ViewGroup的onTouchEvent,当然后续事件调用的方法顺序就是：dispatchTouchEvent(ViewGroup)————>onTouchEvent(ViewGroup);但是如果ACTION_DOWN事件被子View接管了，那么后续事件的调用的顺序：\ndispatchTouchEvent(ViewGroup)————>onInterceptTouchEvent(ViewGroup)————>onTouchEvent(View)\n但是如果View接管了事件，但是后续事件被ViewGroup拦截了的话，那么View还是会收到一个Cancel事件\n\n以上的总结本身在ViewGroup的onInterceptTouchEvent方法中有注释，之前没耐心看，最近因为和事件分发走的近，必须好好看懂这一块\n\n总之View只有一次机会来接管事件，也就是在ACTION_DOWN传过来的时候，不然以后都没机会了，直到下一次ACTION_DOWN来临。假如谁都不管这个事件，那么最后就会一直冒泡到Activity的onTouchEvent中去（这个很好验证，写个空白布局，重写下Activity的onTouchEvent，里面打个日志就知道了 ）因为如此，Android也推出了嵌套滚动，其实就是让子View无脑接管事件，但是呢，会在处理事件前先给parent处理，然后剩下的给自己，这样就让有些不好实现的效果（比如联动）好做很多","source":"_posts/关于事件机制的总结.md","raw":"---\ntitle: 关于事件机制的总结\ndate: 2018-04-19 16:24:05\ntags:\n    - Android\n    - 事件分发\n---\n事件分发影响到自定义控件以及处理一些特殊问题时候特别有用，一直没有总结一下，导致\n在碰到问题的时候思路不够清晰，其实对于单个View的事件分发其实很简单，稍微复杂点的其实\n是在有ViewGroup的情况下。也不用举什么例子，直接就总结吧：\n针对单个View\n所有的事件都从ACTION_DOWN开始，入口是dispatchTouchEvent,因为对于单个View没有拦截之说，所以在dispatchTouchEvent里面只是判断View有没有设置touch监听或者点击，如果有，那么事件就接管了，后续的事件都会直接发给这个View\n\n针对ViewGroup：\n一共有三个方法 dispatchTouchEvent onInterceptTouchEvent onTouchEvent,主要是说清楚这三个方法之间的关系\n\ndispatchTouch一样是入口，同样是从ACTION_DOWN开始，先是在dispatchTouchEvent里面调用了onInterceptTouchEvent，问ViewGroup自己需要拦截吗，如果拦截了，那么后续事件就交给ViewGroup的onTouchEvent,当然后续事件调用的方法顺序就是：dispatchTouchEvent(ViewGroup)————>onTouchEvent(ViewGroup);但是如果ACTION_DOWN事件被子View接管了，那么后续事件的调用的顺序：\ndispatchTouchEvent(ViewGroup)————>onInterceptTouchEvent(ViewGroup)————>onTouchEvent(View)\n但是如果View接管了事件，但是后续事件被ViewGroup拦截了的话，那么View还是会收到一个Cancel事件\n\n以上的总结本身在ViewGroup的onInterceptTouchEvent方法中有注释，之前没耐心看，最近因为和事件分发走的近，必须好好看懂这一块\n\n总之View只有一次机会来接管事件，也就是在ACTION_DOWN传过来的时候，不然以后都没机会了，直到下一次ACTION_DOWN来临。假如谁都不管这个事件，那么最后就会一直冒泡到Activity的onTouchEvent中去（这个很好验证，写个空白布局，重写下Activity的onTouchEvent，里面打个日志就知道了 ）因为如此，Android也推出了嵌套滚动，其实就是让子View无脑接管事件，但是呢，会在处理事件前先给parent处理，然后剩下的给自己，这样就让有些不好实现的效果（比如联动）好做很多","slug":"关于事件机制的总结","published":1,"updated":"2018-04-19T09:35:23.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjl1qvaq1000py47275kahvun","content":"<p>事件分发影响到自定义控件以及处理一些特殊问题时候特别有用，一直没有总结一下，导致<br>在碰到问题的时候思路不够清晰，其实对于单个View的事件分发其实很简单，稍微复杂点的其实<br>是在有ViewGroup的情况下。也不用举什么例子，直接就总结吧：<br>针对单个View<br>所有的事件都从ACTION_DOWN开始，入口是dispatchTouchEvent,因为对于单个View没有拦截之说，所以在dispatchTouchEvent里面只是判断View有没有设置touch监听或者点击，如果有，那么事件就接管了，后续的事件都会直接发给这个View</p>\n<p>针对ViewGroup：<br>一共有三个方法 dispatchTouchEvent onInterceptTouchEvent onTouchEvent,主要是说清楚这三个方法之间的关系</p>\n<p>dispatchTouch一样是入口，同样是从ACTION_DOWN开始，先是在dispatchTouchEvent里面调用了onInterceptTouchEvent，问ViewGroup自己需要拦截吗，如果拦截了，那么后续事件就交给ViewGroup的onTouchEvent,当然后续事件调用的方法顺序就是：dispatchTouchEvent(ViewGroup)————&gt;onTouchEvent(ViewGroup);但是如果ACTION_DOWN事件被子View接管了，那么后续事件的调用的顺序：<br>dispatchTouchEvent(ViewGroup)————&gt;onInterceptTouchEvent(ViewGroup)————&gt;onTouchEvent(View)<br>但是如果View接管了事件，但是后续事件被ViewGroup拦截了的话，那么View还是会收到一个Cancel事件</p>\n<p>以上的总结本身在ViewGroup的onInterceptTouchEvent方法中有注释，之前没耐心看，最近因为和事件分发走的近，必须好好看懂这一块</p>\n<p>总之View只有一次机会来接管事件，也就是在ACTION_DOWN传过来的时候，不然以后都没机会了，直到下一次ACTION_DOWN来临。假如谁都不管这个事件，那么最后就会一直冒泡到Activity的onTouchEvent中去（这个很好验证，写个空白布局，重写下Activity的onTouchEvent，里面打个日志就知道了 ）因为如此，Android也推出了嵌套滚动，其实就是让子View无脑接管事件，但是呢，会在处理事件前先给parent处理，然后剩下的给自己，这样就让有些不好实现的效果（比如联动）好做很多</p>\n","site":{"data":{}},"excerpt":"","more":"<p>事件分发影响到自定义控件以及处理一些特殊问题时候特别有用，一直没有总结一下，导致<br>在碰到问题的时候思路不够清晰，其实对于单个View的事件分发其实很简单，稍微复杂点的其实<br>是在有ViewGroup的情况下。也不用举什么例子，直接就总结吧：<br>针对单个View<br>所有的事件都从ACTION_DOWN开始，入口是dispatchTouchEvent,因为对于单个View没有拦截之说，所以在dispatchTouchEvent里面只是判断View有没有设置touch监听或者点击，如果有，那么事件就接管了，后续的事件都会直接发给这个View</p>\n<p>针对ViewGroup：<br>一共有三个方法 dispatchTouchEvent onInterceptTouchEvent onTouchEvent,主要是说清楚这三个方法之间的关系</p>\n<p>dispatchTouch一样是入口，同样是从ACTION_DOWN开始，先是在dispatchTouchEvent里面调用了onInterceptTouchEvent，问ViewGroup自己需要拦截吗，如果拦截了，那么后续事件就交给ViewGroup的onTouchEvent,当然后续事件调用的方法顺序就是：dispatchTouchEvent(ViewGroup)————&gt;onTouchEvent(ViewGroup);但是如果ACTION_DOWN事件被子View接管了，那么后续事件的调用的顺序：<br>dispatchTouchEvent(ViewGroup)————&gt;onInterceptTouchEvent(ViewGroup)————&gt;onTouchEvent(View)<br>但是如果View接管了事件，但是后续事件被ViewGroup拦截了的话，那么View还是会收到一个Cancel事件</p>\n<p>以上的总结本身在ViewGroup的onInterceptTouchEvent方法中有注释，之前没耐心看，最近因为和事件分发走的近，必须好好看懂这一块</p>\n<p>总之View只有一次机会来接管事件，也就是在ACTION_DOWN传过来的时候，不然以后都没机会了，直到下一次ACTION_DOWN来临。假如谁都不管这个事件，那么最后就会一直冒泡到Activity的onTouchEvent中去（这个很好验证，写个空白布局，重写下Activity的onTouchEvent，里面打个日志就知道了 ）因为如此，Android也推出了嵌套滚动，其实就是让子View无脑接管事件，但是呢，会在处理事件前先给parent处理，然后剩下的给自己，这样就让有些不好实现的效果（比如联动）好做很多</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjl1qvaou0001y4726ms0st71","tag_id":"cjl1qvap20003y4727yzs469d","_id":"cjl1qvapj000cy472rovdm3ol"},{"post_id":"cjl1qvaou0001y4726ms0st71","tag_id":"cjl1qvapb0007y472t6w754a3","_id":"cjl1qvapm000ey472codksrai"},{"post_id":"cjl1qvap00002y472fzegd4y1","tag_id":"cjl1qvaph000ay472i0u3rofj","_id":"cjl1qvapw000ky472laly4e9i"},{"post_id":"cjl1qvap00002y472fzegd4y1","tag_id":"cjl1qvapn000fy472kb7fvwnc","_id":"cjl1qvapx000my472iab8z88x"},{"post_id":"cjl1qvap50004y472t5dcamjq","tag_id":"cjl1qvapu000iy472m1tpybq9","_id":"cjl1qvaq3000ry472oc1bp825"},{"post_id":"cjl1qvap50004y472t5dcamjq","tag_id":"cjl1qvapz000oy472md1lzk5g","_id":"cjl1qvaq3000sy472b2vvxvok"},{"post_id":"cjl1qvap70005y472yxib7sa5","tag_id":"cjl1qvapb0007y472t6w754a3","_id":"cjl1qvaq5000vy472e0kzqtlv"},{"post_id":"cjl1qvap70005y472yxib7sa5","tag_id":"cjl1qvaq4000ty472qpzgtcw1","_id":"cjl1qvaq5000wy472s89t9pn9"},{"post_id":"cjl1qvapa0006y4727tgg540r","tag_id":"cjl1qvaq4000uy472002rpu5z","_id":"cjl1qvaq6000zy472bd890157"},{"post_id":"cjl1qvapa0006y4727tgg540r","tag_id":"cjl1qvapb0007y472t6w754a3","_id":"cjl1qvaq60010y4724e5lycg4"},{"post_id":"cjl1qvapg0009y472t6rsc1lt","tag_id":"cjl1qvaq6000yy472f5lpk13g","_id":"cjl1qvaq80014y472vxejeugn"},{"post_id":"cjl1qvapg0009y472t6rsc1lt","tag_id":"cjl1qvaq60011y4721udpauy1","_id":"cjl1qvaq80015y472wlnv0wmp"},{"post_id":"cjl1qvapg0009y472t6rsc1lt","tag_id":"cjl1qvaq70012y472ev4kdm96","_id":"cjl1qvaq80017y472lmrfs5yf"},{"post_id":"cjl1qvapi000by472hx154hys","tag_id":"cjl1qvaq6000yy472f5lpk13g","_id":"cjl1qvaqb001ay47241gzi4db"},{"post_id":"cjl1qvapi000by472hx154hys","tag_id":"cjl1qvaq80016y4723oj2cb4x","_id":"cjl1qvaqb001by472k6ni27cu"},{"post_id":"cjl1qvapi000by472hx154hys","tag_id":"cjl1qvaq90018y472z7zropzu","_id":"cjl1qvaqb001dy472t18q2v4t"},{"post_id":"cjl1qvapk000dy472kc2su925","tag_id":"cjl1qvaq90019y472j76rzayh","_id":"cjl1qvaqd001fy472of4fx5sx"},{"post_id":"cjl1qvapk000dy472kc2su925","tag_id":"cjl1qvaqb001cy472qpo9hcl9","_id":"cjl1qvaqd001gy472ykhei6x4"},{"post_id":"cjl1qvapp000gy472ctenmgvp","tag_id":"cjl1qvaqc001ey472nk3rgucw","_id":"cjl1qvaqe001jy472v23w11yb"},{"post_id":"cjl1qvapp000gy472ctenmgvp","tag_id":"cjl1qvaqd001hy472y0q0bbkz","_id":"cjl1qvaqe001ky472ktrd837w"},{"post_id":"cjl1qvapq000hy472432ganp2","tag_id":"cjl1qvaqe001iy472o81p1zmt","_id":"cjl1qvaqh001my4723fhjnl45"},{"post_id":"cjl1qvapu000jy472ukmzhils","tag_id":"cjl1qvaqf001ly472ma4fm3mb","_id":"cjl1qvaqi001oy472ranjn18k"},{"post_id":"cjl1qvapu000jy472ukmzhils","tag_id":"cjl1qvapb0007y472t6w754a3","_id":"cjl1qvaqi001py472ibaomhan"},{"post_id":"cjl1qvapw000ly472cr00g6ec","tag_id":"cjl1qvaqh001ny4721i9p0qd1","_id":"cjl1qvaql001sy472qil5u5s0"},{"post_id":"cjl1qvapw000ly472cr00g6ec","tag_id":"cjl1qvaqi001qy472a4nramu1","_id":"cjl1qvaql001ty472kha3krbu"},{"post_id":"cjl1qvapx000ny472iindyrsa","tag_id":"cjl1qvaqk001ry472uca7x38t","_id":"cjl1qvaqn001vy4721pggr5og"},{"post_id":"cjl1qvaq1000py47275kahvun","tag_id":"cjl1qvapb0007y472t6w754a3","_id":"cjl1qvaqn001wy472hoiydzg7"},{"post_id":"cjl1qvaq1000py47275kahvun","tag_id":"cjl1qvaql001uy472jvdt83p6","_id":"cjl1qvaqn001xy472ejwzj8ts"}],"Tag":[{"name":"Gradle","_id":"cjl1qvap20003y4727yzs469d"},{"name":"Android","_id":"cjl1qvapb0007y472t6w754a3"},{"name":"hexo","_id":"cjl1qvaph000ay472i0u3rofj"},{"name":"博客","_id":"cjl1qvapn000fy472kb7fvwnc"},{"name":"MotionLayout","_id":"cjl1qvapu000iy472m1tpybq9"},{"name":"动画","_id":"cjl1qvapz000oy472md1lzk5g"},{"name":"Parcelable","_id":"cjl1qvaq4000ty472qpzgtcw1"},{"name":"RecyclerView LayoutManager LinearLayoutManager","_id":"cjl1qvaq4000uy472002rpu5z"},{"name":"RxJava","_id":"cjl1qvaq6000yy472f5lpk13g"},{"name":"Scheduler","_id":"cjl1qvaq60011y4721udpauy1"},{"name":"线程调度","_id":"cjl1qvaq70012y472ev4kdm96"},{"name":"Producer","_id":"cjl1qvaq80016y4723oj2cb4x"},{"name":"背压","_id":"cjl1qvaq90018y472z7zropzu"},{"name":"SpannableString","_id":"cjl1qvaq90019y472j76rzayh"},{"name":"TextView","_id":"cjl1qvaqb001cy472qpo9hcl9"},{"name":"Rxjava","_id":"cjl1qvaqc001ey472nk3rgucw"},{"name":"Operator","_id":"cjl1qvaqd001hy472y0q0bbkz"},{"name":"AndroidStudio","_id":"cjl1qvaqe001iy472o81p1zmt"},{"name":"DataBinding","_id":"cjl1qvaqf001ly472ma4fm3mb"},{"name":"RecyclerView","_id":"cjl1qvaqh001ny4721i9p0qd1"},{"name":"Fling ItemClick","_id":"cjl1qvaqi001qy472a4nramu1"},{"name":"-RecyclerView -Android","_id":"cjl1qvaqk001ry472uca7x38t"},{"name":"事件分发","_id":"cjl1qvaql001uy472jvdt83p6"}]}}